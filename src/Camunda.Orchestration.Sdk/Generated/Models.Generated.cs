// <auto-generated />
// Generated from OpenAPI spec. DO NOT EDIT.

#nullable enable

using System.Text.Json.Serialization;

namespace Camunda.Orchestration.Sdk.Api;

/// <summary>
/// ActivatedJobResult
/// </summary>
public sealed class ActivatedJobResult
{
    /// <summary>
    /// The type of the job (should match what was requested).
    /// </summary>
    [JsonPropertyName("type")]
    public string Type { get; set; } = null!;

    /// <summary>
    /// The bpmn process ID of the job's process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId ProcessDefinitionId { get; set; }

    /// <summary>
    /// The version of the job's process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionVersion")]
    public int ProcessDefinitionVersion { get; set; }

    /// <summary>
    /// The associated task element ID.
    /// </summary>
    [JsonPropertyName("elementId")]
    public ElementId ElementId { get; set; }

    /// <summary>
    /// A set of custom headers defined during modelling; returned as a serialized JSON document.
    /// </summary>
    [JsonPropertyName("customHeaders")]
    public object CustomHeaders { get; set; } = null!;

    /// <summary>
    /// The name of the worker which activated this job.
    /// </summary>
    [JsonPropertyName("worker")]
    public string Worker { get; set; } = null!;

    /// <summary>
    /// The amount of retries left to this job (should always be positive).
    /// </summary>
    [JsonPropertyName("retries")]
    public int Retries { get; set; }

    /// <summary>
    /// When the job can be activated again, sent as a UNIX epoch timestamp.
    /// </summary>
    [JsonPropertyName("deadline")]
    public long Deadline { get; set; }

    /// <summary>
    /// All variables visible to the task scope, computed at activation time.
    /// </summary>
    [JsonPropertyName("variables")]
    public object Variables { get; set; } = null!;

    /// <summary>
    /// The ID of the tenant that owns the job.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId TenantId { get; set; }

    /// <summary>
    /// The key, a unique identifier for the job.
    /// </summary>
    [JsonPropertyName("jobKey")]
    public JobKey JobKey { get; set; }

    /// <summary>
    /// The job's process instance key.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey ProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the job's process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey ProcessDefinitionKey { get; set; }

    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKey ElementInstanceKey { get; set; }

    /// <summary>
    /// The job kind.
    /// </summary>
    [JsonPropertyName("kind")]
    public JobKindEnum Kind { get; set; }

    /// <summary>
    /// The listener event type of the job.
    /// </summary>
    [JsonPropertyName("listenerEventType")]
    public JobListenerEventTypeEnum ListenerEventType { get; set; }

    /// <summary>
    /// Contains properties of a user task.
    /// </summary>
    [JsonPropertyName("userTask")]
    public UserTaskProperties? UserTask { get; set; }

    /// <summary>
    /// List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
    /// </summary>
    [JsonPropertyName("tags")]
    public List<Tag>? Tags { get; set; }

}

/// <summary>
/// AdHocSubProcessActivateActivitiesInstruction
/// </summary>
public sealed class AdHocSubProcessActivateActivitiesInstruction
{
    /// <summary>
    /// Activities to activate.
    /// </summary>
    [JsonPropertyName("elements")]
    public List<AdHocSubProcessActivateActivityReference> Elements { get; set; } = null!;

    /// <summary>
    /// Whether to cancel remaining instances of the ad-hoc sub-process.
    /// </summary>
    [JsonPropertyName("cancelRemainingInstances")]
    public bool? CancelRemainingInstances { get; set; }

}

/// <summary>
/// AdHocSubProcessActivateActivityReference
/// </summary>
public sealed class AdHocSubProcessActivateActivityReference
{
    /// <summary>
    /// The ID of the element that should be activated.
    /// </summary>
    [JsonPropertyName("elementId")]
    public ElementId ElementId { get; set; }

    /// <summary>
    /// Variables to be set when activating the element.
    /// </summary>
    [JsonPropertyName("variables")]
    public object? Variables { get; set; }

}

/// <summary>
/// Advanced AuditLogActorTypeEnum filter.
/// </summary>
public sealed class AdvancedActorTypeFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public AuditLogActorTypeEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public AuditLogActorTypeEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<AuditLogActorTypeEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced entityKey filter.
/// </summary>
public sealed class AdvancedAuditLogEntityKeyFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public AuditLogEntityKey? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public AuditLogEntityKey? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<AuditLogEntityKey>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<AuditLogEntityKey>? NotIn { get; set; }

}

/// <summary>
/// Advanced AuditLogKey filter.
/// </summary>
public sealed class AdvancedAuditLogKeyFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public AuditLogKey? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public AuditLogKey? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<AuditLogKey>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<AuditLogKey>? NotIn { get; set; }

}

/// <summary>
/// Advanced BatchOperationItemStateEnum filter.
/// </summary>
public sealed class AdvancedBatchOperationItemStateFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public BatchOperationItemStateEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public BatchOperationItemStateEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<BatchOperationItemStateEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced BatchOperationStateEnum filter.
/// </summary>
public sealed class AdvancedBatchOperationStateFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public BatchOperationStateEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public BatchOperationStateEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<BatchOperationStateEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced BatchOperationTypeEnum filter.
/// </summary>
public sealed class AdvancedBatchOperationTypeFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public BatchOperationTypeEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public BatchOperationTypeEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<BatchOperationTypeEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced AuditLogCategoryEnum filter.
/// </summary>
public sealed class AdvancedCategoryFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public AuditLogCategoryEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public AuditLogCategoryEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<AuditLogCategoryEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced ClusterVariableScopeEnum filter.
/// </summary>
public sealed class AdvancedClusterVariableScopeFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public ClusterVariableScopeEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public ClusterVariableScopeEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<ClusterVariableScopeEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced date-time filter.
/// </summary>
public sealed class AdvancedDateTimeFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public DateTimeOffset? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public DateTimeOffset? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Greater than comparison with the provided value.
    /// </summary>
    [JsonPropertyName("$gt")]
    public DateTimeOffset? Gt { get; set; }

    /// <summary>
    /// Greater than or equal comparison with the provided value.
    /// </summary>
    [JsonPropertyName("$gte")]
    public DateTimeOffset? Gte { get; set; }

    /// <summary>
    /// Lower than comparison with the provided value.
    /// </summary>
    [JsonPropertyName("$lt")]
    public DateTimeOffset? Lt { get; set; }

    /// <summary>
    /// Lower than or equal comparison with the provided value.
    /// </summary>
    [JsonPropertyName("$lte")]
    public DateTimeOffset? Lte { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<DateTimeOffset>? In { get; set; }

}

/// <summary>
/// Advanced DecisionDefinitionKey filter.
/// </summary>
public sealed class AdvancedDecisionDefinitionKeyFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public DecisionDefinitionKey? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public DecisionDefinitionKey? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<DecisionDefinitionKey>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<DecisionDefinitionKey>? NotIn { get; set; }

}

/// <summary>
/// Advanced DecisionEvaluationInstanceKey filter.
/// </summary>
public sealed class AdvancedDecisionEvaluationInstanceKeyFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public DecisionEvaluationInstanceKey? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public DecisionEvaluationInstanceKey? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<DecisionEvaluationInstanceKey>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<DecisionEvaluationInstanceKey>? NotIn { get; set; }

}

/// <summary>
/// Advanced DecisionEvaluationKey filter.
/// </summary>
public sealed class AdvancedDecisionEvaluationKeyFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public DecisionEvaluationKey? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public DecisionEvaluationKey? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<DecisionEvaluationKey>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<DecisionEvaluationKey>? NotIn { get; set; }

}

/// <summary>
/// Advanced DecisionInstanceStateEnum filter.
/// </summary>
public sealed class AdvancedDecisionInstanceStateFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public DecisionInstanceStateEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public DecisionInstanceStateEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<DecisionInstanceStateEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<DecisionInstanceStateEnum>? NotIn { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced DecisionRequirementsKey filter.
/// </summary>
public sealed class AdvancedDecisionRequirementsKeyFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public DecisionRequirementsKey? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public DecisionRequirementsKey? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<DecisionRequirementsKey>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<DecisionRequirementsKey>? NotIn { get; set; }

}

/// <summary>
/// Advanced DeploymentKey filter.
/// </summary>
public sealed class AdvancedDeploymentKeyFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public DeploymentKey? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public DeploymentKey? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<DeploymentKey>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<DeploymentKey>? NotIn { get; set; }

}

/// <summary>
/// Advanced ElementInstanceKey filter.
/// </summary>
public sealed class AdvancedElementInstanceKeyFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public ElementInstanceKey? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public ElementInstanceKey? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<ElementInstanceKey>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<ElementInstanceKey>? NotIn { get; set; }

}

/// <summary>
/// Advanced ElementInstanceStateEnum filter.
/// </summary>
public sealed class AdvancedElementInstanceStateFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public ElementInstanceStateEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public ElementInstanceStateEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<ElementInstanceStateEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced AuditLogEntityTypeEnum filter.
/// </summary>
public sealed class AdvancedEntityTypeFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public AuditLogEntityTypeEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public AuditLogEntityTypeEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<AuditLogEntityTypeEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced FormKey filter.
/// </summary>
public sealed class AdvancedFormKeyFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public FormKey? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public FormKey? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<FormKey>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<FormKey>? NotIn { get; set; }

}

/// <summary>
/// Advanced IncidentErrorTypeEnum filter
/// </summary>
public sealed class AdvancedIncidentErrorTypeFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public IncidentErrorTypeEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public IncidentErrorTypeEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<IncidentErrorTypeEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property does not match any of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<IncidentErrorTypeEnum>? NotIn { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced IncidentStateEnum filter
/// </summary>
public sealed class AdvancedIncidentStateFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public IncidentStateEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public IncidentStateEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<IncidentStateEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property does not match any of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<IncidentStateEnum>? NotIn { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced integer (int32) filter.
/// </summary>
public sealed class AdvancedIntegerFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public int? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public int? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Greater than comparison with the provided value.
    /// </summary>
    [JsonPropertyName("$gt")]
    public int? Gt { get; set; }

    /// <summary>
    /// Greater than or equal comparison with the provided value.
    /// </summary>
    [JsonPropertyName("$gte")]
    public int? Gte { get; set; }

    /// <summary>
    /// Lower than comparison with the provided value.
    /// </summary>
    [JsonPropertyName("$lt")]
    public int? Lt { get; set; }

    /// <summary>
    /// Lower than or equal comparison with the provided value.
    /// </summary>
    [JsonPropertyName("$lte")]
    public int? Lte { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<int>? In { get; set; }

}

/// <summary>
/// Advanced JobKey filter.
/// </summary>
public sealed class AdvancedJobKeyFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public JobKey? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public JobKey? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<JobKey>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<JobKey>? NotIn { get; set; }

}

/// <summary>
/// Advanced JobKindEnum filter.
/// </summary>
public sealed class AdvancedJobKindFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public JobKindEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public JobKindEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<JobKindEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced JobListenerEventTypeEnum filter.
/// </summary>
public sealed class AdvancedJobListenerEventTypeFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public JobListenerEventTypeEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public JobListenerEventTypeEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<JobListenerEventTypeEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced JobStateEnum filter.
/// </summary>
public sealed class AdvancedJobStateFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public JobStateEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public JobStateEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<JobStateEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced MessageSubscriptionKey filter.
/// </summary>
public sealed class AdvancedMessageSubscriptionKeyFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public MessageSubscriptionKey? Eq { get; set; }

    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public MessageSubscriptionKey? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<MessageSubscriptionKey>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<MessageSubscriptionKey>? NotIn { get; set; }

}

/// <summary>
/// Advanced MessageSubscriptionStateEnum filter
/// </summary>
public sealed class AdvancedMessageSubscriptionStateFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public MessageSubscriptionStateEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public MessageSubscriptionStateEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<MessageSubscriptionStateEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced AuditLogOperationTypeEnum filter.
/// </summary>
public sealed class AdvancedOperationTypeFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public AuditLogOperationTypeEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public AuditLogOperationTypeEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<AuditLogOperationTypeEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced ProcessDefinitionKey filter.
/// </summary>
public sealed class AdvancedProcessDefinitionKeyFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public ProcessDefinitionKey? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public ProcessDefinitionKey? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<ProcessDefinitionKey>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<ProcessDefinitionKey>? NotIn { get; set; }

}

/// <summary>
/// Advanced ProcessInstanceKey filter.
/// </summary>
public sealed class AdvancedProcessInstanceKeyFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public ProcessInstanceKey? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public ProcessInstanceKey? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<ProcessInstanceKey>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<ProcessInstanceKey>? NotIn { get; set; }

}

/// <summary>
/// Advanced ProcessInstanceStateEnum filter.
/// </summary>
public sealed class AdvancedProcessInstanceStateFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public ProcessInstanceStateEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public ProcessInstanceStateEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<ProcessInstanceStateEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced ResourceKey filter.
/// </summary>
public sealed class AdvancedResourceKeyFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public ResourceKey? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public ResourceKey? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<ResourceKey>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<ResourceKey>? NotIn { get; set; }

}

/// <summary>
/// Advanced AuditLogResultEnum filter.
/// </summary>
public sealed class AdvancedResultFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public AuditLogResultEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public AuditLogResultEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<AuditLogResultEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced ScopeKey filter.
/// </summary>
public sealed class AdvancedScopeKeyFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public ScopeKey? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public ScopeKey? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<ScopeKey>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<ScopeKey>? NotIn { get; set; }

}

/// <summary>
/// Advanced string filter.
/// </summary>
public sealed class AdvancedStringFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public string? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public string? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<string>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<string>? NotIn { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced UserTaskStateEnum filter.
/// </summary>
public sealed class AdvancedUserTaskStateFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public UserTaskStateEnum? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public UserTaskStateEnum? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<UserTaskStateEnum>? In { get; set; }

    /// <summary>
    /// Checks if the property matches the provided like value.
    /// 
    /// Supported wildcard characters are:
    /// 
    /// * `*`: matches zero, one, or multiple characters.
    /// * `?`: matches one, single character.
    /// 
    /// Wildcard characters can be escaped with backslash, for instance: `\*`.
    /// 
    /// </summary>
    [JsonPropertyName("$like")]
    public LikeFilter? Like { get; set; }

}

/// <summary>
/// Advanced VariableKey filter.
/// </summary>
public sealed class AdvancedVariableKeyFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public VariableKey? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public VariableKey? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<VariableKey>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<VariableKey>? NotIn { get; set; }

}

/// <summary>
/// Defines the ancestor scope for the created element instances. The default behavior resembles
/// a "direct" scope instruction with an `ancestorElementInstanceKey` of `"-1"`.
/// 
/// </summary>
/// <remarks>
/// Use one of the following concrete types:
/// <list type="bullet">
/// <item><description><see cref="DirectAncestorKeyInstruction"/></description></item>
/// <item><description><see cref="InferredAncestorKeyInstruction"/></description></item>
/// <item><description><see cref="UseSourceParentKeyInstruction"/></description></item>
/// </list>
/// </remarks>
/// <seealso cref="DirectAncestorKeyInstruction"/>
/// <seealso cref="InferredAncestorKeyInstruction"/>
/// <seealso cref="UseSourceParentKeyInstruction"/>
[JsonDerivedType(typeof(DirectAncestorKeyInstruction))]
[JsonDerivedType(typeof(InferredAncestorKeyInstruction))]
[JsonDerivedType(typeof(UseSourceParentKeyInstruction))]
public abstract class AncestorScopeInstruction { }

/// <summary>
/// The type of actor who performed the operation.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum AuditLogActorTypeEnum
{
    [JsonPropertyName("ANONYMOUS")]
    ANONYMOUS,
    [JsonPropertyName("CLIENT")]
    CLIENT,
    [JsonPropertyName("UNKNOWN")]
    UNKNOWN,
    [JsonPropertyName("USER")]
    USER,
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct AuditLogActorTypeExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private AuditLogActorTypeExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="AuditLogActorTypeExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static AuditLogActorTypeExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "AuditLogActorTypeExactMatch");
        return new AuditLogActorTypeExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// AuditLogActorTypeEnum property with full advanced search capabilities.
/// </summary>
public sealed class AuditLogActorTypeFilterProperty
{
}

/// <summary>
/// The category of the audit log operation.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum AuditLogCategoryEnum
{
    [JsonPropertyName("ADMIN")]
    ADMIN,
    [JsonPropertyName("DEPLOYED_RESOURCES")]
    DEPLOYEDRESOURCES,
    [JsonPropertyName("USER_TASKS")]
    USERTASKS,
}

/// <summary>
/// System-generated entity key for an audit log entry.
/// </summary>
public readonly record struct AuditLogEntityKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private AuditLogEntityKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="AuditLogEntityKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static AuditLogEntityKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "AuditLogEntityKey");
        return new AuditLogEntityKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct AuditLogEntityKeyExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private AuditLogEntityKeyExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="AuditLogEntityKeyExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static AuditLogEntityKeyExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "AuditLogEntityKeyExactMatch");
        return new AuditLogEntityKeyExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// EntityKey property with full advanced search capabilities.
/// </summary>
public sealed class AuditLogEntityKeyFilterProperty
{
}

/// <summary>
/// The type of entity affected by the operation.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum AuditLogEntityTypeEnum
{
    [JsonPropertyName("AUTHORIZATION")]
    AUTHORIZATION,
    [JsonPropertyName("BATCH")]
    BATCH,
    [JsonPropertyName("DECISION")]
    DECISION,
    [JsonPropertyName("GROUP")]
    GROUP,
    [JsonPropertyName("INCIDENT")]
    INCIDENT,
    [JsonPropertyName("MAPPING_RULE")]
    MAPPINGRULE,
    [JsonPropertyName("PROCESS_INSTANCE")]
    PROCESSINSTANCE,
    [JsonPropertyName("RESOURCE")]
    RESOURCE,
    [JsonPropertyName("ROLE")]
    ROLE,
    [JsonPropertyName("TENANT")]
    TENANT,
    [JsonPropertyName("USER")]
    USER,
    [JsonPropertyName("USER_TASK")]
    USERTASK,
    [JsonPropertyName("VARIABLE")]
    VARIABLE,
    [JsonPropertyName("CLIENT")]
    CLIENT,
}

/// <summary>
/// Audit log filter request
/// </summary>
public sealed class AuditLogFilter
{
    /// <summary>
    /// The audit log key search filter.
    /// </summary>
    [JsonPropertyName("auditLogKey")]
    public AuditLogKeyFilterProperty? AuditLogKey { get; set; }

    /// <summary>
    /// The process definition key search filter.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKeyFilterProperty? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The process instance key search filter.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKeyFilterProperty? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The element instance key search filter.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKeyFilterProperty? ElementInstanceKey { get; set; }

    /// <summary>
    /// The operation type search filter.
    /// </summary>
    [JsonPropertyName("operationType")]
    public OperationTypeFilterProperty? OperationType { get; set; }

    /// <summary>
    /// The result search filter.
    /// </summary>
    [JsonPropertyName("result")]
    public AuditLogResultFilterProperty? Result { get; set; }

    /// <summary>
    /// The timestamp search filter.
    /// </summary>
    [JsonPropertyName("timestamp")]
    public DateTimeFilterProperty? Timestamp { get; set; }

    /// <summary>
    /// The actor ID search filter.
    /// </summary>
    [JsonPropertyName("actorId")]
    public StringFilterProperty? ActorId { get; set; }

    /// <summary>
    /// The actor type search filter.
    /// </summary>
    [JsonPropertyName("actorType")]
    public AuditLogActorTypeFilterProperty? ActorType { get; set; }

    /// <summary>
    /// The entity key search filter.
    /// </summary>
    [JsonPropertyName("entityKey")]
    public AuditLogEntityKeyFilterProperty? EntityKey { get; set; }

    /// <summary>
    /// The entity type search filter.
    /// </summary>
    [JsonPropertyName("entityType")]
    public EntityTypeFilterProperty? EntityType { get; set; }

    /// <summary>
    /// The tenant ID search filter.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public StringFilterProperty? TenantId { get; set; }

    /// <summary>
    /// The category search filter.
    /// </summary>
    [JsonPropertyName("category")]
    public CategoryFilterProperty? Category { get; set; }

    /// <summary>
    /// The deployment key search filter.
    /// </summary>
    [JsonPropertyName("deploymentKey")]
    public DeploymentKeyFilterProperty? DeploymentKey { get; set; }

    /// <summary>
    /// The form key search filter.
    /// </summary>
    [JsonPropertyName("formKey")]
    public FormKeyFilterProperty? FormKey { get; set; }

    /// <summary>
    /// The resource key search filter.
    /// </summary>
    [JsonPropertyName("resourceKey")]
    public ResourceKeyFilterProperty? ResourceKey { get; set; }

    /// <summary>
    /// The batch operation type search filter.
    /// </summary>
    [JsonPropertyName("batchOperationType")]
    public BatchOperationTypeFilterProperty? BatchOperationType { get; set; }

    /// <summary>
    /// The process definition ID search filter.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public StringFilterProperty? ProcessDefinitionId { get; set; }

    /// <summary>
    /// The job key search filter.
    /// </summary>
    [JsonPropertyName("jobKey")]
    public JobKeyFilterProperty? JobKey { get; set; }

    /// <summary>
    /// The user task key search filter.
    /// </summary>
    [JsonPropertyName("userTaskKey")]
    public BasicStringFilterProperty? UserTaskKey { get; set; }

    /// <summary>
    /// The decision requirements ID search filter.
    /// </summary>
    [JsonPropertyName("decisionRequirementsId")]
    public StringFilterProperty? DecisionRequirementsId { get; set; }

    /// <summary>
    /// The decision requirements key search filter.
    /// </summary>
    [JsonPropertyName("decisionRequirementsKey")]
    public DecisionRequirementsKeyFilterProperty? DecisionRequirementsKey { get; set; }

    /// <summary>
    /// The decision definition ID search filter.
    /// </summary>
    [JsonPropertyName("decisionDefinitionId")]
    public StringFilterProperty? DecisionDefinitionId { get; set; }

    /// <summary>
    /// The decision definition key search filter.
    /// </summary>
    [JsonPropertyName("decisionDefinitionKey")]
    public DecisionDefinitionKeyFilterProperty? DecisionDefinitionKey { get; set; }

    /// <summary>
    /// The decision evaluation key search filter.
    /// </summary>
    [JsonPropertyName("decisionEvaluationKey")]
    public DecisionEvaluationKeyFilterProperty? DecisionEvaluationKey { get; set; }

    /// <summary>
    /// The related entity key search filter.
    /// </summary>
    [JsonPropertyName("relatedEntityKey")]
    public AuditLogEntityKeyFilterProperty? RelatedEntityKey { get; set; }

    /// <summary>
    /// The related entity type search filter.
    /// </summary>
    [JsonPropertyName("relatedEntityType")]
    public EntityTypeFilterProperty? RelatedEntityType { get; set; }

    /// <summary>
    /// The entity description filter.
    /// </summary>
    [JsonPropertyName("entityDescription")]
    public StringFilterProperty? EntityDescription { get; set; }

}

/// <summary>
/// System-generated key for an audit log entry.
/// </summary>
public readonly record struct AuditLogKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private AuditLogKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="AuditLogKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static AuditLogKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "AuditLogKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new AuditLogKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct AuditLogKeyExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private AuditLogKeyExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="AuditLogKeyExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static AuditLogKeyExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "AuditLogKeyExactMatch");
        return new AuditLogKeyExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// AuditLogKey property with full advanced search capabilities.
/// </summary>
public sealed class AuditLogKeyFilterProperty
{
}

/// <summary>
/// The type of operation performed.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum AuditLogOperationTypeEnum
{
    [JsonPropertyName("ASSIGN")]
    ASSIGN,
    [JsonPropertyName("CANCEL")]
    CANCEL,
    [JsonPropertyName("COMPLETE")]
    COMPLETE,
    [JsonPropertyName("CREATE")]
    CREATE,
    [JsonPropertyName("DELETE")]
    DELETE,
    [JsonPropertyName("EVALUATE")]
    EVALUATE,
    [JsonPropertyName("MIGRATE")]
    MIGRATE,
    [JsonPropertyName("MODIFY")]
    MODIFY,
    [JsonPropertyName("RESOLVE")]
    RESOLVE,
    [JsonPropertyName("RESUME")]
    RESUME,
    [JsonPropertyName("SUSPEND")]
    SUSPEND,
    [JsonPropertyName("UNASSIGN")]
    UNASSIGN,
    [JsonPropertyName("UNKNOWN")]
    UNKNOWN,
    [JsonPropertyName("UPDATE")]
    UPDATE,
}

/// <summary>
/// Audit log item.
/// </summary>
public sealed class AuditLogResult
{
    /// <summary>
    /// The unique key of the audit log entry.
    /// </summary>
    [JsonPropertyName("auditLogKey")]
    public AuditLogKey? AuditLogKey { get; set; }

    /// <summary>
    /// System-generated entity key for an audit log entry.
    /// </summary>
    [JsonPropertyName("entityKey")]
    public AuditLogEntityKey? EntityKey { get; set; }

    /// <summary>
    /// The type of entity affected by the operation.
    /// </summary>
    [JsonPropertyName("entityType")]
    public AuditLogEntityTypeEnum? EntityType { get; set; }

    /// <summary>
    /// The type of operation performed.
    /// </summary>
    [JsonPropertyName("operationType")]
    public AuditLogOperationTypeEnum? OperationType { get; set; }

    /// <summary>
    /// Key of the batch operation.
    /// </summary>
    [JsonPropertyName("batchOperationKey")]
    public BatchOperationKey? BatchOperationKey { get; set; }

    /// <summary>
    /// The type of batch operation performed, if this is part of a batch.
    /// </summary>
    [JsonPropertyName("batchOperationType")]
    public BatchOperationTypeEnum? BatchOperationType { get; set; }

    /// <summary>
    /// The timestamp when the operation occurred.
    /// </summary>
    [JsonPropertyName("timestamp")]
    public DateTimeOffset? Timestamp { get; set; }

    /// <summary>
    /// The ID of the actor who performed the operation.
    /// </summary>
    [JsonPropertyName("actorId")]
    public string? ActorId { get; set; }

    /// <summary>
    /// The type of actor who performed the operation.
    /// </summary>
    [JsonPropertyName("actorType")]
    public AuditLogActorTypeEnum? ActorType { get; set; }

    /// <summary>
    /// The tenant ID of the audit log.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The result status of the operation.
    /// </summary>
    [JsonPropertyName("result")]
    public AuditLogResultEnum? Result { get; set; }

    /// <summary>
    /// Additional notes about the operation.
    /// </summary>
    [JsonPropertyName("annotation")]
    public string? Annotation { get; set; }

    /// <summary>
    /// The category of the audit log operation.
    /// </summary>
    [JsonPropertyName("category")]
    public AuditLogCategoryEnum? Category { get; set; }

    /// <summary>
    /// The process definition ID.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId? ProcessDefinitionId { get; set; }

    /// <summary>
    /// The key of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The key of the process instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the root process instance. The root process instance is the top-level
    /// ancestor in the process instance hierarchy. This field is only present for data
    /// belonging to process instance hierarchies created in version 8.9 or later.
    /// 
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public RootProcessInstanceKey? RootProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the element instance.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKey? ElementInstanceKey { get; set; }

    /// <summary>
    /// The key of the job.
    /// </summary>
    [JsonPropertyName("jobKey")]
    public JobKey? JobKey { get; set; }

    /// <summary>
    /// The key of the user task.
    /// </summary>
    [JsonPropertyName("userTaskKey")]
    public UserTaskKey? UserTaskKey { get; set; }

    /// <summary>
    /// The decision requirements ID.
    /// </summary>
    [JsonPropertyName("decisionRequirementsId")]
    public string? DecisionRequirementsId { get; set; }

    /// <summary>
    /// The assigned key of the decision requirements.
    /// </summary>
    [JsonPropertyName("decisionRequirementsKey")]
    public DecisionRequirementsKey? DecisionRequirementsKey { get; set; }

    /// <summary>
    /// The decision definition ID.
    /// </summary>
    [JsonPropertyName("decisionDefinitionId")]
    public DecisionDefinitionId? DecisionDefinitionId { get; set; }

    /// <summary>
    /// The key of the decision definition.
    /// </summary>
    [JsonPropertyName("decisionDefinitionKey")]
    public DecisionDefinitionKey? DecisionDefinitionKey { get; set; }

    /// <summary>
    /// The key of the decision evaluation.
    /// </summary>
    [JsonPropertyName("decisionEvaluationKey")]
    public DecisionEvaluationKey? DecisionEvaluationKey { get; set; }

    /// <summary>
    /// The key of the deployment.
    /// </summary>
    [JsonPropertyName("deploymentKey")]
    public DeploymentKey? DeploymentKey { get; set; }

    /// <summary>
    /// The key of the form.
    /// </summary>
    [JsonPropertyName("formKey")]
    public FormKey? FormKey { get; set; }

    /// <summary>
    /// The system-assigned key for this resource.
    /// </summary>
    [JsonPropertyName("resourceKey")]
    public ResourceKey? ResourceKey { get; set; }

    /// <summary>
    /// The key of the related entity. The content depends on the operation type and entity type.
    /// For example, for authorization operations, this will contain the ID of the owner (e.g., user or group) the authorization belongs to.
    /// 
    /// </summary>
    [JsonPropertyName("relatedEntityKey")]
    public AuditLogEntityKey? RelatedEntityKey { get; set; }

    /// <summary>
    /// The type of the related entity. The content depends on the operation type and entity type.
    /// For example, for authorization operations, this will contain the type of the owner (e.g., USER or GROUP) the authorization belongs to.
    /// 
    /// </summary>
    [JsonPropertyName("relatedEntityType")]
    public AuditLogEntityTypeEnum? RelatedEntityType { get; set; }

    /// <summary>
    /// Additional description of the entity affected by the operation.
    /// For example, for variable operations, this will contain the variable name.
    /// 
    /// </summary>
    [JsonPropertyName("entityDescription")]
    public string? EntityDescription { get; set; }

}

/// <summary>
/// The result status of the operation.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum AuditLogResultEnum
{
    [JsonPropertyName("FAIL")]
    FAIL,
    [JsonPropertyName("SUCCESS")]
    SUCCESS,
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct AuditLogResultExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private AuditLogResultExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="AuditLogResultExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static AuditLogResultExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "AuditLogResultExactMatch");
        return new AuditLogResultExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// AuditLogResultEnum property with full advanced search capabilities.
/// </summary>
public sealed class AuditLogResultFilterProperty
{
}

/// <summary>
/// Audit log search request.
/// </summary>
public sealed class AuditLogSearchQueryRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<AuditLogSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The audit log search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public AuditLogFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// Audit log search response.
/// </summary>
public sealed class AuditLogSearchQueryResult
{
    /// <summary>
    /// The matching audit logs.
    /// </summary>
    [JsonPropertyName("items")]
    public List<AuditLogResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// AuditLogSearchQuerySortRequest
/// </summary>
public sealed class AuditLogSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// AuthorizationCreateResult
/// </summary>
public sealed class AuthorizationCreateResult
{
    /// <summary>
    /// The key of the created authorization.
    /// </summary>
    [JsonPropertyName("authorizationKey")]
    public AuthorizationKey? AuthorizationKey { get; set; }

}

/// <summary>
/// Authorization search filter.
/// </summary>
public sealed class AuthorizationFilter
{
    /// <summary>
    /// The ID of the owner of permissions.
    /// </summary>
    [JsonPropertyName("ownerId")]
    public string? OwnerId { get; set; }

    /// <summary>
    /// The type of the owner of permissions.
    /// </summary>
    [JsonPropertyName("ownerType")]
    public OwnerTypeEnum? OwnerType { get; set; }

    /// <summary>
    /// The IDs of the resource to search permissions for.
    /// </summary>
    [JsonPropertyName("resourceIds")]
    public List<string>? ResourceIds { get; set; }

    /// <summary>
    /// The names of the resource properties to search permissions for.
    /// </summary>
    [JsonPropertyName("resourcePropertyNames")]
    public List<string>? ResourcePropertyNames { get; set; }

    /// <summary>
    /// The type of resource to search permissions for.
    /// </summary>
    [JsonPropertyName("resourceType")]
    public string? ResourceType { get; set; }

}

/// <summary>
/// AuthorizationIdBasedRequest
/// </summary>
public sealed class AuthorizationIdBasedRequest : AuthorizationRequest
{
    /// <summary>
    /// The ID of the owner of the permissions.
    /// </summary>
    [JsonPropertyName("ownerId")]
    public string OwnerId { get; set; } = null!;

    /// <summary>
    /// The type of the owner of permissions.
    /// </summary>
    [JsonPropertyName("ownerType")]
    public OwnerTypeEnum OwnerType { get; set; }

    /// <summary>
    /// The ID of the resource to add permissions to.
    /// </summary>
    [JsonPropertyName("resourceId")]
    public string ResourceId { get; set; } = null!;

    /// <summary>
    /// The type of resource to add permissions to.
    /// </summary>
    [JsonPropertyName("resourceType")]
    public string ResourceType { get; set; } = null!;

    /// <summary>
    /// The permission types to add.
    /// </summary>
    [JsonPropertyName("permissionTypes")]
    public List<PermissionTypeEnum> PermissionTypes { get; set; } = null!;

}

/// <summary>
/// System-generated key for an authorization.
/// </summary>
public readonly record struct AuthorizationKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private AuthorizationKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="AuthorizationKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static AuthorizationKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "AuthorizationKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new AuthorizationKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// AuthorizationPropertyBasedRequest
/// </summary>
public sealed class AuthorizationPropertyBasedRequest : AuthorizationRequest
{
    /// <summary>
    /// The ID of the owner of the permissions.
    /// </summary>
    [JsonPropertyName("ownerId")]
    public string OwnerId { get; set; } = null!;

    /// <summary>
    /// The type of the owner of permissions.
    /// </summary>
    [JsonPropertyName("ownerType")]
    public OwnerTypeEnum OwnerType { get; set; }

    /// <summary>
    /// The name of the resource property on which this authorization is based.
    /// </summary>
    [JsonPropertyName("resourcePropertyName")]
    public string ResourcePropertyName { get; set; } = null!;

    /// <summary>
    /// The type of resource to add permissions to.
    /// </summary>
    [JsonPropertyName("resourceType")]
    public string ResourceType { get; set; } = null!;

    /// <summary>
    /// The permission types to add.
    /// </summary>
    [JsonPropertyName("permissionTypes")]
    public List<PermissionTypeEnum> PermissionTypes { get; set; } = null!;

}

/// <summary>
/// Defines an authorization request.
/// Either an id-based or a property-based authorization can be provided.
/// 
/// </summary>
/// <remarks>
/// Use one of the following concrete types:
/// <list type="bullet">
/// <item><description><see cref="AuthorizationIdBasedRequest"/></description></item>
/// <item><description><see cref="AuthorizationPropertyBasedRequest"/></description></item>
/// </list>
/// </remarks>
/// <seealso cref="AuthorizationIdBasedRequest"/>
/// <seealso cref="AuthorizationPropertyBasedRequest"/>
[JsonDerivedType(typeof(AuthorizationIdBasedRequest))]
[JsonDerivedType(typeof(AuthorizationPropertyBasedRequest))]
public abstract class AuthorizationRequest { }

/// <summary>
/// AuthorizationResult
/// </summary>
public sealed class AuthorizationResult
{
    /// <summary>
    /// The ID of the owner of permissions.
    /// </summary>
    [JsonPropertyName("ownerId")]
    public string? OwnerId { get; set; }

    /// <summary>
    /// The type of the owner of permissions.
    /// </summary>
    [JsonPropertyName("ownerType")]
    public OwnerTypeEnum? OwnerType { get; set; }

    /// <summary>
    /// The type of resource that the permissions relate to.
    /// </summary>
    [JsonPropertyName("resourceType")]
    public string? ResourceType { get; set; }

    /// <summary>
    /// ID of the resource the permission relates to (mutually exclusive with `resourcePropertyName`).
    /// </summary>
    [JsonPropertyName("resourceId")]
    public string? ResourceId { get; set; }

    /// <summary>
    /// The name of the resource property the permission relates to (mutually exclusive with `resourceId`).
    /// </summary>
    [JsonPropertyName("resourcePropertyName")]
    public string? ResourcePropertyName { get; set; }

    /// <summary>
    /// Specifies the types of the permissions.
    /// </summary>
    [JsonPropertyName("permissionTypes")]
    public List<PermissionTypeEnum>? PermissionTypes { get; set; }

    /// <summary>
    /// The key of the authorization.
    /// </summary>
    [JsonPropertyName("authorizationKey")]
    public AuthorizationKey? AuthorizationKey { get; set; }

}

/// <summary>
/// AuthorizationSearchQuery
/// </summary>
public sealed class AuthorizationSearchQuery
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<AuthorizationSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The authorization search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public AuthorizationFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// AuthorizationSearchQuerySortRequest
/// </summary>
public sealed class AuthorizationSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// AuthorizationSearchResult
/// </summary>
public sealed class AuthorizationSearchResult
{
    /// <summary>
    /// The matching authorizations.
    /// </summary>
    [JsonPropertyName("items")]
    public List<AuthorizationResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// Base process instance search filter.
/// </summary>
public sealed class BaseProcessInstanceFilterFields
{
    /// <summary>
    /// The start date.
    /// </summary>
    [JsonPropertyName("startDate")]
    public DateTimeFilterProperty? StartDate { get; set; }

    /// <summary>
    /// The end date.
    /// </summary>
    [JsonPropertyName("endDate")]
    public DateTimeFilterProperty? EndDate { get; set; }

    /// <summary>
    /// The process instance state.
    /// </summary>
    [JsonPropertyName("state")]
    public ProcessInstanceStateFilterProperty? State { get; set; }

    /// <summary>
    /// Whether this process instance has a related incident or not.
    /// </summary>
    [JsonPropertyName("hasIncident")]
    public bool? HasIncident { get; set; }

    /// <summary>
    /// The tenant id.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public StringFilterProperty? TenantId { get; set; }

    /// <summary>
    /// The process instance variables.
    /// </summary>
    [JsonPropertyName("variables")]
    public List<VariableValueFilterProperty>? Variables { get; set; }

    /// <summary>
    /// The key of this process instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKeyFilterProperty? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The parent process instance key.
    /// </summary>
    [JsonPropertyName("parentProcessInstanceKey")]
    public ProcessInstanceKeyFilterProperty? ParentProcessInstanceKey { get; set; }

    /// <summary>
    /// The parent element instance key.
    /// </summary>
    [JsonPropertyName("parentElementInstanceKey")]
    public ElementInstanceKeyFilterProperty? ParentElementInstanceKey { get; set; }

    /// <summary>
    /// The batch operation id.
    /// </summary>
    [JsonPropertyName("batchOperationId")]
    public StringFilterProperty? BatchOperationId { get; set; }

    /// <summary>
    /// The error message related to the process.
    /// </summary>
    [JsonPropertyName("errorMessage")]
    public StringFilterProperty? ErrorMessage { get; set; }

    /// <summary>
    /// Whether the process has failed jobs with retries left.
    /// </summary>
    [JsonPropertyName("hasRetriesLeft")]
    public bool? HasRetriesLeft { get; set; }

    /// <summary>
    /// The state of the element instances associated with the process instance.
    /// </summary>
    [JsonPropertyName("elementInstanceState")]
    public ElementInstanceStateFilterProperty? ElementInstanceState { get; set; }

    /// <summary>
    /// The element id associated with the process instance.
    /// </summary>
    [JsonPropertyName("elementId")]
    public StringFilterProperty? ElementId { get; set; }

    /// <summary>
    /// Whether the element instance has an incident or not.
    /// </summary>
    [JsonPropertyName("hasElementInstanceIncident")]
    public bool? HasElementInstanceIncident { get; set; }

    /// <summary>
    /// The incident error hash code, associated with this process.
    /// </summary>
    [JsonPropertyName("incidentErrorHashCode")]
    public IntegerFilterProperty? IncidentErrorHashCode { get; set; }

    /// <summary>
    /// List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
    /// </summary>
    [JsonPropertyName("tags")]
    public List<Tag>? Tags { get; set; }

}

/// <summary>
/// Basic advanced string filter.
/// </summary>
public sealed class BasicStringFilter
{
    /// <summary>
    /// Checks for equality with the provided value.
    /// </summary>
    [JsonPropertyName("$eq")]
    public string? Eq { get; set; }

    /// <summary>
    /// Checks for inequality with the provided value.
    /// </summary>
    [JsonPropertyName("$neq")]
    public string? Neq { get; set; }

    /// <summary>
    /// Checks if the current property exists.
    /// </summary>
    [JsonPropertyName("$exists")]
    public bool? Exists { get; set; }

    /// <summary>
    /// Checks if the property matches any of the provided values.
    /// </summary>
    [JsonPropertyName("$in")]
    public List<string>? In { get; set; }

    /// <summary>
    /// Checks if the property matches none of the provided values.
    /// </summary>
    [JsonPropertyName("$notIn")]
    public List<string>? NotIn { get; set; }

}

/// <summary>
/// String property with basic advanced search capabilities.
/// </summary>
public sealed class BasicStringFilterProperty
{
}

/// <summary>
/// The created batch operation.
/// </summary>
public sealed class BatchOperationCreatedResult
{
    /// <summary>
    /// Key of the batch operation.
    /// </summary>
    [JsonPropertyName("batchOperationKey")]
    public BatchOperationKey? BatchOperationKey { get; set; }

    /// <summary>
    /// The type of the batch operation.
    /// </summary>
    [JsonPropertyName("batchOperationType")]
    public BatchOperationTypeEnum? BatchOperationType { get; set; }

}

/// <summary>
/// BatchOperationError
/// </summary>
public sealed class BatchOperationError
{
    /// <summary>
    /// The partition ID where the error occurred.
    /// </summary>
    [JsonPropertyName("partitionId")]
    public int? PartitionId { get; set; }

    /// <summary>
    /// The type of the error that occurred during the batch operation.
    /// </summary>
    [JsonPropertyName("type")]
    public string? Type { get; set; }

    /// <summary>
    /// The error message that occurred during the batch operation.
    /// </summary>
    [JsonPropertyName("message")]
    public string? Message { get; set; }

}

/// <summary>
/// Batch operation filter request.
/// </summary>
public sealed class BatchOperationFilter
{
    /// <summary>
    /// The key (or operate legacy ID) of the batch operation.
    /// </summary>
    [JsonPropertyName("batchOperationKey")]
    public BasicStringFilterProperty? BatchOperationKey { get; set; }

    /// <summary>
    /// The type of the batch operation.
    /// </summary>
    [JsonPropertyName("operationType")]
    public BatchOperationTypeFilterProperty? OperationType { get; set; }

    /// <summary>
    /// The state of the batch operation.
    /// </summary>
    [JsonPropertyName("state")]
    public BatchOperationStateFilterProperty? State { get; set; }

    /// <summary>
    /// The type of the actor who performed the operation.
    /// </summary>
    [JsonPropertyName("actorType")]
    public AuditLogActorTypeEnum? ActorType { get; set; }

    /// <summary>
    /// The ID of the actor who performed the operation.
    /// </summary>
    [JsonPropertyName("actorId")]
    public StringFilterProperty? ActorId { get; set; }

}

/// <summary>
/// Batch operation item filter request.
/// </summary>
public sealed class BatchOperationItemFilter
{
    /// <summary>
    /// The key (or operate legacy ID) of the batch operation.
    /// </summary>
    [JsonPropertyName("batchOperationKey")]
    public BasicStringFilterProperty? BatchOperationKey { get; set; }

    /// <summary>
    /// The key of the item, e.g. a process instance key.
    /// </summary>
    [JsonPropertyName("itemKey")]
    public BasicStringFilterProperty? ItemKey { get; set; }

    /// <summary>
    /// The process instance key of the processed item.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKeyFilterProperty? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The state of the batch operation.
    /// </summary>
    [JsonPropertyName("state")]
    public string? State { get; set; }

    /// <summary>
    /// The type of the batch operation.
    /// </summary>
    [JsonPropertyName("operationType")]
    public BatchOperationTypeFilterProperty? OperationType { get; set; }

}

/// <summary>
/// BatchOperationItemResponse
/// </summary>
public sealed class BatchOperationItemResponse
{
    /// <summary>
    /// The type of the batch operation.
    /// </summary>
    [JsonPropertyName("operationType")]
    public BatchOperationTypeEnum? OperationType { get; set; }

    /// <summary>
    /// The key (or operate legacy ID) of the batch operation.
    /// </summary>
    [JsonPropertyName("batchOperationKey")]
    public BatchOperationKey? BatchOperationKey { get; set; }

    /// <summary>
    /// Key of the item, e.g. a process instance key.
    /// </summary>
    [JsonPropertyName("itemKey")]
    public string? ItemKey { get; set; }

    /// <summary>
    /// the process instance key of the processed item.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the root process instance. The root process instance is the top-level
    /// ancestor in the process instance hierarchy. This field is only present for data
    /// belonging to process instance hierarchies created in version 8.9 or later.
    /// 
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public RootProcessInstanceKey? RootProcessInstanceKey { get; set; }

    /// <summary>
    /// State of the item.
    /// </summary>
    [JsonPropertyName("state")]
    public string? State { get; set; }

    /// <summary>
    /// the date this item was processed.
    /// </summary>
    [JsonPropertyName("processedDate")]
    public DateTimeOffset? ProcessedDate { get; set; }

    /// <summary>
    /// the error message from the engine in case of a failed operation.
    /// </summary>
    [JsonPropertyName("errorMessage")]
    public string? ErrorMessage { get; set; }

}

/// <summary>
/// Batch operation item search request.
/// </summary>
public sealed class BatchOperationItemSearchQuery
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<BatchOperationItemSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The batch operation item search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public BatchOperationItemFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// BatchOperationItemSearchQueryResult
/// </summary>
public sealed class BatchOperationItemSearchQueryResult
{
    /// <summary>
    /// The matching batch operation items.
    /// </summary>
    [JsonPropertyName("items")]
    public List<BatchOperationItemResponse>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// BatchOperationItemSearchQuerySortRequest
/// </summary>
public sealed class BatchOperationItemSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// The batch operation item state.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum BatchOperationItemStateEnum
{
    [JsonPropertyName("ACTIVE")]
    ACTIVE,
    [JsonPropertyName("COMPLETED")]
    COMPLETED,
    [JsonPropertyName("CANCELED")]
    CANCELED,
    [JsonPropertyName("FAILED")]
    FAILED,
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct BatchOperationItemStateExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private BatchOperationItemStateExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="BatchOperationItemStateExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static BatchOperationItemStateExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "BatchOperationItemStateExactMatch");
        return new BatchOperationItemStateExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// BatchOperationItemStateEnum property with full advanced search capabilities.
/// </summary>
public sealed class BatchOperationItemStateFilterProperty
{
}

/// <summary>
/// System-generated key for an batch operation.
/// </summary>
public readonly record struct BatchOperationKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private BatchOperationKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="BatchOperationKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static BatchOperationKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "BatchOperationKey");
        return new BatchOperationKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// BatchOperationResponse
/// </summary>
public sealed class BatchOperationResponse
{
    /// <summary>
    /// Key or (Operate Legacy ID = UUID) of the batch operation.
    /// </summary>
    [JsonPropertyName("batchOperationKey")]
    public BatchOperationKey? BatchOperationKey { get; set; }

    /// <summary>
    /// The batch operation state.
    /// </summary>
    [JsonPropertyName("state")]
    public BatchOperationStateEnum? State { get; set; }

    /// <summary>
    /// The type of the batch operation.
    /// </summary>
    [JsonPropertyName("batchOperationType")]
    public BatchOperationTypeEnum? BatchOperationType { get; set; }

    /// <summary>
    /// The start date of the batch operation.
    /// </summary>
    [JsonPropertyName("startDate")]
    public DateTimeOffset? StartDate { get; set; }

    /// <summary>
    /// The end date of the batch operation.
    /// </summary>
    [JsonPropertyName("endDate")]
    public DateTimeOffset? EndDate { get; set; }

    /// <summary>
    /// The type of actor who performed the operation.
    /// </summary>
    [JsonPropertyName("actorType")]
    public AuditLogActorTypeEnum? ActorType { get; set; }

    /// <summary>
    /// The ID of the actor who performed the operation. Available for batch operations created since 8.9.
    /// </summary>
    [JsonPropertyName("actorId")]
    public string? ActorId { get; set; }

    /// <summary>
    /// The total number of items contained in this batch operation.
    /// </summary>
    [JsonPropertyName("operationsTotalCount")]
    public int? OperationsTotalCount { get; set; }

    /// <summary>
    /// The number of items which failed during execution of the batch operation. (e.g. because they are rejected by the Zeebe engine).
    /// </summary>
    [JsonPropertyName("operationsFailedCount")]
    public int? OperationsFailedCount { get; set; }

    /// <summary>
    /// The number of successfully completed tasks.
    /// </summary>
    [JsonPropertyName("operationsCompletedCount")]
    public int? OperationsCompletedCount { get; set; }

    /// <summary>
    /// The errors that occurred per partition during the batch operation.
    /// </summary>
    [JsonPropertyName("errors")]
    public List<BatchOperationError>? Errors { get; set; }

}

/// <summary>
/// Batch operation search request.
/// </summary>
public sealed class BatchOperationSearchQuery
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<BatchOperationSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The batch operation search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public BatchOperationFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// The batch operation search query result.
/// </summary>
public sealed class BatchOperationSearchQueryResult
{
    /// <summary>
    /// The matching batch operations.
    /// </summary>
    [JsonPropertyName("items")]
    public List<BatchOperationResponse>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// BatchOperationSearchQuerySortRequest
/// </summary>
public sealed class BatchOperationSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// The batch operation state.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum BatchOperationStateEnum
{
    [JsonPropertyName("ACTIVE")]
    ACTIVE,
    [JsonPropertyName("CANCELED")]
    CANCELED,
    [JsonPropertyName("COMPLETED")]
    COMPLETED,
    [JsonPropertyName("CREATED")]
    CREATED,
    [JsonPropertyName("FAILED")]
    FAILED,
    [JsonPropertyName("PARTIALLY_COMPLETED")]
    PARTIALLYCOMPLETED,
    [JsonPropertyName("SUSPENDED")]
    SUSPENDED,
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct BatchOperationStateExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private BatchOperationStateExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="BatchOperationStateExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static BatchOperationStateExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "BatchOperationStateExactMatch");
        return new BatchOperationStateExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// BatchOperationStateEnum property with full advanced search capabilities.
/// </summary>
public sealed class BatchOperationStateFilterProperty
{
}

/// <summary>
/// The type of the batch operation.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum BatchOperationTypeEnum
{
    [JsonPropertyName("ADD_VARIABLE")]
    ADDVARIABLE,
    [JsonPropertyName("CANCEL_PROCESS_INSTANCE")]
    CANCELPROCESSINSTANCE,
    [JsonPropertyName("DELETE_DECISION_DEFINITION")]
    DELETEDECISIONDEFINITION,
    [JsonPropertyName("DELETE_DECISION_INSTANCE")]
    DELETEDECISIONINSTANCE,
    [JsonPropertyName("DELETE_PROCESS_DEFINITION")]
    DELETEPROCESSDEFINITION,
    [JsonPropertyName("DELETE_PROCESS_INSTANCE")]
    DELETEPROCESSINSTANCE,
    [JsonPropertyName("MIGRATE_PROCESS_INSTANCE")]
    MIGRATEPROCESSINSTANCE,
    [JsonPropertyName("MODIFY_PROCESS_INSTANCE")]
    MODIFYPROCESSINSTANCE,
    [JsonPropertyName("RESOLVE_INCIDENT")]
    RESOLVEINCIDENT,
    [JsonPropertyName("UPDATE_VARIABLE")]
    UPDATEVARIABLE,
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct BatchOperationTypeExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private BatchOperationTypeExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="BatchOperationTypeExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static BatchOperationTypeExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "BatchOperationTypeExactMatch");
        return new BatchOperationTypeExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// BatchOperationTypeEnum property with full advanced search capabilities.
/// </summary>
public sealed class BatchOperationTypeFilterProperty
{
}

/// <summary>
/// Provides information on a broker node.
/// </summary>
public sealed class BrokerInfo
{
    /// <summary>
    /// The unique (within a cluster) node ID for the broker.
    /// </summary>
    [JsonPropertyName("nodeId")]
    public int NodeId { get; set; }

    /// <summary>
    /// The hostname for reaching the broker.
    /// </summary>
    [JsonPropertyName("host")]
    public string Host { get; set; } = null!;

    /// <summary>
    /// The port for reaching the broker.
    /// </summary>
    [JsonPropertyName("port")]
    public int Port { get; set; }

    /// <summary>
    /// A list of partitions managed or replicated on this broker.
    /// </summary>
    [JsonPropertyName("partitions")]
    public List<Partition> Partitions { get; set; } = null!;

    /// <summary>
    /// The broker version.
    /// </summary>
    [JsonPropertyName("version")]
    public string Version { get; set; } = null!;

}

/// <summary>
/// CamundaUserResult
/// </summary>
public sealed class CamundaUserResult
{
    /// <summary>
    /// The username of the user.
    /// </summary>
    [JsonPropertyName("username")]
    public Username? Username { get; set; }

    /// <summary>
    /// The display name of the user.
    /// </summary>
    [JsonPropertyName("displayName")]
    public string? DisplayName { get; set; }

    /// <summary>
    /// The email of the user.
    /// </summary>
    [JsonPropertyName("email")]
    public string? Email { get; set; }

    /// <summary>
    /// The web components the user is authorized to use.
    /// </summary>
    [JsonPropertyName("authorizedComponents")]
    public List<string>? AuthorizedComponents { get; set; }

    /// <summary>
    /// The tenants the user is a member of.
    /// </summary>
    [JsonPropertyName("tenants")]
    public List<TenantResult> Tenants { get; set; } = null!;

    /// <summary>
    /// The groups assigned to the user.
    /// </summary>
    [JsonPropertyName("groups")]
    public List<string> Groups { get; set; } = null!;

    /// <summary>
    /// The roles assigned to the user.
    /// </summary>
    [JsonPropertyName("roles")]
    public List<string> Roles { get; set; } = null!;

    /// <summary>
    /// The plan of the user.
    /// </summary>
    [JsonPropertyName("salesPlanType")]
    public string SalesPlanType { get; set; } = null!;

    /// <summary>
    /// The links to the components in the C8 stack.
    /// </summary>
    [JsonPropertyName("c8Links")]
    public Dictionary<string, string> C8Links { get; set; } = null!;

    /// <summary>
    /// Flag for understanding if the user is able to perform logout.
    /// </summary>
    [JsonPropertyName("canLogout")]
    public bool CanLogout { get; set; }

}

/// <summary>
/// CancelProcessInstanceRequest
/// </summary>
public sealed class CancelProcessInstanceRequest
{
    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public OperationReference? OperationReference { get; set; }

}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct CategoryExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private CategoryExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="CategoryExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static CategoryExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "CategoryExactMatch");
        return new CategoryExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// AuditLogCategoryEnum property with full advanced search capabilities.
/// </summary>
public sealed class CategoryFilterProperty
{
}

/// <summary>
/// JSON object with changed task attribute values.
/// 
/// The following attributes can be adjusted with this endpoint, additional attributes
/// will be ignored:
/// 
/// * `candidateGroups` - reset by providing an empty list
/// * `candidateUsers` - reset by providing an empty list
/// * `dueDate` - reset by providing an empty String
/// * `followUpDate` - reset by providing an empty String
/// * `priority` - minimum 0, maximum 100, default 50
/// 
/// Providing any of those attributes with a `null` value or omitting it preserves
/// the persisted attribute's value.
/// 
/// The assignee cannot be adjusted with this endpoint, use the Assign task endpoint.
/// This ensures correct event emission for assignee changes.
/// 
/// </summary>
public sealed class Changeset
{
    /// <summary>
    /// The due date of the task. Reset by providing an empty String.
    /// </summary>
    [JsonPropertyName("dueDate")]
    public DateTimeOffset? DueDate { get; set; }

    /// <summary>
    /// The follow-up date of the task. Reset by providing an empty String.
    /// </summary>
    [JsonPropertyName("followUpDate")]
    public DateTimeOffset? FollowUpDate { get; set; }

    /// <summary>
    /// The list of candidate users of the task. Reset by providing an empty list.
    /// </summary>
    [JsonPropertyName("candidateUsers")]
    public List<string>? CandidateUsers { get; set; }

    /// <summary>
    /// The list of candidate groups of the task. Reset by providing an empty list.
    /// </summary>
    [JsonPropertyName("candidateGroups")]
    public List<string>? CandidateGroups { get; set; }

    /// <summary>
    /// The priority of the task.
    /// </summary>
    [JsonPropertyName("priority")]
    public int? Priority { get; set; }

}

/// <summary>
/// ClockPinRequest
/// </summary>
public sealed class ClockPinRequest
{
    /// <summary>
    /// The exact time in epoch milliseconds to which the clock should be pinned.
    /// </summary>
    [JsonPropertyName("timestamp")]
    public long Timestamp { get; set; }

}

/// <summary>
/// ClusterVariableResult
/// </summary>
public sealed class ClusterVariableResult
{
    /// <summary>
    /// Full value of this cluster variable.
    /// </summary>
    [JsonPropertyName("value")]
    public string Value { get; set; } = null!;

    /// <summary>
    /// The name of the cluster variable. Unique within its scope (global or tenant-specific).
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; } = null!;

    /// <summary>
    /// The scope of a cluster variable.
    /// </summary>
    [JsonPropertyName("scope")]
    public ClusterVariableScopeEnum Scope { get; set; }

    /// <summary>
    /// Only provided if the cluster variable scope is TENANT.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public string? TenantId { get; set; }

}

/// <summary>
/// Cluster variable response item.
/// </summary>
public sealed class ClusterVariableResultBase
{
    /// <summary>
    /// The name of the cluster variable. Unique within its scope (global or tenant-specific).
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; } = null!;

    /// <summary>
    /// The scope of a cluster variable.
    /// </summary>
    [JsonPropertyName("scope")]
    public ClusterVariableScopeEnum Scope { get; set; }

    /// <summary>
    /// Only provided if the cluster variable scope is TENANT.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public string? TenantId { get; set; }

}

/// <summary>
/// The scope of a cluster variable.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum ClusterVariableScopeEnum
{
    [JsonPropertyName("GLOBAL")]
    GLOBAL,
    [JsonPropertyName("TENANT")]
    TENANT,
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct ClusterVariableScopeExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private ClusterVariableScopeExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="ClusterVariableScopeExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static ClusterVariableScopeExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "ClusterVariableScopeExactMatch");
        return new ClusterVariableScopeExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// ClusterVariableScopeEnum property with full advanced search capabilities.
/// </summary>
public sealed class ClusterVariableScopeFilterProperty
{
}

/// <summary>
/// Cluster variable filter request.
/// </summary>
public sealed class ClusterVariableSearchQueryFilterRequest
{
    /// <summary>
    /// Name of the cluster variable.
    /// </summary>
    [JsonPropertyName("name")]
    public StringFilterProperty? Name { get; set; }

    /// <summary>
    /// The value of the cluster variable.
    /// </summary>
    [JsonPropertyName("value")]
    public StringFilterProperty? Value { get; set; }

    /// <summary>
    /// The scope filter for cluster variables.
    /// </summary>
    [JsonPropertyName("scope")]
    public ClusterVariableScopeFilterProperty? Scope { get; set; }

    /// <summary>
    /// Tenant ID of this variable.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public StringFilterProperty? TenantId { get; set; }

    /// <summary>
    /// Filter cluster variables by truncation status of their stored values. When true, returns only variables whose stored values are truncated (i.e., the value exceeds the storage size limit and is truncated in storage). When false, returns only variables with non-truncated stored values. This filter is based on the underlying storage characteristic, not the response format.
    /// 
    /// </summary>
    [JsonPropertyName("isTruncated")]
    public bool? IsTruncated { get; set; }

}

/// <summary>
/// Cluster variable search query request.
/// </summary>
public sealed class ClusterVariableSearchQueryRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<ClusterVariableSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The cluster variable search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public ClusterVariableSearchQueryFilterRequest? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// Cluster variable search query response.
/// </summary>
public sealed class ClusterVariableSearchQueryResult
{
    /// <summary>
    /// The matching cluster variables.
    /// </summary>
    [JsonPropertyName("items")]
    public List<ClusterVariableSearchResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// ClusterVariableSearchQuerySortRequest
/// </summary>
public sealed class ClusterVariableSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// Cluster variable search response item.
/// </summary>
public sealed class ClusterVariableSearchResult
{
    /// <summary>
    /// Value of this cluster variable. Can be truncated.
    /// </summary>
    [JsonPropertyName("value")]
    public string Value { get; set; } = null!;

    /// <summary>
    /// Whether the value is truncated or not.
    /// </summary>
    [JsonPropertyName("isTruncated")]
    public bool? IsTruncated { get; set; }

    /// <summary>
    /// The name of the cluster variable. Unique within its scope (global or tenant-specific).
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; } = null!;

    /// <summary>
    /// The scope of a cluster variable.
    /// </summary>
    [JsonPropertyName("scope")]
    public ClusterVariableScopeEnum Scope { get; set; }

    /// <summary>
    /// Only provided if the cluster variable scope is TENANT.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public string? TenantId { get; set; }

}

/// <summary>
/// ConditionalEvaluationInstruction
/// </summary>
public sealed class ConditionalEvaluationInstruction : global::Camunda.Orchestration.Sdk.Runtime.ITenantIdSettable
{
    /// <summary>
    /// Used to evaluate root-level conditional start events for a tenant with the given ID.
    /// This will only evaluate root-level conditional start events of process definitions which belong to the tenant.
    /// 
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// Used to evaluate root-level conditional start events of the process definition with the given key.
    /// 
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// JSON object representing the variables to use for evaluation of the conditions and to pass to the process instances that have been triggered.
    /// 
    /// </summary>
    [JsonPropertyName("variables")]
    public object Variables { get; set; } = null!;

    /// <inheritdoc />
    public void SetDefaultTenantId(string tenantId) { TenantId ??= global::Camunda.Orchestration.Sdk.Api.TenantId.AssumeExists(tenantId); }

}

/// <summary>
/// System-generated key for a conditional evaluation.
/// </summary>
public readonly record struct ConditionalEvaluationKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private ConditionalEvaluationKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="ConditionalEvaluationKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static ConditionalEvaluationKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "ConditionalEvaluationKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new ConditionalEvaluationKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Correlated message subscriptions search filter.
/// </summary>
public sealed class CorrelatedMessageSubscriptionFilter
{
    /// <summary>
    /// The correlation key of the message.
    /// </summary>
    [JsonPropertyName("correlationKey")]
    public StringFilterProperty? CorrelationKey { get; set; }

    /// <summary>
    /// The time when the message was correlated.
    /// </summary>
    [JsonPropertyName("correlationTime")]
    public DateTimeFilterProperty? CorrelationTime { get; set; }

    /// <summary>
    /// The element ID that received the message.
    /// </summary>
    [JsonPropertyName("elementId")]
    public StringFilterProperty? ElementId { get; set; }

    /// <summary>
    /// The element instance key that received the message.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKeyFilterProperty? ElementInstanceKey { get; set; }

    /// <summary>
    /// The message key.
    /// </summary>
    [JsonPropertyName("messageKey")]
    public BasicStringFilterProperty? MessageKey { get; set; }

    /// <summary>
    /// The name of the message.
    /// </summary>
    [JsonPropertyName("messageName")]
    public StringFilterProperty? MessageName { get; set; }

    /// <summary>
    /// The partition ID that correlated the message.
    /// </summary>
    [JsonPropertyName("partitionId")]
    public IntegerFilterProperty? PartitionId { get; set; }

    /// <summary>
    /// The process definition ID associated with this correlated message subscription.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public StringFilterProperty? ProcessDefinitionId { get; set; }

    /// <summary>
    /// The process definition key associated with this correlated message subscription. For intermediate message events, this only works for data created with 8.9 and later.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKeyFilterProperty? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The process instance key associated with this correlated message subscription.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKeyFilterProperty? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The subscription key that received the message.
    /// </summary>
    [JsonPropertyName("subscriptionKey")]
    public MessageSubscriptionKeyFilterProperty? SubscriptionKey { get; set; }

    /// <summary>
    /// The tenant ID associated with this correlated message subscription.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public StringFilterProperty? TenantId { get; set; }

}

/// <summary>
/// CorrelatedMessageSubscriptionResult
/// </summary>
public sealed class CorrelatedMessageSubscriptionResult
{
    /// <summary>
    /// The correlation key of the message.
    /// </summary>
    [JsonPropertyName("correlationKey")]
    public string CorrelationKey { get; set; } = null!;

    /// <summary>
    /// The time when the message was correlated.
    /// </summary>
    [JsonPropertyName("correlationTime")]
    public DateTimeOffset CorrelationTime { get; set; }

    /// <summary>
    /// The element ID that received the message.
    /// </summary>
    [JsonPropertyName("elementId")]
    public string ElementId { get; set; } = null!;

    /// <summary>
    /// The element instance key that received the message.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKey? ElementInstanceKey { get; set; }

    /// <summary>
    /// The message key.
    /// </summary>
    [JsonPropertyName("messageKey")]
    public MessageKey MessageKey { get; set; }

    /// <summary>
    /// The name of the message.
    /// </summary>
    [JsonPropertyName("messageName")]
    public string MessageName { get; set; } = null!;

    /// <summary>
    /// The partition ID that correlated the message.
    /// </summary>
    [JsonPropertyName("partitionId")]
    public int PartitionId { get; set; }

    /// <summary>
    /// The process definition ID associated with this correlated message subscription.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId ProcessDefinitionId { get; set; }

    /// <summary>
    /// The process definition key associated with this correlated message subscription.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The process instance key associated with this correlated message subscription.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey ProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the root process instance. The root process instance is the top-level
    /// ancestor in the process instance hierarchy. This field is only present for data
    /// belonging to process instance hierarchies created in version 8.9 or later.
    /// 
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public RootProcessInstanceKey? RootProcessInstanceKey { get; set; }

    /// <summary>
    /// The subscription key that received the message.
    /// </summary>
    [JsonPropertyName("subscriptionKey")]
    public MessageSubscriptionKey SubscriptionKey { get; set; }

    /// <summary>
    /// The tenant ID associated with this correlated message subscription.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId TenantId { get; set; }

}

/// <summary>
/// CorrelatedMessageSubscriptionSearchQuery
/// </summary>
public sealed class CorrelatedMessageSubscriptionSearchQuery
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<CorrelatedMessageSubscriptionSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The correlated message subscriptions search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public CorrelatedMessageSubscriptionFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// CorrelatedMessageSubscriptionSearchQueryResult
/// </summary>
public sealed class CorrelatedMessageSubscriptionSearchQueryResult
{
    /// <summary>
    /// The matching correlated message subscriptions.
    /// </summary>
    [JsonPropertyName("items")]
    public List<CorrelatedMessageSubscriptionResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// CorrelatedMessageSubscriptionSearchQuerySortRequest
/// </summary>
public sealed class CorrelatedMessageSubscriptionSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// CreateClusterVariableRequest
/// </summary>
public sealed class CreateClusterVariableRequest
{
    /// <summary>
    /// The name of the cluster variable. Must be unique within its scope (global or tenant-specific).
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; } = null!;

    /// <summary>
    /// The value of the cluster variable. Can be any JSON object or primitive value. Will be serialized as a JSON string in responses.
    /// </summary>
    [JsonPropertyName("value")]
    public object Value { get; set; } = null!;

}

/// <summary>
/// CreateProcessInstanceResult
/// </summary>
public sealed class CreateProcessInstanceResult
{
    /// <summary>
    /// The BPMN process id of the process definition which was used to create the process.
    /// instance
    /// 
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId ProcessDefinitionId { get; set; }

    /// <summary>
    /// The version of the process definition which was used to create the process instance.
    /// 
    /// </summary>
    [JsonPropertyName("processDefinitionVersion")]
    public int ProcessDefinitionVersion { get; set; }

    /// <summary>
    /// The tenant id of the created process instance.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId TenantId { get; set; }

    /// <summary>
    /// All the variables visible in the root scope.
    /// </summary>
    [JsonPropertyName("variables")]
    public object Variables { get; set; } = null!;

    /// <summary>
    /// The key of the process definition which was used to create the process instance.
    /// 
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The unique identifier of the created process instance; to be used wherever a request
    /// needs a process instance key (e.g. CancelProcessInstanceRequest).
    /// 
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey ProcessInstanceKey { get; set; }

    /// <summary>
    /// List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
    /// </summary>
    [JsonPropertyName("tags")]
    public List<Tag>? Tags { get; set; }

}

/// <summary>
/// CursorBackwardPagination
/// </summary>
public sealed class CursorBackwardPagination : SearchQueryPageRequest
{
    /// <summary>
    /// Use the `startCursor` value from the previous response to fetch the previous page of results.
    /// </summary>
    [JsonPropertyName("before")]
    public StartCursor Before { get; set; }

    /// <summary>
    /// The maximum number of items to return in one request.
    /// </summary>
    [JsonPropertyName("limit")]
    public int? Limit { get; set; }

}

/// <summary>
/// CursorForwardPagination
/// </summary>
public sealed class CursorForwardPagination : SearchQueryPageRequest
{
    /// <summary>
    /// Use the `endCursor` value from the previous response to fetch the next page of results.
    /// </summary>
    [JsonPropertyName("after")]
    public EndCursor After { get; set; }

    /// <summary>
    /// The maximum number of items to return in one request.
    /// </summary>
    [JsonPropertyName("limit")]
    public int? Limit { get; set; }

}

/// <summary>
/// Date-time property with full advanced search capabilities.
/// </summary>
public sealed class DateTimeFilterProperty
{
}

/// <summary>
/// Decision definition search filter.
/// </summary>
public sealed class DecisionDefinitionFilter
{
    /// <summary>
    /// The DMN ID of the decision definition.
    /// </summary>
    [JsonPropertyName("decisionDefinitionId")]
    public DecisionDefinitionId? DecisionDefinitionId { get; set; }

    /// <summary>
    /// The DMN name of the decision definition.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// Whether to only return the latest version of each decision definition.
    /// When using this filter, pagination functionality is limited, you can only paginate forward using `after` and `limit`.
    /// The response contains no `startCursor` in the `page`, and requests ignore the `from` and `before` in the `page`.
    /// 
    /// </summary>
    [JsonPropertyName("isLatestVersion")]
    public bool? IsLatestVersion { get; set; }

    /// <summary>
    /// The assigned version of the decision definition.
    /// </summary>
    [JsonPropertyName("version")]
    public int? Version { get; set; }

    /// <summary>
    /// the DMN ID of the decision requirements graph that the decision definition is part of.
    /// </summary>
    [JsonPropertyName("decisionRequirementsId")]
    public string? DecisionRequirementsId { get; set; }

    /// <summary>
    /// The tenant ID of the decision definition.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The assigned key, which acts as a unique identifier for this decision definition.
    /// </summary>
    [JsonPropertyName("decisionDefinitionKey")]
    public DecisionDefinitionKey? DecisionDefinitionKey { get; set; }

    /// <summary>
    /// The assigned key of the decision requirements graph that the decision definition is part of.
    /// </summary>
    [JsonPropertyName("decisionRequirementsKey")]
    public DecisionRequirementsKey? DecisionRequirementsKey { get; set; }

    /// <summary>
    /// The DMN name of the decision requirements that the decision definition is part of.
    /// </summary>
    [JsonPropertyName("decisionRequirementsName")]
    public string? DecisionRequirementsName { get; set; }

    /// <summary>
    /// The assigned version of the decision requirements that the decision definition is part of.
    /// </summary>
    [JsonPropertyName("decisionRequirementsVersion")]
    public int? DecisionRequirementsVersion { get; set; }

}

/// <summary>
/// Id of a decision definition, from the model. Only ids of decision definitions that are deployed are useful.
/// </summary>
public readonly record struct DecisionDefinitionId : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private DecisionDefinitionId(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="DecisionDefinitionId"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static DecisionDefinitionId AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "DecisionDefinitionId", pattern: @"^[A-Za-z0-9_@.+-]+$", minLength: 1, maxLength: 256);
        return new DecisionDefinitionId(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^[A-Za-z0-9_@.+-]+$", minLength: 1, maxLength: 256);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// System-generated key for a decision definition.
/// </summary>
public readonly record struct DecisionDefinitionKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private DecisionDefinitionKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="DecisionDefinitionKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static DecisionDefinitionKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "DecisionDefinitionKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new DecisionDefinitionKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct DecisionDefinitionKeyExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private DecisionDefinitionKeyExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="DecisionDefinitionKeyExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static DecisionDefinitionKeyExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "DecisionDefinitionKeyExactMatch");
        return new DecisionDefinitionKeyExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// DecisionDefinitionKey property with full advanced search capabilities.
/// </summary>
public sealed class DecisionDefinitionKeyFilterProperty
{
}

/// <summary>
/// DecisionDefinitionResult
/// </summary>
public sealed class DecisionDefinitionResult
{
    /// <summary>
    /// The DMN ID of the decision definition.
    /// </summary>
    [JsonPropertyName("decisionDefinitionId")]
    public DecisionDefinitionId? DecisionDefinitionId { get; set; }

    /// <summary>
    /// The DMN name of the decision definition.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The assigned version of the decision definition.
    /// </summary>
    [JsonPropertyName("version")]
    public int? Version { get; set; }

    /// <summary>
    /// the DMN ID of the decision requirements graph that the decision definition is part of.
    /// </summary>
    [JsonPropertyName("decisionRequirementsId")]
    public string? DecisionRequirementsId { get; set; }

    /// <summary>
    /// The tenant ID of the decision definition.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The assigned key, which acts as a unique identifier for this decision definition.
    /// </summary>
    [JsonPropertyName("decisionDefinitionKey")]
    public DecisionDefinitionKey? DecisionDefinitionKey { get; set; }

    /// <summary>
    /// The assigned key of the decision requirements graph that the decision definition is part of.
    /// </summary>
    [JsonPropertyName("decisionRequirementsKey")]
    public DecisionRequirementsKey? DecisionRequirementsKey { get; set; }

    /// <summary>
    /// The DMN name of the decision requirements that the decision definition is part of.
    /// </summary>
    [JsonPropertyName("decisionRequirementsName")]
    public string? DecisionRequirementsName { get; set; }

    /// <summary>
    /// The assigned version of the decision requirements that the decision definition is part of.
    /// </summary>
    [JsonPropertyName("decisionRequirementsVersion")]
    public int? DecisionRequirementsVersion { get; set; }

}

/// <summary>
/// DecisionDefinitionSearchQuery
/// </summary>
public sealed class DecisionDefinitionSearchQuery
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<DecisionDefinitionSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The decision definition search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public DecisionDefinitionFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// DecisionDefinitionSearchQueryResult
/// </summary>
public sealed class DecisionDefinitionSearchQueryResult
{
    /// <summary>
    /// The matching decision definitions.
    /// </summary>
    [JsonPropertyName("items")]
    public List<DecisionDefinitionResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// DecisionDefinitionSearchQuerySortRequest
/// </summary>
public sealed class DecisionDefinitionSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// The type of the decision.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum DecisionDefinitionTypeEnum
{
    [JsonPropertyName("DECISION_TABLE")]
    DECISIONTABLE,
    [JsonPropertyName("LITERAL_EXPRESSION")]
    LITERALEXPRESSION,
    [JsonPropertyName("UNKNOWN")]
    UNKNOWN,
}

/// <summary>
/// DecisionEvaluationById
/// </summary>
public sealed class DecisionEvaluationById : DecisionEvaluationInstruction, global::Camunda.Orchestration.Sdk.Runtime.ITenantIdSettable
{
    /// <summary>
    /// The ID of the decision to be evaluated.
    /// When using the decision ID, the latest
    /// deployed version of the decision is used.
    /// 
    /// </summary>
    [JsonPropertyName("decisionDefinitionId")]
    public DecisionDefinitionId DecisionDefinitionId { get; set; }

    /// <summary>
    /// The message variables as JSON document.
    /// </summary>
    [JsonPropertyName("variables")]
    public object? Variables { get; set; }

    /// <summary>
    /// The tenant ID of the decision.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <inheritdoc />
    public void SetDefaultTenantId(string tenantId) { TenantId ??= global::Camunda.Orchestration.Sdk.Api.TenantId.AssumeExists(tenantId); }

}

/// <summary>
/// DecisionEvaluationByKey
/// </summary>
public sealed class DecisionEvaluationByKey : DecisionEvaluationInstruction, global::Camunda.Orchestration.Sdk.Runtime.ITenantIdSettable
{
    /// <summary>
    /// System-generated key for a decision definition.
    /// </summary>
    [JsonPropertyName("decisionDefinitionKey")]
    public DecisionDefinitionKey DecisionDefinitionKey { get; set; }

    /// <summary>
    /// The message variables as JSON document.
    /// </summary>
    [JsonPropertyName("variables")]
    public object? Variables { get; set; }

    /// <summary>
    /// The tenant ID of the decision.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <inheritdoc />
    public void SetDefaultTenantId(string tenantId) { TenantId ??= global::Camunda.Orchestration.Sdk.Api.TenantId.AssumeExists(tenantId); }

}

/// <summary>
/// System-generated key for a decision evaluation instance.
/// </summary>
public readonly record struct DecisionEvaluationInstanceKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private DecisionEvaluationInstanceKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="DecisionEvaluationInstanceKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static DecisionEvaluationInstanceKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "DecisionEvaluationInstanceKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new DecisionEvaluationInstanceKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct DecisionEvaluationInstanceKeyExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private DecisionEvaluationInstanceKeyExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="DecisionEvaluationInstanceKeyExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static DecisionEvaluationInstanceKeyExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "DecisionEvaluationInstanceKeyExactMatch");
        return new DecisionEvaluationInstanceKeyExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// DecisionEvaluationInstanceKey property with full advanced search capabilities.
/// </summary>
public sealed class DecisionEvaluationInstanceKeyFilterProperty
{
}

/// <summary>
/// DecisionEvaluationInstruction
/// </summary>
/// <remarks>
/// Use one of the following concrete types:
/// <list type="bullet">
/// <item><description><see cref="DecisionEvaluationById"/></description></item>
/// <item><description><see cref="DecisionEvaluationByKey"/></description></item>
/// </list>
/// </remarks>
/// <seealso cref="DecisionEvaluationById"/>
/// <seealso cref="DecisionEvaluationByKey"/>
[JsonDerivedType(typeof(DecisionEvaluationById))]
[JsonDerivedType(typeof(DecisionEvaluationByKey))]
public abstract class DecisionEvaluationInstruction { }

/// <summary>
/// System-generated key for a decision evaluation.
/// </summary>
public readonly record struct DecisionEvaluationKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private DecisionEvaluationKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="DecisionEvaluationKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static DecisionEvaluationKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "DecisionEvaluationKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new DecisionEvaluationKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct DecisionEvaluationKeyExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private DecisionEvaluationKeyExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="DecisionEvaluationKeyExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static DecisionEvaluationKeyExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "DecisionEvaluationKeyExactMatch");
        return new DecisionEvaluationKeyExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// DecisionEvaluationKey property with full advanced search capabilities.
/// </summary>
public sealed class DecisionEvaluationKeyFilterProperty
{
}

/// <summary>
/// The decision instance filter that defines which decision instances should be deleted.
/// </summary>
public sealed class DecisionInstanceDeletionBatchOperationRequest
{
    /// <summary>
    /// The decision instance filter.
    /// </summary>
    [JsonPropertyName("filter")]
    public DecisionInstanceFilter Filter { get; set; } = null!;

    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public OperationReference? OperationReference { get; set; }

}

/// <summary>
/// Decision instance search filter.
/// </summary>
public sealed class DecisionInstanceFilter
{
    /// <summary>
    /// The key of the decision evaluation instance.
    /// </summary>
    [JsonPropertyName("decisionEvaluationInstanceKey")]
    public DecisionEvaluationInstanceKeyFilterProperty? DecisionEvaluationInstanceKey { get; set; }

    /// <summary>
    /// The state of the decision instance.
    /// </summary>
    [JsonPropertyName("state")]
    public DecisionInstanceStateFilterProperty? State { get; set; }

    /// <summary>
    /// The evaluation failure of the decision instance.
    /// </summary>
    [JsonPropertyName("evaluationFailure")]
    public string? EvaluationFailure { get; set; }

    /// <summary>
    /// The evaluation date of the decision instance.
    /// </summary>
    [JsonPropertyName("evaluationDate")]
    public DateTimeFilterProperty? EvaluationDate { get; set; }

    /// <summary>
    /// The ID of the DMN decision.
    /// </summary>
    [JsonPropertyName("decisionDefinitionId")]
    public DecisionDefinitionId? DecisionDefinitionId { get; set; }

    /// <summary>
    /// The name of the DMN decision.
    /// </summary>
    [JsonPropertyName("decisionDefinitionName")]
    public string? DecisionDefinitionName { get; set; }

    /// <summary>
    /// The version of the decision.
    /// </summary>
    [JsonPropertyName("decisionDefinitionVersion")]
    public int? DecisionDefinitionVersion { get; set; }

    /// <summary>
    /// The type of the decision.
    /// </summary>
    [JsonPropertyName("decisionDefinitionType")]
    public DecisionDefinitionTypeEnum? DecisionDefinitionType { get; set; }

    /// <summary>
    /// The tenant ID of the decision instance.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The key of the parent decision evaluation. Note that this is not the identifier of an individual decision instance; the `decisionEvaluationInstanceKey` is the identifier for a decision instance.
    /// 
    /// </summary>
    [JsonPropertyName("decisionEvaluationKey")]
    public DecisionEvaluationKey? DecisionEvaluationKey { get; set; }

    /// <summary>
    /// The key of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The key of the process instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the decision.
    /// </summary>
    [JsonPropertyName("decisionDefinitionKey")]
    public DecisionDefinitionKeyFilterProperty? DecisionDefinitionKey { get; set; }

    /// <summary>
    /// The key of the element instance this decision instance is linked to.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKeyFilterProperty? ElementInstanceKey { get; set; }

    /// <summary>
    /// The key of the root decision definition.
    /// </summary>
    [JsonPropertyName("rootDecisionDefinitionKey")]
    public DecisionDefinitionKeyFilterProperty? RootDecisionDefinitionKey { get; set; }

    /// <summary>
    /// The key of the decision requirements definition.
    /// </summary>
    [JsonPropertyName("decisionRequirementsKey")]
    public DecisionRequirementsKeyFilterProperty? DecisionRequirementsKey { get; set; }

}

/// <summary>
/// DecisionInstanceGetQueryResult
/// </summary>
public sealed class DecisionInstanceGetQueryResult
{
    /// <summary>
    /// System-generated key for a decision evaluation instance.
    /// </summary>
    [JsonPropertyName("decisionEvaluationInstanceKey")]
    public DecisionEvaluationInstanceKey? DecisionEvaluationInstanceKey { get; set; }

    /// <summary>
    /// The state of the decision instance.
    /// </summary>
    [JsonPropertyName("state")]
    public DecisionInstanceStateEnum? State { get; set; }

    /// <summary>
    /// The evaluation date of the decision instance.
    /// </summary>
    [JsonPropertyName("evaluationDate")]
    public DateTimeOffset? EvaluationDate { get; set; }

    /// <summary>
    /// The evaluation failure of the decision instance.
    /// </summary>
    [JsonPropertyName("evaluationFailure")]
    public string? EvaluationFailure { get; set; }

    /// <summary>
    /// The ID of the DMN decision.
    /// </summary>
    [JsonPropertyName("decisionDefinitionId")]
    public DecisionDefinitionId? DecisionDefinitionId { get; set; }

    /// <summary>
    /// The name of the DMN decision.
    /// </summary>
    [JsonPropertyName("decisionDefinitionName")]
    public string? DecisionDefinitionName { get; set; }

    /// <summary>
    /// The version of the decision.
    /// </summary>
    [JsonPropertyName("decisionDefinitionVersion")]
    public int? DecisionDefinitionVersion { get; set; }

    /// <summary>
    /// The type of the decision.
    /// </summary>
    [JsonPropertyName("decisionDefinitionType")]
    public DecisionDefinitionTypeEnum? DecisionDefinitionType { get; set; }

    /// <summary>
    /// The result of the decision instance.
    /// </summary>
    [JsonPropertyName("result")]
    public string? Result { get; set; }

    /// <summary>
    /// The tenant ID of the decision instance.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The key of the decision evaluation where this instance was created.
    /// </summary>
    [JsonPropertyName("decisionEvaluationKey")]
    public DecisionEvaluationKey? DecisionEvaluationKey { get; set; }

    /// <summary>
    /// The key of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The key of the process instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the root process instance. The root process instance is the top-level
    /// ancestor in the process instance hierarchy. This field is only present for data
    /// belonging to process instance hierarchies created in version 8.9 or later.
    /// 
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public RootProcessInstanceKey? RootProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the decision.
    /// </summary>
    [JsonPropertyName("decisionDefinitionKey")]
    public DecisionDefinitionKey? DecisionDefinitionKey { get; set; }

    /// <summary>
    /// The key of the element instance this decision instance is linked to.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKey? ElementInstanceKey { get; set; }

    /// <summary>
    /// The key of the root decision definition.
    /// </summary>
    [JsonPropertyName("rootDecisionDefinitionKey")]
    public DecisionDefinitionKey? RootDecisionDefinitionKey { get; set; }

    /// <summary>
    /// The evaluated inputs of the decision instance.
    /// 
    /// </summary>
    [JsonPropertyName("evaluatedInputs")]
    public List<EvaluatedDecisionInputItem>? EvaluatedInputs { get; set; }

    /// <summary>
    /// The matched rules of the decision instance.
    /// 
    /// </summary>
    [JsonPropertyName("matchedRules")]
    public List<MatchedDecisionRuleItem>? MatchedRules { get; set; }

}

/// <summary>
/// System-generated key for a deployed decision instance.
/// </summary>
public readonly record struct DecisionInstanceKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private DecisionInstanceKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="DecisionInstanceKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static DecisionInstanceKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "DecisionInstanceKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new DecisionInstanceKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// DecisionInstanceResult
/// </summary>
public sealed class DecisionInstanceResult
{
    /// <summary>
    /// System-generated key for a decision evaluation instance.
    /// </summary>
    [JsonPropertyName("decisionEvaluationInstanceKey")]
    public DecisionEvaluationInstanceKey? DecisionEvaluationInstanceKey { get; set; }

    /// <summary>
    /// The state of the decision instance.
    /// </summary>
    [JsonPropertyName("state")]
    public DecisionInstanceStateEnum? State { get; set; }

    /// <summary>
    /// The evaluation date of the decision instance.
    /// </summary>
    [JsonPropertyName("evaluationDate")]
    public DateTimeOffset? EvaluationDate { get; set; }

    /// <summary>
    /// The evaluation failure of the decision instance.
    /// </summary>
    [JsonPropertyName("evaluationFailure")]
    public string? EvaluationFailure { get; set; }

    /// <summary>
    /// The ID of the DMN decision.
    /// </summary>
    [JsonPropertyName("decisionDefinitionId")]
    public DecisionDefinitionId? DecisionDefinitionId { get; set; }

    /// <summary>
    /// The name of the DMN decision.
    /// </summary>
    [JsonPropertyName("decisionDefinitionName")]
    public string? DecisionDefinitionName { get; set; }

    /// <summary>
    /// The version of the decision.
    /// </summary>
    [JsonPropertyName("decisionDefinitionVersion")]
    public int? DecisionDefinitionVersion { get; set; }

    /// <summary>
    /// The type of the decision.
    /// </summary>
    [JsonPropertyName("decisionDefinitionType")]
    public DecisionDefinitionTypeEnum? DecisionDefinitionType { get; set; }

    /// <summary>
    /// The result of the decision instance.
    /// </summary>
    [JsonPropertyName("result")]
    public string? Result { get; set; }

    /// <summary>
    /// The tenant ID of the decision instance.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The key of the decision evaluation where this instance was created.
    /// </summary>
    [JsonPropertyName("decisionEvaluationKey")]
    public DecisionEvaluationKey? DecisionEvaluationKey { get; set; }

    /// <summary>
    /// The key of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The key of the process instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the root process instance. The root process instance is the top-level
    /// ancestor in the process instance hierarchy. This field is only present for data
    /// belonging to process instance hierarchies created in version 8.9 or later.
    /// 
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public RootProcessInstanceKey? RootProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the decision.
    /// </summary>
    [JsonPropertyName("decisionDefinitionKey")]
    public DecisionDefinitionKey? DecisionDefinitionKey { get; set; }

    /// <summary>
    /// The key of the element instance this decision instance is linked to.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKey? ElementInstanceKey { get; set; }

    /// <summary>
    /// The key of the root decision definition.
    /// </summary>
    [JsonPropertyName("rootDecisionDefinitionKey")]
    public DecisionDefinitionKey? RootDecisionDefinitionKey { get; set; }

}

/// <summary>
/// DecisionInstanceSearchQuery
/// </summary>
public sealed class DecisionInstanceSearchQuery
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<DecisionInstanceSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The decision instance search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public DecisionInstanceFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// DecisionInstanceSearchQueryResult
/// </summary>
public sealed class DecisionInstanceSearchQueryResult
{
    /// <summary>
    /// The matching decision instances.
    /// </summary>
    [JsonPropertyName("items")]
    public List<DecisionInstanceResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// DecisionInstanceSearchQuerySortRequest
/// </summary>
public sealed class DecisionInstanceSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// The state of the decision instance.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum DecisionInstanceStateEnum
{
    [JsonPropertyName("EVALUATED")]
    EVALUATED,
    [JsonPropertyName("FAILED")]
    FAILED,
    [JsonPropertyName("UNSPECIFIED")]
    UNSPECIFIED,
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct DecisionInstanceStateExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private DecisionInstanceStateExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="DecisionInstanceStateExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static DecisionInstanceStateExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "DecisionInstanceStateExactMatch");
        return new DecisionInstanceStateExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// DecisionInstanceStateEnum property with full advanced search capabilities.
/// </summary>
public sealed class DecisionInstanceStateFilterProperty
{
}

/// <summary>
/// Decision requirements search filter.
/// </summary>
public sealed class DecisionRequirementsFilter
{
    /// <summary>
    /// The DMN name of the decision requirements.
    /// </summary>
    [JsonPropertyName("decisionRequirementsName")]
    public string? DecisionRequirementsName { get; set; }

    /// <summary>
    /// the DMN ID of the decision requirements.
    /// </summary>
    [JsonPropertyName("decisionRequirementsId")]
    public string? DecisionRequirementsId { get; set; }

    /// <summary>
    /// System-generated key for a deployed decision requirements definition.
    /// </summary>
    [JsonPropertyName("decisionRequirementsKey")]
    public DecisionRequirementsKey? DecisionRequirementsKey { get; set; }

    /// <summary>
    /// The assigned version of the decision requirements.
    /// </summary>
    [JsonPropertyName("version")]
    public int? Version { get; set; }

    /// <summary>
    /// The tenant ID of the decision requirements.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The name of the resource from which the decision requirements were parsed
    /// </summary>
    [JsonPropertyName("resourceName")]
    public string? ResourceName { get; set; }

}

/// <summary>
/// System-generated key for a deployed decision requirements definition.
/// </summary>
public readonly record struct DecisionRequirementsKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private DecisionRequirementsKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="DecisionRequirementsKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static DecisionRequirementsKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "DecisionRequirementsKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new DecisionRequirementsKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct DecisionRequirementsKeyExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private DecisionRequirementsKeyExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="DecisionRequirementsKeyExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static DecisionRequirementsKeyExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "DecisionRequirementsKeyExactMatch");
        return new DecisionRequirementsKeyExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// DecisionRequirementsKey property with full advanced search capabilities.
/// </summary>
public sealed class DecisionRequirementsKeyFilterProperty
{
}

/// <summary>
/// DecisionRequirementsResult
/// </summary>
public sealed class DecisionRequirementsResult
{
    /// <summary>
    /// The DMN name of the decision requirements.
    /// </summary>
    [JsonPropertyName("decisionRequirementsName")]
    public string? DecisionRequirementsName { get; set; }

    /// <summary>
    /// The assigned version of the decision requirements.
    /// </summary>
    [JsonPropertyName("version")]
    public int? Version { get; set; }

    /// <summary>
    /// The DMN ID of the decision requirements.
    /// </summary>
    [JsonPropertyName("decisionRequirementsId")]
    public string? DecisionRequirementsId { get; set; }

    /// <summary>
    /// The name of the resource from which this decision requirements was parsed.
    /// </summary>
    [JsonPropertyName("resourceName")]
    public string? ResourceName { get; set; }

    /// <summary>
    /// The tenant ID of the decision requirements.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The assigned key, which acts as a unique identifier for this decision requirements.
    /// </summary>
    [JsonPropertyName("decisionRequirementsKey")]
    public DecisionRequirementsKey? DecisionRequirementsKey { get; set; }

}

/// <summary>
/// DecisionRequirementsSearchQuery
/// </summary>
public sealed class DecisionRequirementsSearchQuery
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<DecisionRequirementsSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The decision definition search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public DecisionRequirementsFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// DecisionRequirementsSearchQueryResult
/// </summary>
public sealed class DecisionRequirementsSearchQueryResult
{
    /// <summary>
    /// The matching decision requirements.
    /// </summary>
    [JsonPropertyName("items")]
    public List<DecisionRequirementsResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// DecisionRequirementsSearchQuerySortRequest
/// </summary>
public sealed class DecisionRequirementsSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// DeleteDecisionInstanceRequest
/// </summary>
public sealed class DeleteDecisionInstanceRequest
{
    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public OperationReference? OperationReference { get; set; }

}

/// <summary>
/// DeleteProcessInstanceRequest
/// </summary>
public sealed class DeleteProcessInstanceRequest
{
    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public OperationReference? OperationReference { get; set; }

}

/// <summary>
/// DeleteResourceRequest
/// </summary>
public sealed class DeleteResourceRequest
{
    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public OperationReference? OperationReference { get; set; }

    /// <summary>
    /// Indicates if the historic data of a process resource should be deleted via a
    /// batch operation asynchronously.
    /// 
    /// This flag is only effective for process resources. For other resource types
    /// (decisions, forms, generic resources), this flag is ignored and no history
    /// will be deleted. In those cases, the `batchOperation` field in the response
    /// will not be populated.
    /// 
    /// </summary>
    [JsonPropertyName("deleteHistory")]
    public bool? DeleteHistory { get; set; }

}

/// <summary>
/// DeleteResourceResponse
/// </summary>
public sealed class DeleteResourceResponse
{
    /// <summary>
    /// The system-assigned key for this resource, requested to be deleted.
    /// </summary>
    [JsonPropertyName("resourceKey")]
    public ResourceKey ResourceKey { get; set; }

    /// <summary>
    /// The batch operation created for asynchronously deleting the historic data.
    /// 
    /// This field is only populated when the request `deleteHistory` is set to `true` and the resource
    /// is a process definition. For other resource types (decisions, forms, generic resources),
    /// this field will not be present in the response.
    /// 
    /// </summary>
    [JsonPropertyName("batchOperation")]
    public BatchOperationCreatedResult? BatchOperation { get; set; }

}

/// <summary>
/// Deployed decision requirements.
/// </summary>
public sealed class DeploymentDecisionRequirementsResult
{
    [JsonPropertyName("decisionRequirementsId")]
    public string? DecisionRequirementsId { get; set; }

    [JsonPropertyName("decisionRequirementsName")]
    public string? DecisionRequirementsName { get; set; }

    [JsonPropertyName("version")]
    public int? Version { get; set; }

    [JsonPropertyName("resourceName")]
    public string? ResourceName { get; set; }

    /// <summary>
    /// The tenant ID of the deployed decision requirements.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The assigned decision requirements key, which acts as a unique identifier for this decision requirements.
    /// 
    /// </summary>
    [JsonPropertyName("decisionRequirementsKey")]
    public DecisionRequirementsKey? DecisionRequirementsKey { get; set; }

}

/// <summary>
/// A deployed decision.
/// </summary>
public sealed class DeploymentDecisionResult
{
    /// <summary>
    /// The dmn decision ID, as parsed during deployment, together with the version forms a
    /// unique identifier for a specific decision.
    /// 
    /// </summary>
    [JsonPropertyName("decisionDefinitionId")]
    public DecisionDefinitionId? DecisionDefinitionId { get; set; }

    /// <summary>
    /// The assigned decision version.
    /// </summary>
    [JsonPropertyName("version")]
    public int? Version { get; set; }

    /// <summary>
    /// The DMN name of the decision, as parsed during deployment.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The tenant ID of the deployed decision.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The dmn ID of the decision requirements graph that this decision is part of, as parsed during deployment.
    /// 
    /// </summary>
    [JsonPropertyName("decisionRequirementsId")]
    public string? DecisionRequirementsId { get; set; }

    /// <summary>
    /// The assigned decision key, which acts as a unique identifier for this decision.
    /// 
    /// </summary>
    [JsonPropertyName("decisionDefinitionKey")]
    public DecisionDefinitionKey? DecisionDefinitionKey { get; set; }

    /// <summary>
    /// The assigned key of the decision requirements graph that this decision is part of.
    /// 
    /// </summary>
    [JsonPropertyName("decisionRequirementsKey")]
    public DecisionRequirementsKey? DecisionRequirementsKey { get; set; }

}

/// <summary>
/// A deployed form.
/// </summary>
public sealed class DeploymentFormResult
{
    /// <summary>
    /// The form ID, as parsed during deployment, together with the version forms a
    /// unique identifier for a specific form.
    /// 
    /// </summary>
    [JsonPropertyName("formId")]
    public FormId? FormId { get; set; }

    [JsonPropertyName("version")]
    public int? Version { get; set; }

    [JsonPropertyName("resourceName")]
    public string? ResourceName { get; set; }

    /// <summary>
    /// The unique identifier of the tenant.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The assigned key, which acts as a unique identifier for this form.
    /// </summary>
    [JsonPropertyName("formKey")]
    public FormKey? FormKey { get; set; }

}

/// <summary>
/// Key for a deployment.
/// </summary>
public readonly record struct DeploymentKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private DeploymentKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="DeploymentKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static DeploymentKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "DeploymentKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new DeploymentKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct DeploymentKeyExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private DeploymentKeyExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="DeploymentKeyExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static DeploymentKeyExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "DeploymentKeyExactMatch");
        return new DeploymentKeyExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// DeploymentKey property with full advanced search capabilities.
/// </summary>
public sealed class DeploymentKeyFilterProperty
{
}

/// <summary>
/// DeploymentMetadataResult
/// </summary>
public sealed class DeploymentMetadataResult
{
    /// <summary>
    /// A deployed process.
    /// </summary>
    [JsonPropertyName("processDefinition")]
    public DeploymentProcessResult? ProcessDefinition { get; set; }

    /// <summary>
    /// A deployed decision.
    /// </summary>
    [JsonPropertyName("decisionDefinition")]
    public DeploymentDecisionResult? DecisionDefinition { get; set; }

    /// <summary>
    /// Deployed decision requirements.
    /// </summary>
    [JsonPropertyName("decisionRequirements")]
    public DeploymentDecisionRequirementsResult? DecisionRequirements { get; set; }

    /// <summary>
    /// A deployed form.
    /// </summary>
    [JsonPropertyName("form")]
    public DeploymentFormResult? Form { get; set; }

    /// <summary>
    /// A deployed Resource.
    /// </summary>
    [JsonPropertyName("resource")]
    public DeploymentResourceResult? Resource { get; set; }

}

/// <summary>
/// A deployed process.
/// </summary>
public sealed class DeploymentProcessResult
{
    /// <summary>
    /// The bpmn process ID, as parsed during deployment, together with the version forms a
    /// unique identifier for a specific process definition.
    /// 
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId ProcessDefinitionId { get; set; }

    /// <summary>
    /// The assigned process version.
    /// </summary>
    [JsonPropertyName("processDefinitionVersion")]
    public int ProcessDefinitionVersion { get; set; }

    /// <summary>
    /// The resource name from which this process was parsed.
    /// </summary>
    [JsonPropertyName("resourceName")]
    public string ResourceName { get; set; } = null!;

    /// <summary>
    /// The tenant ID of the deployed process.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId TenantId { get; set; }

    /// <summary>
    /// The assigned key, which acts as a unique identifier for this process.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey ProcessDefinitionKey { get; set; }

}

/// <summary>
/// A deployed Resource.
/// </summary>
public sealed class DeploymentResourceResult
{
    [JsonPropertyName("resourceId")]
    public string? ResourceId { get; set; }

    [JsonPropertyName("resourceName")]
    public string? ResourceName { get; set; }

    [JsonPropertyName("version")]
    public int? Version { get; set; }

    /// <summary>
    /// The unique identifier of the tenant.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The assigned key, which acts as a unique identifier for this Resource.
    /// </summary>
    [JsonPropertyName("resourceKey")]
    public ResourceKey? ResourceKey { get; set; }

}

/// <summary>
/// DeploymentResult
/// </summary>
public sealed class DeploymentResult
{
    /// <summary>
    /// The unique key identifying the deployment.
    /// </summary>
    [JsonPropertyName("deploymentKey")]
    public DeploymentKey DeploymentKey { get; set; }

    /// <summary>
    /// The tenant ID associated with the deployment.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId TenantId { get; set; }

    /// <summary>
    /// Items deployed by the request.
    /// </summary>
    [JsonPropertyName("deployments")]
    public List<DeploymentMetadataResult> Deployments { get; set; } = null!;

}

/// <summary>
/// Provides a concrete key to use as ancestor scope for the created element instance.
/// </summary>
public sealed class DirectAncestorKeyInstruction : AncestorScopeInstruction
{
    /// <summary>
    /// The type of ancestor scope instruction.
    /// </summary>
    [JsonPropertyName("ancestorScopeType")]
    public string AncestorScopeType { get; set; } = null!;

    /// <summary>
    /// The key of the ancestor scope the element instance should be created in.
    /// Set to -1 to create the new element instance within an existing element instance of the
    /// flow scope. If multiple instances of the target element's flow scope exist, choose one
    /// specifically with this property by providing its key.
    /// 
    /// </summary>
    [JsonPropertyName("ancestorElementInstanceKey")]
    public object AncestorElementInstanceKey { get; set; } = null!;

}

/// <summary>
/// DocumentCreationBatchResponse
/// </summary>
public sealed class DocumentCreationBatchResponse
{
    /// <summary>
    /// Documents that were successfully created.
    /// </summary>
    [JsonPropertyName("failedDocuments")]
    public List<DocumentCreationFailureDetail>? FailedDocuments { get; set; }

    /// <summary>
    /// Documents that failed creation.
    /// </summary>
    [JsonPropertyName("createdDocuments")]
    public List<DocumentReference>? CreatedDocuments { get; set; }

}

/// <summary>
/// DocumentCreationFailureDetail
/// </summary>
public sealed class DocumentCreationFailureDetail
{
    /// <summary>
    /// The name of the file that failed to upload.
    /// </summary>
    [JsonPropertyName("fileName")]
    public string? FileName { get; set; }

    /// <summary>
    /// The HTTP status code of the failure.
    /// </summary>
    [JsonPropertyName("status")]
    public int? Status { get; set; }

    /// <summary>
    /// A short, human-readable summary of the problem type.
    /// </summary>
    [JsonPropertyName("title")]
    public string? Title { get; set; }

    /// <summary>
    /// A human-readable explanation specific to this occurrence of the problem.
    /// </summary>
    [JsonPropertyName("detail")]
    public string? Detail { get; set; }

}

/// <summary>
/// Document Id that uniquely identifies a document.
/// </summary>
public readonly record struct DocumentId : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private DocumentId(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="DocumentId"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static DocumentId AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "DocumentId");
        return new DocumentId(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// DocumentLink
/// </summary>
public sealed class DocumentLink
{
    /// <summary>
    /// The link to the document.
    /// </summary>
    [JsonPropertyName("url")]
    public string? Url { get; set; }

    /// <summary>
    /// The date and time when the link expires.
    /// </summary>
    [JsonPropertyName("expiresAt")]
    public DateTimeOffset? ExpiresAt { get; set; }

}

/// <summary>
/// DocumentLinkRequest
/// </summary>
public sealed class DocumentLinkRequest
{
    /// <summary>
    /// The time-to-live of the document link in ms.
    /// </summary>
    [JsonPropertyName("timeToLive")]
    public long? TimeToLive { get; set; }

}

/// <summary>
/// Information about the document.
/// </summary>
public sealed class DocumentMetadata
{
    /// <summary>
    /// The content type of the document.
    /// </summary>
    [JsonPropertyName("contentType")]
    public string? ContentType { get; set; }

    /// <summary>
    /// The name of the file.
    /// </summary>
    [JsonPropertyName("fileName")]
    public string? FileName { get; set; }

    /// <summary>
    /// The date and time when the document expires.
    /// </summary>
    [JsonPropertyName("expiresAt")]
    public DateTimeOffset? ExpiresAt { get; set; }

    /// <summary>
    /// The size of the document in bytes.
    /// </summary>
    [JsonPropertyName("size")]
    public long? Size { get; set; }

    /// <summary>
    /// The ID of the process definition that created the document.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId? ProcessDefinitionId { get; set; }

    /// <summary>
    /// The key of the process instance that created the document.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// Custom properties of the document.
    /// </summary>
    [JsonPropertyName("customProperties")]
    public object? CustomProperties { get; set; }

}

/// <summary>
/// DocumentReference
/// </summary>
public sealed class DocumentReference
{
    /// <summary>
    /// Document discriminator. Always set to "camunda".
    /// </summary>
    [JsonPropertyName("camunda.document.type")]
    public string? CamundaDocumentType { get; set; }

    /// <summary>
    /// The ID of the document store.
    /// </summary>
    [JsonPropertyName("storeId")]
    public string? StoreId { get; set; }

    /// <summary>
    /// The ID of the document.
    /// </summary>
    [JsonPropertyName("documentId")]
    public DocumentId? DocumentId { get; set; }

    /// <summary>
    /// The hash of the document.
    /// </summary>
    [JsonPropertyName("contentHash")]
    public string? ContentHash { get; set; }

    /// <summary>
    /// Information about the document.
    /// </summary>
    [JsonPropertyName("metadata")]
    public DocumentMetadata? Metadata { get; set; }

}

/// <summary>
/// The model-defined id of an element.
/// </summary>
public readonly record struct ElementId : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private ElementId(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="ElementId"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static ElementId AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "ElementId");
        return new ElementId(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Element instance filter.
/// </summary>
public sealed class ElementInstanceFilter
{
    /// <summary>
    /// The process definition ID associated to this element instance.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId? ProcessDefinitionId { get; set; }

    /// <summary>
    /// State of element instance as defined set of values.
    /// </summary>
    [JsonPropertyName("state")]
    public ElementInstanceStateFilterProperty? State { get; set; }

    /// <summary>
    /// Type of element as defined set of values.
    /// </summary>
    [JsonPropertyName("type")]
    public string? Type { get; set; }

    /// <summary>
    /// The element ID for this element instance.
    /// </summary>
    [JsonPropertyName("elementId")]
    public ElementId? ElementId { get; set; }

    /// <summary>
    /// The element name. This only works for data created with 8.8 and onwards. Instances from prior versions don't contain this data and cannot be found.
    /// 
    /// </summary>
    [JsonPropertyName("elementName")]
    public string? ElementName { get; set; }

    /// <summary>
    /// Shows whether this element instance has an incident related to.
    /// </summary>
    [JsonPropertyName("hasIncident")]
    public bool? HasIncident { get; set; }

    /// <summary>
    /// The unique identifier of the tenant.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The assigned key, which acts as a unique identifier for this element instance.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKey? ElementInstanceKey { get; set; }

    /// <summary>
    /// The process instance key associated to this element instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The process definition key associated to this element instance.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The key of incident if field incident is true.
    /// </summary>
    [JsonPropertyName("incidentKey")]
    public IncidentKey? IncidentKey { get; set; }

    /// <summary>
    /// The start date of this element instance.
    /// </summary>
    [JsonPropertyName("startDate")]
    public DateTimeFilterProperty? StartDate { get; set; }

    /// <summary>
    /// The end date of this element instance.
    /// </summary>
    [JsonPropertyName("endDate")]
    public DateTimeFilterProperty? EndDate { get; set; }

    /// <summary>
    /// The scope key of this element instance. If provided with a process instance key it will return element instances that are immediate children of the process instance. If provided with an element instance key it will return element instances that are immediate children of the element instance.
    /// 
    /// </summary>
    [JsonPropertyName("elementInstanceScopeKey")]
    public string? ElementInstanceScopeKey { get; set; }

}

/// <summary>
/// System-generated key for a element instance.
/// </summary>
public readonly record struct ElementInstanceKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private ElementInstanceKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="ElementInstanceKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static ElementInstanceKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "ElementInstanceKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new ElementInstanceKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct ElementInstanceKeyExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private ElementInstanceKeyExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="ElementInstanceKeyExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static ElementInstanceKeyExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "ElementInstanceKeyExactMatch");
        return new ElementInstanceKeyExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// ElementInstanceKey property with full advanced search capabilities.
/// </summary>
public sealed class ElementInstanceKeyFilterProperty
{
}

/// <summary>
/// ElementInstanceResult
/// </summary>
public sealed class ElementInstanceResult
{
    /// <summary>
    /// The process definition ID associated to this element instance.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId ProcessDefinitionId { get; set; }

    /// <summary>
    /// Date when element instance started.
    /// </summary>
    [JsonPropertyName("startDate")]
    public DateTimeOffset StartDate { get; set; }

    /// <summary>
    /// Date when element instance finished.
    /// </summary>
    [JsonPropertyName("endDate")]
    public DateTimeOffset? EndDate { get; set; }

    /// <summary>
    /// The element ID for this element instance.
    /// </summary>
    [JsonPropertyName("elementId")]
    public ElementId ElementId { get; set; }

    /// <summary>
    /// The element name for this element instance.
    /// </summary>
    [JsonPropertyName("elementName")]
    public string ElementName { get; set; } = null!;

    /// <summary>
    /// Type of element as defined set of values.
    /// </summary>
    [JsonPropertyName("type")]
    public string Type { get; set; } = null!;

    /// <summary>
    /// State of element instance as defined set of values.
    /// </summary>
    [JsonPropertyName("state")]
    public ElementInstanceStateEnum State { get; set; }

    /// <summary>
    /// Shows whether this element instance has an incident. If true also an incidentKey is provided.
    /// </summary>
    [JsonPropertyName("hasIncident")]
    public bool HasIncident { get; set; }

    /// <summary>
    /// The tenant ID of the incident.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId TenantId { get; set; }

    /// <summary>
    /// The assigned key, which acts as a unique identifier for this element instance.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKey ElementInstanceKey { get; set; }

    /// <summary>
    /// The process instance key associated to this element instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey ProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the root process instance. The root process instance is the top-level
    /// ancestor in the process instance hierarchy. This field is only present for data
    /// belonging to process instance hierarchies created in version 8.9 or later.
    /// 
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public RootProcessInstanceKey? RootProcessInstanceKey { get; set; }

    /// <summary>
    /// The process definition key associated to this element instance.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey ProcessDefinitionKey { get; set; }

    /// <summary>
    /// Incident key associated with this element instance.
    /// </summary>
    [JsonPropertyName("incidentKey")]
    public IncidentKey? IncidentKey { get; set; }

}

/// <summary>
/// Element instance search request.
/// </summary>
public sealed class ElementInstanceSearchQuery
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<ElementInstanceSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The element instance search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public ElementInstanceFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// ElementInstanceSearchQueryResult
/// </summary>
public sealed class ElementInstanceSearchQueryResult
{
    /// <summary>
    /// The matching element instances.
    /// </summary>
    [JsonPropertyName("items")]
    public List<ElementInstanceResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// ElementInstanceSearchQuerySortRequest
/// </summary>
public sealed class ElementInstanceSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// Element states
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum ElementInstanceStateEnum
{
    [JsonPropertyName("ACTIVE")]
    ACTIVE,
    [JsonPropertyName("COMPLETED")]
    COMPLETED,
    [JsonPropertyName("TERMINATED")]
    TERMINATED,
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct ElementInstanceStateExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private ElementInstanceStateExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="ElementInstanceStateExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static ElementInstanceStateExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "ElementInstanceStateExactMatch");
        return new ElementInstanceStateExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// ElementInstanceStateEnum property with full advanced search capabilities.
/// </summary>
public sealed class ElementInstanceStateFilterProperty
{
}

/// <summary>
/// The end cursor in a search query result set.
/// </summary>
public readonly record struct EndCursor : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private EndCursor(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="EndCursor"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static EndCursor AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "EndCursor", pattern: @"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}=)?$", minLength: 2, maxLength: 300);
        return new EndCursor(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}=)?$", minLength: 2, maxLength: 300);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct EntityTypeExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private EntityTypeExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="EntityTypeExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static EntityTypeExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "EntityTypeExactMatch");
        return new EntityTypeExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// AuditLogEntityTypeEnum property with full advanced search capabilities.
/// </summary>
public sealed class EntityTypeFilterProperty
{
}

/// <summary>
/// EvaluateConditionalResult
/// </summary>
public sealed class EvaluateConditionalResult
{
    /// <summary>
    /// The unique key of the conditional evaluation operation.
    /// </summary>
    [JsonPropertyName("conditionalEvaluationKey")]
    public ConditionalEvaluationKey ConditionalEvaluationKey { get; set; }

    /// <summary>
    /// The tenant ID of the conditional evaluation operation.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId TenantId { get; set; }

    /// <summary>
    /// List of process instances created. If no root-level conditional start events evaluated to true, the list will be empty.
    /// </summary>
    [JsonPropertyName("processInstances")]
    public List<ProcessInstanceReference> ProcessInstances { get; set; } = null!;

}

/// <summary>
/// A decision input that was evaluated within this decision evaluation.
/// </summary>
public sealed class EvaluatedDecisionInputItem
{
    [JsonPropertyName("inputId")]
    public string? InputId { get; set; }

    [JsonPropertyName("inputName")]
    public string? InputName { get; set; }

    [JsonPropertyName("inputValue")]
    public string? InputValue { get; set; }

}

/// <summary>
/// The evaluated decision outputs.
/// </summary>
public sealed class EvaluatedDecisionOutputItem
{
    [JsonPropertyName("outputId")]
    public string? OutputId { get; set; }

    [JsonPropertyName("outputName")]
    public string? OutputName { get; set; }

    [JsonPropertyName("outputValue")]
    public string? OutputValue { get; set; }

    [JsonPropertyName("ruleId")]
    public string? RuleId { get; set; }

    [JsonPropertyName("ruleIndex")]
    public int? RuleIndex { get; set; }

}

/// <summary>
/// A decision that was evaluated.
/// </summary>
public sealed class EvaluatedDecisionResult
{
    /// <summary>
    /// The ID of the decision which was evaluated.
    /// </summary>
    [JsonPropertyName("decisionDefinitionId")]
    public DecisionDefinitionId? DecisionDefinitionId { get; set; }

    /// <summary>
    /// The name of the decision which was evaluated.
    /// </summary>
    [JsonPropertyName("decisionDefinitionName")]
    public string? DecisionDefinitionName { get; set; }

    /// <summary>
    /// The version of the decision which was evaluated.
    /// </summary>
    [JsonPropertyName("decisionDefinitionVersion")]
    public int? DecisionDefinitionVersion { get; set; }

    /// <summary>
    /// The type of the decision which was evaluated.
    /// </summary>
    [JsonPropertyName("decisionDefinitionType")]
    public string? DecisionDefinitionType { get; set; }

    /// <summary>
    /// JSON document that will instantiate the result of the decision which was evaluated.
    /// 
    /// </summary>
    [JsonPropertyName("output")]
    public string? Output { get; set; }

    /// <summary>
    /// The tenant ID of the evaluated decision.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The decision rules that matched within this decision evaluation.
    /// </summary>
    [JsonPropertyName("matchedRules")]
    public List<MatchedDecisionRuleItem>? MatchedRules { get; set; }

    /// <summary>
    /// The decision inputs that were evaluated within this decision evaluation.
    /// </summary>
    [JsonPropertyName("evaluatedInputs")]
    public List<EvaluatedDecisionInputItem>? EvaluatedInputs { get; set; }

    /// <summary>
    /// The unique key identifying the decision which was evaluate.
    /// </summary>
    [JsonPropertyName("decisionDefinitionKey")]
    public DecisionDefinitionKey? DecisionDefinitionKey { get; set; }

    /// <summary>
    /// The unique key identifying this decision evaluation instance.
    /// </summary>
    [JsonPropertyName("decisionEvaluationInstanceKey")]
    public DecisionEvaluationInstanceKey? DecisionEvaluationInstanceKey { get; set; }

}

/// <summary>
/// EvaluateDecisionResult
/// </summary>
public sealed class EvaluateDecisionResult
{
    /// <summary>
    /// The ID of the decision which was evaluated.
    /// </summary>
    [JsonPropertyName("decisionDefinitionId")]
    public DecisionDefinitionId DecisionDefinitionId { get; set; }

    /// <summary>
    /// The name of the decision which was evaluated.
    /// </summary>
    [JsonPropertyName("decisionDefinitionName")]
    public string DecisionDefinitionName { get; set; } = null!;

    /// <summary>
    /// The version of the decision which was evaluated.
    /// </summary>
    [JsonPropertyName("decisionDefinitionVersion")]
    public int DecisionDefinitionVersion { get; set; }

    /// <summary>
    /// The ID of the decision requirements graph that the decision which was evaluated is part of.
    /// </summary>
    [JsonPropertyName("decisionRequirementsId")]
    public string DecisionRequirementsId { get; set; } = null!;

    /// <summary>
    /// JSON document that will instantiate the result of the decision which was evaluated.
    /// 
    /// </summary>
    [JsonPropertyName("output")]
    public string Output { get; set; } = null!;

    /// <summary>
    /// The ID of the decision which failed during evaluation.
    /// </summary>
    [JsonPropertyName("failedDecisionDefinitionId")]
    public DecisionDefinitionId FailedDecisionDefinitionId { get; set; }

    /// <summary>
    /// Message describing why the decision which was evaluated failed.
    /// </summary>
    [JsonPropertyName("failureMessage")]
    public string FailureMessage { get; set; } = null!;

    /// <summary>
    /// The tenant ID of the evaluated decision.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId TenantId { get; set; }

    /// <summary>
    /// The unique key identifying the decision which was evaluated.
    /// </summary>
    [JsonPropertyName("decisionDefinitionKey")]
    public DecisionDefinitionKey DecisionDefinitionKey { get; set; }

    /// <summary>
    /// The unique key identifying the decision requirements graph that the decision which was evaluated is part of.
    /// </summary>
    [JsonPropertyName("decisionRequirementsKey")]
    public DecisionRequirementsKey DecisionRequirementsKey { get; set; }

    /// <summary>
    /// Deprecated, please refer to `decisionEvaluationKey`.
    /// </summary>
    [JsonPropertyName("decisionInstanceKey")]
    public DecisionInstanceKey? DecisionInstanceKey { get; set; }

    /// <summary>
    /// The unique key identifying this decision evaluation.
    /// </summary>
    [JsonPropertyName("decisionEvaluationKey")]
    public DecisionEvaluationKey DecisionEvaluationKey { get; set; }

    /// <summary>
    /// Decisions that were evaluated within the requested decision evaluation.
    /// </summary>
    [JsonPropertyName("evaluatedDecisions")]
    public List<EvaluatedDecisionResult> EvaluatedDecisions { get; set; } = null!;

}

/// <summary>
/// ExpressionEvaluationRequest
/// </summary>
public sealed class ExpressionEvaluationRequest : global::Camunda.Orchestration.Sdk.Runtime.ITenantIdSettable
{
    /// <summary>
    /// The expression to evaluate (e.g., "=x + y")
    /// </summary>
    [JsonPropertyName("expression")]
    public string Expression { get; set; } = null!;

    /// <summary>
    /// Required when the expression references tenant-scoped cluster variables
    /// </summary>
    [JsonPropertyName("tenantId")]
    public string? TenantId { get; set; }

    /// <inheritdoc />
    public void SetDefaultTenantId(string tenantId) { TenantId ??= tenantId; }

}

/// <summary>
/// ExpressionEvaluationResult
/// </summary>
public sealed class ExpressionEvaluationResult
{
    /// <summary>
    /// The evaluated expression
    /// </summary>
    [JsonPropertyName("expression")]
    public string Expression { get; set; } = null!;

    /// <summary>
    /// The result value. Its type can vary.
    /// </summary>
    [JsonPropertyName("result")]
    public object Result { get; set; } = null!;

    /// <summary>
    /// List of warnings generated during expression evaluation
    /// </summary>
    [JsonPropertyName("warnings")]
    public List<string> Warnings { get; set; } = null!;

}

/// <summary>
/// The user-defined id for the form
/// </summary>
public readonly record struct FormId : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private FormId(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="FormId"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static FormId AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "FormId");
        return new FormId(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// System-generated key for a deployed form.
/// </summary>
public readonly record struct FormKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private FormKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="FormKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static FormKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "FormKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new FormKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct FormKeyExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private FormKeyExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="FormKeyExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static FormKeyExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "FormKeyExactMatch");
        return new FormKeyExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// FormKey property with full advanced search capabilities.
/// </summary>
public sealed class FormKeyFilterProperty
{
}

/// <summary>
/// FormResult
/// </summary>
public sealed class FormResult
{
    /// <summary>
    /// The tenant ID of the form.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The user-provided identifier of the form.
    /// </summary>
    [JsonPropertyName("formId")]
    public FormId? FormId { get; set; }

    /// <summary>
    /// The form content.
    /// </summary>
    [JsonPropertyName("schema")]
    public object? Schema { get; set; }

    /// <summary>
    /// The version of the the deployed form.
    /// </summary>
    [JsonPropertyName("version")]
    public long? Version { get; set; }

    /// <summary>
    /// The assigned key, which acts as a unique identifier for this form.
    /// </summary>
    [JsonPropertyName("formKey")]
    public FormKey? FormKey { get; set; }

}

/// <summary>
/// Global job statistics query result.
/// </summary>
public sealed class GlobalJobStatisticsQueryResult
{
    /// <summary>
    /// Metric for a single job status.
    /// </summary>
    [JsonPropertyName("created")]
    public StatusMetric Created { get; set; } = null!;

    /// <summary>
    /// Metric for a single job status.
    /// </summary>
    [JsonPropertyName("completed")]
    public StatusMetric Completed { get; set; } = null!;

    /// <summary>
    /// Metric for a single job status.
    /// </summary>
    [JsonPropertyName("failed")]
    public StatusMetric Failed { get; set; } = null!;

    /// <summary>
    /// True if some data is missing because internal limits were reached and some metrics were not recorded.
    /// </summary>
    [JsonPropertyName("isIncomplete")]
    public bool IsIncomplete { get; set; }

}

/// <summary>
/// GroupClientResult
/// </summary>
public sealed class GroupClientResult
{
    /// <summary>
    /// The ID of the client.
    /// </summary>
    [JsonPropertyName("clientId")]
    public string? ClientId { get; set; }

}

/// <summary>
/// GroupClientSearchQueryRequest
/// </summary>
public sealed class GroupClientSearchQueryRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<GroupClientSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// GroupClientSearchQuerySortRequest
/// </summary>
public sealed class GroupClientSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// GroupClientSearchResult
/// </summary>
public sealed class GroupClientSearchResult
{
    /// <summary>
    /// The matching client IDs.
    /// </summary>
    [JsonPropertyName("items")]
    public List<GroupClientResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// GroupCreateRequest
/// </summary>
public sealed class GroupCreateRequest
{
    /// <summary>
    /// The ID of the new group.
    /// </summary>
    [JsonPropertyName("groupId")]
    public string GroupId { get; set; } = null!;

    /// <summary>
    /// The display name of the new group.
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; } = null!;

    /// <summary>
    /// The description of the new group.
    /// </summary>
    [JsonPropertyName("description")]
    public string? Description { get; set; }

}

/// <summary>
/// GroupCreateResult
/// </summary>
public sealed class GroupCreateResult
{
    /// <summary>
    /// The ID of the created group.
    /// </summary>
    [JsonPropertyName("groupId")]
    public string? GroupId { get; set; }

    /// <summary>
    /// The display name of the created group.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The description of the created group.
    /// </summary>
    [JsonPropertyName("description")]
    public string? Description { get; set; }

}

/// <summary>
/// Group filter request
/// </summary>
public sealed class GroupFilter
{
    /// <summary>
    /// The group ID search filters.
    /// </summary>
    [JsonPropertyName("groupId")]
    public StringFilterProperty? GroupId { get; set; }

    /// <summary>
    /// The group name search filters.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

}

/// <summary>
/// Group search response item.
/// </summary>
public sealed class GroupResult
{
    /// <summary>
    /// The group name.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The group ID.
    /// </summary>
    [JsonPropertyName("groupId")]
    public string? GroupId { get; set; }

    /// <summary>
    /// The group description.
    /// </summary>
    [JsonPropertyName("description")]
    public string? Description { get; set; }

}

/// <summary>
/// Group search request.
/// </summary>
public sealed class GroupSearchQueryRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<GroupSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The group search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public GroupFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// Group search response.
/// </summary>
public sealed class GroupSearchQueryResult
{
    /// <summary>
    /// The matching groups.
    /// </summary>
    [JsonPropertyName("items")]
    public List<GroupResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// GroupSearchQuerySortRequest
/// </summary>
public sealed class GroupSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// GroupUpdateRequest
/// </summary>
public sealed class GroupUpdateRequest
{
    /// <summary>
    /// The new name of the group.
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; } = null!;

    /// <summary>
    /// The new description of the group.
    /// </summary>
    [JsonPropertyName("description")]
    public string? Description { get; set; }

}

/// <summary>
/// GroupUpdateResult
/// </summary>
public sealed class GroupUpdateResult
{
    /// <summary>
    /// The unique external group ID.
    /// </summary>
    [JsonPropertyName("groupId")]
    public string? GroupId { get; set; }

    /// <summary>
    /// The name of the group.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The description of the group.
    /// </summary>
    [JsonPropertyName("description")]
    public string? Description { get; set; }

}

/// <summary>
/// GroupUserResult
/// </summary>
public sealed class GroupUserResult
{
    /// <summary>
    /// The unique name of a user.
    /// </summary>
    [JsonPropertyName("username")]
    public Username? Username { get; set; }

}

/// <summary>
/// GroupUserSearchQueryRequest
/// </summary>
public sealed class GroupUserSearchQueryRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<GroupUserSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// GroupUserSearchQuerySortRequest
/// </summary>
public sealed class GroupUserSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// GroupUserSearchResult
/// </summary>
public sealed class GroupUserSearchResult
{
    /// <summary>
    /// The matching members.
    /// </summary>
    [JsonPropertyName("items")]
    public List<GroupUserResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// Incident error type with a defined set of values.
/// </summary>
public sealed class IncidentErrorTypeEnum
{
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct IncidentErrorTypeExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private IncidentErrorTypeExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="IncidentErrorTypeExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static IncidentErrorTypeExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "IncidentErrorTypeExactMatch");
        return new IncidentErrorTypeExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// IncidentErrorTypeEnum with full advanced search capabilities.
/// </summary>
public sealed class IncidentErrorTypeFilterProperty
{
}

/// <summary>
/// Incident search filter.
/// </summary>
public sealed class IncidentFilter
{
    /// <summary>
    /// The process definition ID associated to this incident.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public StringFilterProperty? ProcessDefinitionId { get; set; }

    /// <summary>
    /// Incident error type with a defined set of values.
    /// </summary>
    [JsonPropertyName("errorType")]
    public IncidentErrorTypeFilterProperty? ErrorType { get; set; }

    /// <summary>
    /// The error message of this incident.
    /// </summary>
    [JsonPropertyName("errorMessage")]
    public StringFilterProperty? ErrorMessage { get; set; }

    /// <summary>
    /// The element ID associated to this incident.
    /// </summary>
    [JsonPropertyName("elementId")]
    public StringFilterProperty? ElementId { get; set; }

    /// <summary>
    /// Date of incident creation.
    /// </summary>
    [JsonPropertyName("creationTime")]
    public DateTimeFilterProperty? CreationTime { get; set; }

    /// <summary>
    /// State of this incident with a defined set of values.
    /// </summary>
    [JsonPropertyName("state")]
    public IncidentStateFilterProperty? State { get; set; }

    /// <summary>
    /// The tenant ID of the incident.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public StringFilterProperty? TenantId { get; set; }

    /// <summary>
    /// The assigned key, which acts as a unique identifier for this incident.
    /// </summary>
    [JsonPropertyName("incidentKey")]
    public BasicStringFilterProperty? IncidentKey { get; set; }

    /// <summary>
    /// The process definition key associated to this incident.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKeyFilterProperty? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The process instance key associated to this incident.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKeyFilterProperty? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The element instance key associated to this incident.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKeyFilterProperty? ElementInstanceKey { get; set; }

    /// <summary>
    /// The job key, if exists, associated with this incident.
    /// </summary>
    [JsonPropertyName("jobKey")]
    public JobKeyFilterProperty? JobKey { get; set; }

}

/// <summary>
/// System-generated key for a incident.
/// </summary>
public readonly record struct IncidentKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private IncidentKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="IncidentKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static IncidentKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "IncidentKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new IncidentKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Filter for the incident process instance statistics by definition query.
/// </summary>
public sealed class IncidentProcessInstanceStatisticsByDefinitionFilter
{
    /// <summary>
    /// The error hash code of the incidents to filter the process instance statistics by.
    /// 
    /// </summary>
    [JsonPropertyName("errorHashCode")]
    public int ErrorHashCode { get; set; }

}

/// <summary>
/// IncidentProcessInstanceStatisticsByDefinitionQuery
/// </summary>
public sealed class IncidentProcessInstanceStatisticsByDefinitionQuery
{
    /// <summary>
    /// Filter criteria for the aggregated process instance statistics.
    /// </summary>
    [JsonPropertyName("filter")]
    public IncidentProcessInstanceStatisticsByDefinitionFilter Filter { get; set; } = null!;

    /// <summary>
    /// Pagination parameters for the aggregated process instance statistics.
    /// </summary>
    [JsonPropertyName("page")]
    public OffsetPagination? Page { get; set; }

    /// <summary>
    /// Sorting criteria for process instance statistics grouped by process definition.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<IncidentProcessInstanceStatisticsByDefinitionQuerySortRequest>? Sort { get; set; }

}

/// <summary>
/// IncidentProcessInstanceStatisticsByDefinitionQueryResult
/// </summary>
public sealed class IncidentProcessInstanceStatisticsByDefinitionQueryResult
{
    /// <summary>
    /// Statistics of active process instances with incidents, grouped by process
    /// definition for the specified error hash code.
    /// 
    /// </summary>
    [JsonPropertyName("items")]
    public List<IncidentProcessInstanceStatisticsByDefinitionResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// IncidentProcessInstanceStatisticsByDefinitionQuerySortRequest
/// </summary>
public sealed class IncidentProcessInstanceStatisticsByDefinitionQuerySortRequest
{
    /// <summary>
    /// The aggregated field by which the process instance statistics are sorted.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// IncidentProcessInstanceStatisticsByDefinitionResult
/// </summary>
public sealed class IncidentProcessInstanceStatisticsByDefinitionResult
{
    /// <summary>
    /// Id of a process definition, from the model. Only ids of process definitions that are deployed are useful.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId? ProcessDefinitionId { get; set; }

    /// <summary>
    /// System-generated key for a deployed process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The name of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionName")]
    public string? ProcessDefinitionName { get; set; }

    /// <summary>
    /// The version of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionVersion")]
    public int? ProcessDefinitionVersion { get; set; }

    /// <summary>
    /// The unique identifier of the tenant.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The number of active process instances that currently have an incident
    /// with the specified error hash code.
    /// 
    /// </summary>
    [JsonPropertyName("activeInstancesWithErrorCount")]
    public long? ActiveInstancesWithErrorCount { get; set; }

}

/// <summary>
/// IncidentProcessInstanceStatisticsByErrorQuery
/// </summary>
public sealed class IncidentProcessInstanceStatisticsByErrorQuery
{
    /// <summary>
    /// Pagination parameters for process instance statistics grouped by incident error.
    /// 
    /// </summary>
    [JsonPropertyName("page")]
    public OffsetPagination? Page { get; set; }

    /// <summary>
    /// Sorting criteria for process instance statistics grouped by incident error.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<IncidentProcessInstanceStatisticsByErrorQuerySortRequest>? Sort { get; set; }

}

/// <summary>
/// IncidentProcessInstanceStatisticsByErrorQueryResult
/// </summary>
public sealed class IncidentProcessInstanceStatisticsByErrorQueryResult
{
    /// <summary>
    /// Statistics of active process instances grouped by incident error.
    /// 
    /// </summary>
    [JsonPropertyName("items")]
    public List<IncidentProcessInstanceStatisticsByErrorResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// IncidentProcessInstanceStatisticsByErrorQuerySortRequest
/// </summary>
public sealed class IncidentProcessInstanceStatisticsByErrorQuerySortRequest
{
    /// <summary>
    /// The field to sort the incident error statistics by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// IncidentProcessInstanceStatisticsByErrorResult
/// </summary>
public sealed class IncidentProcessInstanceStatisticsByErrorResult
{
    /// <summary>
    /// The hash code identifying a specific incident error..
    /// </summary>
    [JsonPropertyName("errorHashCode")]
    public int? ErrorHashCode { get; set; }

    /// <summary>
    /// The error message associated with the incident error hash code.
    /// </summary>
    [JsonPropertyName("errorMessage")]
    public string? ErrorMessage { get; set; }

    /// <summary>
    /// The number of active process instances that currently have an active incident with this error.
    /// 
    /// </summary>
    [JsonPropertyName("activeInstancesWithErrorCount")]
    public long? ActiveInstancesWithErrorCount { get; set; }

}

/// <summary>
/// IncidentResolutionRequest
/// </summary>
public sealed class IncidentResolutionRequest
{
    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public OperationReference? OperationReference { get; set; }

}

/// <summary>
/// IncidentResult
/// </summary>
public sealed class IncidentResult
{
    /// <summary>
    /// The process definition ID associated to this incident.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId? ProcessDefinitionId { get; set; }

    [JsonPropertyName("errorType")]
    public IncidentErrorTypeEnum? ErrorType { get; set; }

    /// <summary>
    /// Error message which describes the error in more detail.
    /// </summary>
    [JsonPropertyName("errorMessage")]
    public string? ErrorMessage { get; set; }

    /// <summary>
    /// The element ID associated to this incident.
    /// </summary>
    [JsonPropertyName("elementId")]
    public ElementId? ElementId { get; set; }

    [JsonPropertyName("creationTime")]
    public DateTimeOffset? CreationTime { get; set; }

    [JsonPropertyName("state")]
    public IncidentStateEnum? State { get; set; }

    /// <summary>
    /// The tenant ID of the incident.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The assigned key, which acts as a unique identifier for this incident.
    /// </summary>
    [JsonPropertyName("incidentKey")]
    public IncidentKey? IncidentKey { get; set; }

    /// <summary>
    /// The process definition key associated to this incident.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The process instance key associated to this incident.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the root process instance. The root process instance is the top-level
    /// ancestor in the process instance hierarchy. This field is only present for data
    /// belonging to process instance hierarchies created in version 8.9 or later.
    /// 
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public RootProcessInstanceKey? RootProcessInstanceKey { get; set; }

    /// <summary>
    /// The element instance key associated to this incident.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKey? ElementInstanceKey { get; set; }

    /// <summary>
    /// The job key, if exists, associated with this incident.
    /// </summary>
    [JsonPropertyName("jobKey")]
    public JobKey? JobKey { get; set; }

}

/// <summary>
/// IncidentSearchQuery
/// </summary>
public sealed class IncidentSearchQuery
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<IncidentSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The incident search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public IncidentFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// IncidentSearchQueryResult
/// </summary>
public sealed class IncidentSearchQueryResult
{
    /// <summary>
    /// The matching incidents.
    /// </summary>
    [JsonPropertyName("items")]
    public List<IncidentResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// IncidentSearchQuerySortRequest
/// </summary>
public sealed class IncidentSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// Incident states with a defined set of values.
/// </summary>
public sealed class IncidentStateEnum
{
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct IncidentStateExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private IncidentStateExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="IncidentStateExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static IncidentStateExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "IncidentStateExactMatch");
        return new IncidentStateExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// IncidentStateEnum with full advanced search capabilities.
/// </summary>
public sealed class IncidentStateFilterProperty
{
}

/// <summary>
/// Instructs the engine to derive the ancestor scope key from the source element's hierarchy. The engine traverses the source element's ancestry to find an instance that matches one of the target element's flow scopes, ensuring the target is activated in the correct scope.
/// 
/// </summary>
public sealed class InferredAncestorKeyInstruction : AncestorScopeInstruction
{
    /// <summary>
    /// The type of ancestor scope instruction.
    /// </summary>
    [JsonPropertyName("ancestorScopeType")]
    public string AncestorScopeType { get; set; } = null!;

}

/// <summary>
/// Integer property with advanced search capabilities.
/// </summary>
public sealed class IntegerFilterProperty
{
}

/// <summary>
/// JobActivationRequest
/// </summary>
public sealed class JobActivationRequest
{
    /// <summary>
    /// The job type, as defined in the BPMN process (e.g. &lt;zeebe:taskDefinition type="payment-service" /&gt;)
    /// </summary>
    [JsonPropertyName("type")]
    public string Type { get; set; } = null!;

    /// <summary>
    /// The name of the worker activating the jobs, mostly used for logging purposes.
    /// </summary>
    [JsonPropertyName("worker")]
    public string? Worker { get; set; }

    /// <summary>
    /// A job returned after this call will not be activated by another call until the timeout (in ms) has been reached.
    /// 
    /// </summary>
    [JsonPropertyName("timeout")]
    public long Timeout { get; set; }

    /// <summary>
    /// The maximum jobs to activate by this request.
    /// </summary>
    [JsonPropertyName("maxJobsToActivate")]
    public int MaxJobsToActivate { get; set; }

    /// <summary>
    /// A list of variables to fetch as the job variables; if empty, all visible variables at the time of activation for the scope of the job will be returned.
    /// </summary>
    [JsonPropertyName("fetchVariable")]
    public List<string>? FetchVariable { get; set; }

    /// <summary>
    /// The request will be completed when at least one job is activated or after the requestTimeout (in ms). If the requestTimeout = 0, a default timeout is used. If the requestTimeout &lt; 0, long polling is disabled and the request is completed immediately, even when no job is activated.
    /// 
    /// </summary>
    [JsonPropertyName("requestTimeout")]
    public long? RequestTimeout { get; set; }

    /// <summary>
    /// A list of IDs of tenants for which to activate jobs.
    /// </summary>
    [JsonPropertyName("tenantIds")]
    public List<TenantId>? TenantIds { get; set; }

    /// <summary>
    /// The tenant filtering strategy - determines whether to use provided tenant IDs or assigned tenant IDs from the authenticated principal's authorized tenants.
    /// 
    /// </summary>
    [JsonPropertyName("tenantFilter")]
    public TenantFilterEnum? TenantFilter { get; set; }

}

/// <summary>
/// The list of activated jobs
/// </summary>
public sealed class JobActivationResult
{
    /// <summary>
    /// The activated jobs.
    /// </summary>
    [JsonPropertyName("jobs")]
    public List<ActivatedJobResult> Jobs { get; set; } = null!;

}

/// <summary>
/// JSON object with changed job attribute values. The job cannot be completed or failed with this endpoint, use the complete job or fail job endpoints instead.
/// </summary>
public sealed class JobChangeset
{
    /// <summary>
    /// The new number of retries for the job.
    /// </summary>
    [JsonPropertyName("retries")]
    public int? Retries { get; set; }

    /// <summary>
    /// The new timeout for the job in milliseconds.
    /// </summary>
    [JsonPropertyName("timeout")]
    public long? Timeout { get; set; }

}

/// <summary>
/// JobCompletionRequest
/// </summary>
public sealed class JobCompletionRequest
{
    /// <summary>
    /// The variables to complete the job with.
    /// </summary>
    [JsonPropertyName("variables")]
    public object? Variables { get; set; }

    /// <summary>
    /// The result of the completed job as determined by the worker.
    /// 
    /// </summary>
    [JsonPropertyName("result")]
    public JobResult? Result { get; set; }

}

/// <summary>
/// JobErrorRequest
/// </summary>
public sealed class JobErrorRequest
{
    /// <summary>
    /// The error code that will be matched with an error catch event.
    /// 
    /// </summary>
    [JsonPropertyName("errorCode")]
    public string ErrorCode { get; set; } = null!;

    /// <summary>
    /// An error message that provides additional context.
    /// 
    /// </summary>
    [JsonPropertyName("errorMessage")]
    public string? ErrorMessage { get; set; }

    /// <summary>
    /// JSON object that will instantiate the variables at the local scope of the error catch event that catches the thrown error.
    /// 
    /// </summary>
    [JsonPropertyName("variables")]
    public object? Variables { get; set; }

}

/// <summary>
/// JobFailRequest
/// </summary>
public sealed class JobFailRequest
{
    /// <summary>
    /// The amount of retries the job should have left
    /// </summary>
    [JsonPropertyName("retries")]
    public int? Retries { get; set; }

    /// <summary>
    /// An optional error message describing why the job failed; if not provided, an empty string is used.
    /// </summary>
    [JsonPropertyName("errorMessage")]
    public string? ErrorMessage { get; set; }

    /// <summary>
    /// An optional retry back off for the failed job. The job will not be retryable before the current time plus the back off time. The default is 0 which means the job is retryable immediately.
    /// </summary>
    [JsonPropertyName("retryBackOff")]
    public long? RetryBackOff { get; set; }

    /// <summary>
    /// JSON object that will instantiate the variables at the local scope of the job's associated task.
    /// 
    /// </summary>
    [JsonPropertyName("variables")]
    public object? Variables { get; set; }

}

/// <summary>
/// Job search filter.
/// </summary>
public sealed class JobFilter
{
    /// <summary>
    /// When the job can next be activated.
    /// </summary>
    [JsonPropertyName("deadline")]
    public DateTimeFilterProperty? Deadline { get; set; }

    /// <summary>
    /// The reason provided by the user task listener for denying the work.
    /// </summary>
    [JsonPropertyName("deniedReason")]
    public StringFilterProperty? DeniedReason { get; set; }

    /// <summary>
    /// The element ID associated with the job.
    /// </summary>
    [JsonPropertyName("elementId")]
    public StringFilterProperty? ElementId { get; set; }

    /// <summary>
    /// The element instance key associated with the job.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKeyFilterProperty? ElementInstanceKey { get; set; }

    /// <summary>
    /// When the job ended.
    /// </summary>
    [JsonPropertyName("endTime")]
    public DateTimeFilterProperty? EndTime { get; set; }

    /// <summary>
    /// The error code provided for the failed job.
    /// </summary>
    [JsonPropertyName("errorCode")]
    public StringFilterProperty? ErrorCode { get; set; }

    /// <summary>
    /// The error message that provides additional context for a failed job.
    /// </summary>
    [JsonPropertyName("errorMessage")]
    public StringFilterProperty? ErrorMessage { get; set; }

    /// <summary>
    /// Indicates whether the job has failed with retries left.
    /// </summary>
    [JsonPropertyName("hasFailedWithRetriesLeft")]
    public bool? HasFailedWithRetriesLeft { get; set; }

    /// <summary>
    /// Indicates whether the user task listener denies the work.
    /// </summary>
    [JsonPropertyName("isDenied")]
    public bool? IsDenied { get; set; }

    /// <summary>
    /// The key, a unique identifier for the job.
    /// </summary>
    [JsonPropertyName("jobKey")]
    public JobKeyFilterProperty? JobKey { get; set; }

    /// <summary>
    /// The kind of the job.
    /// </summary>
    [JsonPropertyName("kind")]
    public JobKindFilterProperty? Kind { get; set; }

    /// <summary>
    /// The listener event type of the job.
    /// </summary>
    [JsonPropertyName("listenerEventType")]
    public JobListenerEventTypeFilterProperty? ListenerEventType { get; set; }

    /// <summary>
    /// The process definition ID associated with the job.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public StringFilterProperty? ProcessDefinitionId { get; set; }

    /// <summary>
    /// The process definition key associated with the job.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKeyFilterProperty? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The process instance key associated with the job.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKeyFilterProperty? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The number of retries left.
    /// </summary>
    [JsonPropertyName("retries")]
    public IntegerFilterProperty? Retries { get; set; }

    /// <summary>
    /// The state of the job.
    /// </summary>
    [JsonPropertyName("state")]
    public JobStateFilterProperty? State { get; set; }

    /// <summary>
    /// The tenant ID.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public StringFilterProperty? TenantId { get; set; }

    /// <summary>
    /// The type of the job.
    /// </summary>
    [JsonPropertyName("type")]
    public StringFilterProperty? Type { get; set; }

    /// <summary>
    /// The name of the worker for this job.
    /// </summary>
    [JsonPropertyName("worker")]
    public StringFilterProperty? Worker { get; set; }

    /// <summary>
    /// When the job was created. Field is present for jobs created after 8.9.
    /// </summary>
    [JsonPropertyName("creationTime")]
    public DateTimeFilterProperty? CreationTime { get; set; }

    /// <summary>
    /// When the job was last updated. Field is present for jobs created after 8.9.
    /// </summary>
    [JsonPropertyName("lastUpdateTime")]
    public DateTimeFilterProperty? LastUpdateTime { get; set; }

}

/// <summary>
/// System-generated key for a job.
/// </summary>
public readonly record struct JobKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private JobKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="JobKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static JobKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "JobKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new JobKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct JobKeyExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private JobKeyExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="JobKeyExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static JobKeyExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "JobKeyExactMatch");
        return new JobKeyExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// JobKey property with full advanced search capabilities.
/// </summary>
public sealed class JobKeyFilterProperty
{
}

/// <summary>
/// The job kind.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum JobKindEnum
{
    [JsonPropertyName("BPMN_ELEMENT")]
    BPMNELEMENT,
    [JsonPropertyName("EXECUTION_LISTENER")]
    EXECUTIONLISTENER,
    [JsonPropertyName("TASK_LISTENER")]
    TASKLISTENER,
    [JsonPropertyName("AD_HOC_SUB_PROCESS")]
    ADHOCSUBPROCESS,
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct JobKindExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private JobKindExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="JobKindExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static JobKindExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "JobKindExactMatch");
        return new JobKindExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// JobKindEnum property with full advanced search capabilities.
/// </summary>
public sealed class JobKindFilterProperty
{
}

/// <summary>
/// The listener event type of the job.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum JobListenerEventTypeEnum
{
    [JsonPropertyName("ASSIGNING")]
    ASSIGNING,
    [JsonPropertyName("CANCELING")]
    CANCELING,
    [JsonPropertyName("COMPLETING")]
    COMPLETING,
    [JsonPropertyName("CREATING")]
    CREATING,
    [JsonPropertyName("END")]
    END,
    [JsonPropertyName("START")]
    START,
    [JsonPropertyName("UNSPECIFIED")]
    UNSPECIFIED,
    [JsonPropertyName("UPDATING")]
    UPDATING,
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct JobListenerEventTypeExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private JobListenerEventTypeExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="JobListenerEventTypeExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static JobListenerEventTypeExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "JobListenerEventTypeExactMatch");
        return new JobListenerEventTypeExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// JobListenerEventTypeEnum property with full advanced search capabilities.
/// </summary>
public sealed class JobListenerEventTypeFilterProperty
{
}

/// <summary>
/// The result of the completed job as determined by the worker.
/// 
/// </summary>
/// <remarks>
/// Use one of the following concrete types:
/// <list type="bullet">
/// <item><description><see cref="JobResultUserTask"/></description></item>
/// <item><description><see cref="JobResultAdHocSubProcess"/></description></item>
/// </list>
/// </remarks>
/// <seealso cref="JobResultUserTask"/>
/// <seealso cref="JobResultAdHocSubProcess"/>
[JsonDerivedType(typeof(JobResultUserTask))]
[JsonDerivedType(typeof(JobResultAdHocSubProcess))]
public abstract class JobResult { }

/// <summary>
/// Instruction to activate a single BPMN element within an adâ€‘hoc subâ€‘process, optionally providing variables scoped to that element.
/// </summary>
public sealed class JobResultActivateElement
{
    /// <summary>
    /// The element ID to activate.
    /// </summary>
    [JsonPropertyName("elementId")]
    public ElementId? ElementId { get; set; }

    /// <summary>
    /// Variables for the element.
    /// </summary>
    [JsonPropertyName("variables")]
    public object? Variables { get; set; }

}

/// <summary>
/// Job result details for an adâ€‘hoc subâ€‘process, including elements to activate and flags indicating completion or cancellation behavior.
/// 
/// </summary>
public sealed class JobResultAdHocSubProcess : JobResult
{
    /// <summary>
    /// Indicates which elements need to be activated in the ad-hoc subprocess.
    /// </summary>
    [JsonPropertyName("activateElements")]
    public List<JobResultActivateElement>? ActivateElements { get; set; }

    /// <summary>
    /// Indicates whether the completion condition of the ad-hoc subprocess is fulfilled.
    /// </summary>
    [JsonPropertyName("isCompletionConditionFulfilled")]
    public bool? IsCompletionConditionFulfilled { get; set; }

    /// <summary>
    /// Indicates whether the remaining instances of the ad-hoc subprocess should be canceled.
    /// </summary>
    [JsonPropertyName("isCancelRemainingInstances")]
    public bool? IsCancelRemainingInstances { get; set; }

    /// <summary>
    /// Used to distinguish between different types of job results.
    /// </summary>
    [JsonPropertyName("type")]
    public string? Type { get; set; }

}

/// <summary>
/// JSON object with attributes that were corrected by the worker.
/// 
/// The following attributes can be corrected, additional attributes will be ignored:
/// 
/// * `assignee` - clear by providing an empty String
/// * `dueDate` - clear by providing an empty String
/// * `followUpDate` - clear by providing an empty String
/// * `candidateGroups` - clear by providing an empty list
/// * `candidateUsers` - clear by providing an empty list
/// * `priority` - minimum 0, maximum 100, default 50
/// 
/// Providing any of those attributes with a `null` value or omitting it preserves
/// the persisted attribute's value.
/// 
/// </summary>
public sealed class JobResultCorrections
{
    /// <summary>
    /// Assignee of the task.
    /// </summary>
    [JsonPropertyName("assignee")]
    public string? Assignee { get; set; }

    /// <summary>
    /// The due date of the task.
    /// </summary>
    [JsonPropertyName("dueDate")]
    public DateTimeOffset? DueDate { get; set; }

    /// <summary>
    /// The follow-up date of the task.
    /// </summary>
    [JsonPropertyName("followUpDate")]
    public DateTimeOffset? FollowUpDate { get; set; }

    /// <summary>
    /// The list of candidate users of the task.
    /// </summary>
    [JsonPropertyName("candidateUsers")]
    public List<string>? CandidateUsers { get; set; }

    /// <summary>
    /// The list of candidate groups of the task.
    /// </summary>
    [JsonPropertyName("candidateGroups")]
    public List<string>? CandidateGroups { get; set; }

    /// <summary>
    /// The priority of the task.
    /// </summary>
    [JsonPropertyName("priority")]
    public int? Priority { get; set; }

}

/// <summary>
/// Job result details for a user task completion, optionally including a denial reason and corrected task properties.
/// 
/// </summary>
public sealed class JobResultUserTask : JobResult
{
    /// <summary>
    /// Indicates whether the worker denies the work, i.e. explicitly doesn't approve it. For example, a user task listener can deny the completion of a task by setting this flag to true. In this example, the completion of a task is represented by a job that the worker can complete as denied. As a result, the completion request is rejected and the task remains active. Defaults to false.
    /// 
    /// </summary>
    [JsonPropertyName("denied")]
    public bool? Denied { get; set; }

    /// <summary>
    /// The reason provided by the user task listener for denying the work.
    /// </summary>
    [JsonPropertyName("deniedReason")]
    public string? DeniedReason { get; set; }

    /// <summary>
    /// JSON object with attributes that were corrected by the worker.
    /// 
    /// The following attributes can be corrected, additional attributes will be ignored:
    /// 
    /// * `assignee` - clear by providing an empty String
    /// * `dueDate` - clear by providing an empty String
    /// * `followUpDate` - clear by providing an empty String
    /// * `candidateGroups` - clear by providing an empty list
    /// * `candidateUsers` - clear by providing an empty list
    /// * `priority` - minimum 0, maximum 100, default 50
    /// 
    /// Providing any of those attributes with a `null` value or omitting it preserves
    /// the persisted attribute's value.
    /// 
    /// </summary>
    [JsonPropertyName("corrections")]
    public JobResultCorrections? Corrections { get; set; }

    /// <summary>
    /// Used to distinguish between different types of job results.
    /// </summary>
    [JsonPropertyName("type")]
    public string? Type { get; set; }

}

/// <summary>
/// Job search request.
/// </summary>
public sealed class JobSearchQuery
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<JobSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The job search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public JobFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// Job search response.
/// </summary>
public sealed class JobSearchQueryResult
{
    /// <summary>
    /// The matching jobs.
    /// </summary>
    [JsonPropertyName("items")]
    public List<JobSearchResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// JobSearchQuerySortRequest
/// </summary>
public sealed class JobSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// JobSearchResult
/// </summary>
public sealed class JobSearchResult
{
    /// <summary>
    /// A set of custom headers defined during modelling.
    /// </summary>
    [JsonPropertyName("customHeaders")]
    public Dictionary<string, string> CustomHeaders { get; set; } = null!;

    /// <summary>
    /// If the job has been activated, when it will next be available to be activated.
    /// </summary>
    [JsonPropertyName("deadline")]
    public DateTimeOffset? Deadline { get; set; }

    /// <summary>
    /// The reason provided by the user task listener for denying the work.
    /// </summary>
    [JsonPropertyName("deniedReason")]
    public string? DeniedReason { get; set; }

    /// <summary>
    /// The element ID associated with the job.
    /// </summary>
    [JsonPropertyName("elementId")]
    public ElementId ElementId { get; set; }

    /// <summary>
    /// The element instance key associated with the job.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKey ElementInstanceKey { get; set; }

    /// <summary>
    /// When the job ended.
    /// </summary>
    [JsonPropertyName("endTime")]
    public DateTimeOffset? EndTime { get; set; }

    /// <summary>
    /// The error code provided for a failed job.
    /// </summary>
    [JsonPropertyName("errorCode")]
    public string? ErrorCode { get; set; }

    /// <summary>
    /// The error message that provides additional context for a failed job.
    /// </summary>
    [JsonPropertyName("errorMessage")]
    public string? ErrorMessage { get; set; }

    /// <summary>
    /// Indicates whether the job has failed with retries left.
    /// </summary>
    [JsonPropertyName("hasFailedWithRetriesLeft")]
    public bool HasFailedWithRetriesLeft { get; set; }

    /// <summary>
    /// Indicates whether the user task listener denies the work.
    /// </summary>
    [JsonPropertyName("isDenied")]
    public bool? IsDenied { get; set; }

    /// <summary>
    /// The key, a unique identifier for the job.
    /// </summary>
    [JsonPropertyName("jobKey")]
    public JobKey JobKey { get; set; }

    /// <summary>
    /// The job kind.
    /// </summary>
    [JsonPropertyName("kind")]
    public JobKindEnum Kind { get; set; }

    /// <summary>
    /// The listener event type of the job.
    /// </summary>
    [JsonPropertyName("listenerEventType")]
    public JobListenerEventTypeEnum ListenerEventType { get; set; }

    /// <summary>
    /// The process definition ID associated with the job.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId ProcessDefinitionId { get; set; }

    /// <summary>
    /// The process definition key associated with the job.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The process instance key associated with the job.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey ProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the root process instance. The root process instance is the top-level
    /// ancestor in the process instance hierarchy. This field is only present for data
    /// belonging to process instance hierarchies created in version 8.9 or later.
    /// 
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public RootProcessInstanceKey? RootProcessInstanceKey { get; set; }

    /// <summary>
    /// The amount of retries left to this job.
    /// </summary>
    [JsonPropertyName("retries")]
    public int Retries { get; set; }

    /// <summary>
    /// The state of the job.
    /// </summary>
    [JsonPropertyName("state")]
    public JobStateEnum State { get; set; }

    /// <summary>
    /// The unique identifier of the tenant.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId TenantId { get; set; }

    /// <summary>
    /// The type of the job.
    /// </summary>
    [JsonPropertyName("type")]
    public string Type { get; set; } = null!;

    /// <summary>
    /// The name of the worker of this job.
    /// </summary>
    [JsonPropertyName("worker")]
    public string Worker { get; set; } = null!;

    /// <summary>
    /// When the job was created. Field is present for jobs created after 8.9.
    /// </summary>
    [JsonPropertyName("creationTime")]
    public DateTimeOffset? CreationTime { get; set; }

    /// <summary>
    /// When the job was last updated. Field is present for jobs created after 8.9.
    /// </summary>
    [JsonPropertyName("lastUpdateTime")]
    public DateTimeOffset? LastUpdateTime { get; set; }

}

/// <summary>
/// The state of the job.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum JobStateEnum
{
    [JsonPropertyName("CANCELED")]
    CANCELED,
    [JsonPropertyName("COMPLETED")]
    COMPLETED,
    [JsonPropertyName("CREATED")]
    CREATED,
    [JsonPropertyName("ERROR_THROWN")]
    ERRORTHROWN,
    [JsonPropertyName("FAILED")]
    FAILED,
    [JsonPropertyName("MIGRATED")]
    MIGRATED,
    [JsonPropertyName("RETRIES_UPDATED")]
    RETRIESUPDATED,
    [JsonPropertyName("TIMED_OUT")]
    TIMEDOUT,
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct JobStateExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private JobStateExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="JobStateExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static JobStateExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "JobStateExactMatch");
        return new JobStateExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// JobStateEnum property with full advanced search capabilities.
/// </summary>
public sealed class JobStateFilterProperty
{
}

/// <summary>
/// JobUpdateRequest
/// </summary>
public sealed class JobUpdateRequest
{
    /// <summary>
    /// JSON object with changed job attribute values. The job cannot be completed or failed with this endpoint, use the complete job or fail job endpoints instead.
    /// </summary>
    [JsonPropertyName("changeset")]
    public JobChangeset Changeset { get; set; } = null!;

    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public OperationReference? OperationReference { get; set; }

}

/// <summary>
/// The response of a license request.
/// </summary>
public sealed class LicenseResponse
{
    /// <summary>
    /// True if the Camunda license is valid, false if otherwise
    /// </summary>
    [JsonPropertyName("validLicense")]
    public bool ValidLicense { get; set; }

    /// <summary>
    /// Will return the license type property of the Camunda license
    /// </summary>
    [JsonPropertyName("licenseType")]
    public string LicenseType { get; set; } = null!;

    /// <summary>
    /// Will be false when a license contains a non-commerical=true property
    /// </summary>
    [JsonPropertyName("isCommercial")]
    public bool IsCommercial { get; set; }

    /// <summary>
    /// The date when the Camunda license expires
    /// </summary>
    [JsonPropertyName("expiresAt")]
    public DateTimeOffset? ExpiresAt { get; set; }

}

/// <summary>
/// Checks if the property matches the provided like value.
/// 
/// Supported wildcard characters are:
/// 
/// * `*`: matches zero, one, or multiple characters.
/// * `?`: matches one, single character.
/// 
/// Wildcard characters can be escaped with backslash, for instance: `\*`.
/// 
/// </summary>
public readonly record struct LikeFilter : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private LikeFilter(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="LikeFilter"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static LikeFilter AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "LikeFilter");
        return new LikeFilter(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// LimitPagination
/// </summary>
public sealed class LimitPagination : SearchQueryPageRequest
{
    /// <summary>
    /// The maximum number of items to return in one request.
    /// </summary>
    [JsonPropertyName("limit")]
    public int? Limit { get; set; }

}

/// <summary>
/// Zeebe Engine resource key (Java long serialized as string)
/// </summary>
public readonly record struct LongKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private LongKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="LongKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static LongKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "LongKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new LongKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// MappingRuleCreateRequest
/// </summary>
public sealed class MappingRuleCreateRequest
{
    /// <summary>
    /// The unique ID of the mapping rule.
    /// </summary>
    [JsonPropertyName("mappingRuleId")]
    public string MappingRuleId { get; set; } = null!;

    /// <summary>
    /// The name of the claim to map.
    /// </summary>
    [JsonPropertyName("claimName")]
    public string ClaimName { get; set; } = null!;

    /// <summary>
    /// The value of the claim to map.
    /// </summary>
    [JsonPropertyName("claimValue")]
    public string ClaimValue { get; set; } = null!;

    /// <summary>
    /// The name of the mapping rule.
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; } = null!;

}

/// <summary>
/// MappingRuleCreateResult
/// </summary>
public sealed class MappingRuleCreateResult
{
    /// <summary>
    /// The name of the claim to map.
    /// </summary>
    [JsonPropertyName("claimName")]
    public string? ClaimName { get; set; }

    /// <summary>
    /// The value of the claim to map.
    /// </summary>
    [JsonPropertyName("claimValue")]
    public string? ClaimValue { get; set; }

    /// <summary>
    /// The name of the mapping rule.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The unique ID of the mapping rule.
    /// </summary>
    [JsonPropertyName("mappingRuleId")]
    public string? MappingRuleId { get; set; }

}

/// <summary>
/// MappingRuleCreateUpdateRequest
/// </summary>
public sealed class MappingRuleCreateUpdateRequest
{
    /// <summary>
    /// The name of the claim to map.
    /// </summary>
    [JsonPropertyName("claimName")]
    public string ClaimName { get; set; } = null!;

    /// <summary>
    /// The value of the claim to map.
    /// </summary>
    [JsonPropertyName("claimValue")]
    public string ClaimValue { get; set; } = null!;

    /// <summary>
    /// The name of the mapping rule.
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; } = null!;

}

/// <summary>
/// MappingRuleCreateUpdateResult
/// </summary>
public sealed class MappingRuleCreateUpdateResult
{
    /// <summary>
    /// The name of the claim to map.
    /// </summary>
    [JsonPropertyName("claimName")]
    public string? ClaimName { get; set; }

    /// <summary>
    /// The value of the claim to map.
    /// </summary>
    [JsonPropertyName("claimValue")]
    public string? ClaimValue { get; set; }

    /// <summary>
    /// The name of the mapping rule.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The unique ID of the mapping rule.
    /// </summary>
    [JsonPropertyName("mappingRuleId")]
    public string? MappingRuleId { get; set; }

}

/// <summary>
/// Mapping rule search filter.
/// </summary>
public sealed class MappingRuleFilter
{
    /// <summary>
    /// The claim name to match against a token.
    /// </summary>
    [JsonPropertyName("claimName")]
    public string? ClaimName { get; set; }

    /// <summary>
    /// The value of the claim to match.
    /// </summary>
    [JsonPropertyName("claimValue")]
    public string? ClaimValue { get; set; }

    /// <summary>
    /// The name of the mapping rule.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The ID of the mapping rule.
    /// </summary>
    [JsonPropertyName("mappingRuleId")]
    public string? MappingRuleId { get; set; }

}

/// <summary>
/// MappingRuleResult
/// </summary>
public sealed class MappingRuleResult
{
    /// <summary>
    /// The name of the claim to map.
    /// </summary>
    [JsonPropertyName("claimName")]
    public string? ClaimName { get; set; }

    /// <summary>
    /// The value of the claim to map.
    /// </summary>
    [JsonPropertyName("claimValue")]
    public string? ClaimValue { get; set; }

    /// <summary>
    /// The name of the mapping rule.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The ID of the mapping rule.
    /// </summary>
    [JsonPropertyName("mappingRuleId")]
    public string? MappingRuleId { get; set; }

}

/// <summary>
/// MappingRuleSearchQueryRequest
/// </summary>
public sealed class MappingRuleSearchQueryRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<MappingRuleSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The mapping rule search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public MappingRuleFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// MappingRuleSearchQueryResult
/// </summary>
public sealed class MappingRuleSearchQueryResult
{
    /// <summary>
    /// The matching mapping rules.
    /// </summary>
    [JsonPropertyName("items")]
    public List<MappingRuleResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// MappingRuleSearchQuerySortRequest
/// </summary>
public sealed class MappingRuleSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// MappingRuleUpdateRequest
/// </summary>
public sealed class MappingRuleUpdateRequest
{
    /// <summary>
    /// The name of the claim to map.
    /// </summary>
    [JsonPropertyName("claimName")]
    public string ClaimName { get; set; } = null!;

    /// <summary>
    /// The value of the claim to map.
    /// </summary>
    [JsonPropertyName("claimValue")]
    public string ClaimValue { get; set; } = null!;

    /// <summary>
    /// The name of the mapping rule.
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; } = null!;

}

/// <summary>
/// MappingRuleUpdateResult
/// </summary>
public sealed class MappingRuleUpdateResult
{
    /// <summary>
    /// The name of the claim to map.
    /// </summary>
    [JsonPropertyName("claimName")]
    public string? ClaimName { get; set; }

    /// <summary>
    /// The value of the claim to map.
    /// </summary>
    [JsonPropertyName("claimValue")]
    public string? ClaimValue { get; set; }

    /// <summary>
    /// The name of the mapping rule.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The unique ID of the mapping rule.
    /// </summary>
    [JsonPropertyName("mappingRuleId")]
    public string? MappingRuleId { get; set; }

}

/// <summary>
/// A decision rule that matched within this decision evaluation.
/// </summary>
public sealed class MatchedDecisionRuleItem
{
    /// <summary>
    /// The ID of the matched rule.
    /// </summary>
    [JsonPropertyName("ruleId")]
    public string? RuleId { get; set; }

    /// <summary>
    /// The index of the matched rule.
    /// </summary>
    [JsonPropertyName("ruleIndex")]
    public int? RuleIndex { get; set; }

    /// <summary>
    /// The evaluated decision outputs.
    /// </summary>
    [JsonPropertyName("evaluatedOutputs")]
    public List<EvaluatedDecisionOutputItem>? EvaluatedOutputs { get; set; }

}

/// <summary>
/// MessageCorrelationRequest
/// </summary>
public sealed class MessageCorrelationRequest : global::Camunda.Orchestration.Sdk.Runtime.ITenantIdSettable
{
    /// <summary>
    /// The message name as defined in the BPMN process
    /// 
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; } = null!;

    /// <summary>
    /// The correlation key of the message.
    /// </summary>
    [JsonPropertyName("correlationKey")]
    public string? CorrelationKey { get; set; }

    /// <summary>
    /// The message variables as JSON document
    /// </summary>
    [JsonPropertyName("variables")]
    public object? Variables { get; set; }

    /// <summary>
    /// the tenant for which the message is published
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <inheritdoc />
    public void SetDefaultTenantId(string tenantId) { TenantId ??= global::Camunda.Orchestration.Sdk.Api.TenantId.AssumeExists(tenantId); }

}

/// <summary>
/// The message key of the correlated message, as well as the first process instance key it
/// correlated with.
/// 
/// </summary>
public sealed class MessageCorrelationResult
{
    /// <summary>
    /// The tenant ID of the correlated message
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The key of the correlated message.
    /// </summary>
    [JsonPropertyName("messageKey")]
    public MessageKey? MessageKey { get; set; }

    /// <summary>
    /// The key of the first process instance the message correlated with
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

}

/// <summary>
/// System-generated key for an message.
/// </summary>
public readonly record struct MessageKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private MessageKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="MessageKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static MessageKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "MessageKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new MessageKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// MessagePublicationRequest
/// </summary>
public sealed class MessagePublicationRequest : global::Camunda.Orchestration.Sdk.Runtime.ITenantIdSettable
{
    /// <summary>
    /// The name of the message.
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; } = null!;

    /// <summary>
    /// The correlation key of the message.
    /// </summary>
    [JsonPropertyName("correlationKey")]
    public string? CorrelationKey { get; set; }

    /// <summary>
    /// Timespan (in ms) to buffer the message on the broker.
    /// </summary>
    [JsonPropertyName("timeToLive")]
    public long? TimeToLive { get; set; }

    /// <summary>
    /// The unique ID of the message. This is used to ensure only one message with the given ID
    /// will be published during the lifetime of the message (if `timeToLive` is set).
    /// 
    /// </summary>
    [JsonPropertyName("messageId")]
    public string? MessageId { get; set; }

    /// <summary>
    /// The message variables as JSON document.
    /// </summary>
    [JsonPropertyName("variables")]
    public object? Variables { get; set; }

    /// <summary>
    /// The tenant of the message sender.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <inheritdoc />
    public void SetDefaultTenantId(string tenantId) { TenantId ??= global::Camunda.Orchestration.Sdk.Api.TenantId.AssumeExists(tenantId); }

}

/// <summary>
/// The message key of the published message.
/// </summary>
public sealed class MessagePublicationResult
{
    /// <summary>
    /// The tenant ID of the message.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The key of the published message.
    /// </summary>
    [JsonPropertyName("messageKey")]
    public MessageKey? MessageKey { get; set; }

}

/// <summary>
/// Message subscription search filter.
/// </summary>
public sealed class MessageSubscriptionFilter
{
    /// <summary>
    /// The message subscription key associated with this message subscription.
    /// </summary>
    [JsonPropertyName("messageSubscriptionKey")]
    public MessageSubscriptionKeyFilterProperty? MessageSubscriptionKey { get; set; }

    /// <summary>
    /// The process definition key associated with this correlated message subscription. This only works for data created with 8.9 and later.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKeyFilterProperty? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The process definition ID associated with this message subscription.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public StringFilterProperty? ProcessDefinitionId { get; set; }

    /// <summary>
    /// The process instance key associated with this message subscription.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKeyFilterProperty? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The element ID associated with this message subscription.
    /// </summary>
    [JsonPropertyName("elementId")]
    public StringFilterProperty? ElementId { get; set; }

    /// <summary>
    /// The element instance key associated with this message subscription.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKeyFilterProperty? ElementInstanceKey { get; set; }

    /// <summary>
    /// The message subscription state.
    /// </summary>
    [JsonPropertyName("messageSubscriptionState")]
    public MessageSubscriptionStateFilterProperty? MessageSubscriptionState { get; set; }

    /// <summary>
    /// The last updated date of the message subscription.
    /// </summary>
    [JsonPropertyName("lastUpdatedDate")]
    public DateTimeFilterProperty? LastUpdatedDate { get; set; }

    /// <summary>
    /// The name of the message associated with the message subscription.
    /// </summary>
    [JsonPropertyName("messageName")]
    public StringFilterProperty? MessageName { get; set; }

    /// <summary>
    /// The correlation key of the message subscription.
    /// </summary>
    [JsonPropertyName("correlationKey")]
    public StringFilterProperty? CorrelationKey { get; set; }

    /// <summary>
    /// The unique external tenant ID.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public StringFilterProperty? TenantId { get; set; }

}

/// <summary>
/// System-generated key for a message subscription.
/// </summary>
public readonly record struct MessageSubscriptionKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private MessageSubscriptionKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="MessageSubscriptionKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static MessageSubscriptionKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "MessageSubscriptionKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new MessageSubscriptionKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct MessageSubscriptionKeyExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private MessageSubscriptionKeyExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="MessageSubscriptionKeyExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static MessageSubscriptionKeyExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "MessageSubscriptionKeyExactMatch");
        return new MessageSubscriptionKeyExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// MessageSubscriptionKey property with full advanced search capabilities.
/// </summary>
public sealed class MessageSubscriptionKeyFilterProperty
{
}

/// <summary>
/// MessageSubscriptionResult
/// </summary>
public sealed class MessageSubscriptionResult
{
    /// <summary>
    /// The message subscription key associated with this message subscription.
    /// </summary>
    [JsonPropertyName("messageSubscriptionKey")]
    public MessageSubscriptionKey? MessageSubscriptionKey { get; set; }

    /// <summary>
    /// The process definition ID associated with this message subscription.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId? ProcessDefinitionId { get; set; }

    /// <summary>
    /// The process definition key associated with this message subscription.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The process instance key associated with this message subscription.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the root process instance. The root process instance is the top-level
    /// ancestor in the process instance hierarchy. This field is only present for data
    /// belonging to process instance hierarchies created in version 8.9 or later.
    /// 
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public RootProcessInstanceKey? RootProcessInstanceKey { get; set; }

    /// <summary>
    /// The element ID associated with this message subscription.
    /// </summary>
    [JsonPropertyName("elementId")]
    public ElementId? ElementId { get; set; }

    /// <summary>
    /// The element instance key associated with this message subscription.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKey? ElementInstanceKey { get; set; }

    /// <summary>
    /// The state of message subscription.
    /// </summary>
    [JsonPropertyName("messageSubscriptionState")]
    public MessageSubscriptionStateEnum? MessageSubscriptionState { get; set; }

    /// <summary>
    /// The last updated date of the message subscription.
    /// </summary>
    [JsonPropertyName("lastUpdatedDate")]
    public DateTimeOffset? LastUpdatedDate { get; set; }

    /// <summary>
    /// The name of the message associated with the message subscription.
    /// </summary>
    [JsonPropertyName("messageName")]
    public string? MessageName { get; set; }

    /// <summary>
    /// The correlation key of the message subscription.
    /// </summary>
    [JsonPropertyName("correlationKey")]
    public string? CorrelationKey { get; set; }

    /// <summary>
    /// The unique identifier of the tenant.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

}

/// <summary>
/// MessageSubscriptionSearchQuery
/// </summary>
public sealed class MessageSubscriptionSearchQuery
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<MessageSubscriptionSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The incident search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public MessageSubscriptionFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// MessageSubscriptionSearchQueryResult
/// </summary>
public sealed class MessageSubscriptionSearchQueryResult
{
    /// <summary>
    /// The matching message subscriptions.
    /// </summary>
    [JsonPropertyName("items")]
    public List<MessageSubscriptionResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// MessageSubscriptionSearchQuerySortRequest
/// </summary>
public sealed class MessageSubscriptionSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// The state of message subscription.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum MessageSubscriptionStateEnum
{
    [JsonPropertyName("CORRELATED")]
    CORRELATED,
    [JsonPropertyName("CREATED")]
    CREATED,
    [JsonPropertyName("DELETED")]
    DELETED,
    [JsonPropertyName("MIGRATED")]
    MIGRATED,
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct MessageSubscriptionStateExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private MessageSubscriptionStateExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="MessageSubscriptionStateExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static MessageSubscriptionStateExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "MessageSubscriptionStateExactMatch");
        return new MessageSubscriptionStateExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// MessageSubscriptionStateEnum with full advanced search capabilities.
/// </summary>
public sealed class MessageSubscriptionStateFilterProperty
{
}

/// <summary>
/// The mapping instructions describe how to map elements from the source process definition to the target process definition.
/// 
/// </summary>
public sealed class MigrateProcessInstanceMappingInstruction
{
    /// <summary>
    /// The element id to migrate from.
    /// </summary>
    [JsonPropertyName("sourceElementId")]
    public ElementId SourceElementId { get; set; }

    /// <summary>
    /// The element id to migrate into.
    /// </summary>
    [JsonPropertyName("targetElementId")]
    public ElementId TargetElementId { get; set; }

}

/// <summary>
/// Instruction describing which variables to create or update.
/// </summary>
public sealed class ModifyProcessInstanceVariableInstruction
{
    /// <summary>
    /// JSON document that will instantiate the variables at the scope defined by the scopeId.
    /// It must be a JSON object, as variables will be mapped in a key-value fashion.
    /// 
    /// </summary>
    [JsonPropertyName("variables")]
    public object Variables { get; set; } = null!;

    /// <summary>
    /// The id of the element in which scope the variables should be created.
    /// Leave empty to create the variables in the global scope of the process instance.
    /// 
    /// </summary>
    [JsonPropertyName("scopeId")]
    public string? ScopeId { get; set; }

}

/// <summary>
/// OffsetPagination
/// </summary>
public sealed class OffsetPagination : SearchQueryPageRequest
{
    /// <summary>
    /// The index of items to start searching from.
    /// </summary>
    [JsonPropertyName("from")]
    public int? From { get; set; }

    /// <summary>
    /// The maximum number of items to return in one request.
    /// </summary>
    [JsonPropertyName("limit")]
    public int? Limit { get; set; }

}

/// <summary>
/// A reference key chosen by the user that will be part of all records resulting from this operation.
/// Must be &gt; 0 if provided.
/// 
/// </summary>
public readonly record struct OperationReference : global::Camunda.Orchestration.Sdk.Runtime.ICamundaLongKey
{
    /// <summary>The underlying long value.</summary>
    public long Value { get; }

    private OperationReference(long value) => Value = value;

    /// <summary>
    /// Creates a <see cref="OperationReference"/> from a raw long value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static OperationReference AssumeExists(long value)
    {
        return new OperationReference(value);
    }

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct OperationTypeExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private OperationTypeExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="OperationTypeExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static OperationTypeExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "OperationTypeExactMatch");
        return new OperationTypeExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// AuditLogOperationTypeEnum property with full advanced search capabilities.
/// </summary>
public sealed class OperationTypeFilterProperty
{
}

/// <summary>
/// The type of the owner of permissions.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum OwnerTypeEnum
{
    [JsonPropertyName("USER")]
    USER,
    [JsonPropertyName("CLIENT")]
    CLIENT,
    [JsonPropertyName("ROLE")]
    ROLE,
    [JsonPropertyName("GROUP")]
    GROUP,
    [JsonPropertyName("MAPPING_RULE")]
    MAPPINGRULE,
    [JsonPropertyName("UNSPECIFIED")]
    UNSPECIFIED,
}

/// <summary>
/// Provides information on a partition within a broker node.
/// </summary>
public sealed class Partition
{
    /// <summary>
    /// The unique ID of this partition.
    /// </summary>
    [JsonPropertyName("partitionId")]
    public int PartitionId { get; set; }

    /// <summary>
    /// Describes the Raft role of the broker for a given partition.
    /// </summary>
    [JsonPropertyName("role")]
    public string Role { get; set; } = null!;

    /// <summary>
    /// Describes the current health of the partition.
    /// </summary>
    [JsonPropertyName("health")]
    public string Health { get; set; } = null!;

}

/// <summary>
/// Specifies the type of permissions.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum PermissionTypeEnum
{
    [JsonPropertyName("ACCESS")]
    ACCESS,
    [JsonPropertyName("CANCEL_PROCESS_INSTANCE")]
    CANCELPROCESSINSTANCE,
    [JsonPropertyName("CLAIM")]
    CLAIM,
    [JsonPropertyName("COMPLETE")]
    COMPLETE,
    [JsonPropertyName("CREATE")]
    CREATE,
    [JsonPropertyName("CREATE_BATCH_OPERATION_CANCEL_PROCESS_INSTANCE")]
    CREATEBATCHOPERATIONCANCELPROCESSINSTANCE,
    [JsonPropertyName("CREATE_BATCH_OPERATION_DELETE_DECISION_DEFINITION")]
    CREATEBATCHOPERATIONDELETEDECISIONDEFINITION,
    [JsonPropertyName("CREATE_BATCH_OPERATION_DELETE_DECISION_INSTANCE")]
    CREATEBATCHOPERATIONDELETEDECISIONINSTANCE,
    [JsonPropertyName("CREATE_BATCH_OPERATION_DELETE_PROCESS_DEFINITION")]
    CREATEBATCHOPERATIONDELETEPROCESSDEFINITION,
    [JsonPropertyName("CREATE_BATCH_OPERATION_DELETE_PROCESS_INSTANCE")]
    CREATEBATCHOPERATIONDELETEPROCESSINSTANCE,
    [JsonPropertyName("CREATE_BATCH_OPERATION_MIGRATE_PROCESS_INSTANCE")]
    CREATEBATCHOPERATIONMIGRATEPROCESSINSTANCE,
    [JsonPropertyName("CREATE_BATCH_OPERATION_MODIFY_PROCESS_INSTANCE")]
    CREATEBATCHOPERATIONMODIFYPROCESSINSTANCE,
    [JsonPropertyName("CREATE_BATCH_OPERATION_RESOLVE_INCIDENT")]
    CREATEBATCHOPERATIONRESOLVEINCIDENT,
    [JsonPropertyName("CREATE_DECISION_INSTANCE")]
    CREATEDECISIONINSTANCE,
    [JsonPropertyName("CREATE_PROCESS_INSTANCE")]
    CREATEPROCESSINSTANCE,
    [JsonPropertyName("CREATE_TASK_LISTENER")]
    CREATETASKLISTENER,
    [JsonPropertyName("DELETE")]
    DELETE,
    [JsonPropertyName("DELETE_DECISION_INSTANCE")]
    DELETEDECISIONINSTANCE,
    [JsonPropertyName("DELETE_DRD")]
    DELETEDRD,
    [JsonPropertyName("DELETE_FORM")]
    DELETEFORM,
    [JsonPropertyName("DELETE_PROCESS")]
    DELETEPROCESS,
    [JsonPropertyName("DELETE_PROCESS_INSTANCE")]
    DELETEPROCESSINSTANCE,
    [JsonPropertyName("DELETE_RESOURCE")]
    DELETERESOURCE,
    [JsonPropertyName("DELETE_TASK_LISTENER")]
    DELETETASKLISTENER,
    [JsonPropertyName("EVALUATE")]
    EVALUATE,
    [JsonPropertyName("MODIFY_PROCESS_INSTANCE")]
    MODIFYPROCESSINSTANCE,
    [JsonPropertyName("READ")]
    READ,
    [JsonPropertyName("READ_DECISION_DEFINITION")]
    READDECISIONDEFINITION,
    [JsonPropertyName("READ_DECISION_INSTANCE")]
    READDECISIONINSTANCE,
    [JsonPropertyName("READ_JOB_METRIC")]
    READJOBMETRIC,
    [JsonPropertyName("READ_PROCESS_DEFINITION")]
    READPROCESSDEFINITION,
    [JsonPropertyName("READ_PROCESS_INSTANCE")]
    READPROCESSINSTANCE,
    [JsonPropertyName("READ_USAGE_METRIC")]
    READUSAGEMETRIC,
    [JsonPropertyName("READ_USER_TASK")]
    READUSERTASK,
    [JsonPropertyName("READ_TASK_LISTENER")]
    READTASKLISTENER,
    [JsonPropertyName("UPDATE")]
    UPDATE,
    [JsonPropertyName("UPDATE_PROCESS_INSTANCE")]
    UPDATEPROCESSINSTANCE,
    [JsonPropertyName("UPDATE_USER_TASK")]
    UPDATEUSERTASK,
    [JsonPropertyName("UPDATE_TASK_LISTENER")]
    UPDATETASKLISTENER,
}

/// <summary>
/// A Problem detail object as described in [RFC 9457](https://www.rfc-editor.org/rfc/rfc9457). There may be additional properties specific to the problem type.
/// 
/// </summary>
public sealed class ProblemDetail
{
    /// <summary>
    /// A URI identifying the problem type.
    /// </summary>
    [JsonPropertyName("type")]
    public string? Type { get; set; }

    /// <summary>
    /// A summary of the problem type.
    /// </summary>
    [JsonPropertyName("title")]
    public string? Title { get; set; }

    /// <summary>
    /// The HTTP status code for this problem.
    /// </summary>
    [JsonPropertyName("status")]
    public int? Status { get; set; }

    /// <summary>
    /// An explanation of the problem in more detail.
    /// </summary>
    [JsonPropertyName("detail")]
    public string? Detail { get; set; }

    /// <summary>
    /// A URI path identifying the origin of the problem.
    /// </summary>
    [JsonPropertyName("instance")]
    public string? Instance { get; set; }

}

/// <summary>
/// Process definition element statistics request.
/// </summary>
public sealed class ProcessDefinitionElementStatisticsQuery
{
    /// <summary>
    /// The process definition statistics search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public ProcessDefinitionStatisticsFilter? Filter { get; set; }

}

/// <summary>
/// Process definition element statistics query response.
/// </summary>
public sealed class ProcessDefinitionElementStatisticsQueryResult
{
    /// <summary>
    /// The element statistics.
    /// </summary>
    [JsonPropertyName("items")]
    public List<ProcessElementStatisticsResult>? Items { get; set; }

}

/// <summary>
/// Process definition search filter.
/// </summary>
public sealed class ProcessDefinitionFilter
{
    /// <summary>
    /// Name of this process definition.
    /// </summary>
    [JsonPropertyName("name")]
    public StringFilterProperty? Name { get; set; }

    /// <summary>
    /// Whether to only return the latest version of each process definition.
    /// When using this filter, pagination functionality is limited, you can only paginate forward using `after` and `limit`.
    /// The response contains no `startCursor` in the `page`, and requests ignore the `from` and `before` in the `page`.
    /// 
    /// </summary>
    [JsonPropertyName("isLatestVersion")]
    public bool? IsLatestVersion { get; set; }

    /// <summary>
    /// Resource name of this process definition.
    /// </summary>
    [JsonPropertyName("resourceName")]
    public string? ResourceName { get; set; }

    /// <summary>
    /// Version of this process definition.
    /// </summary>
    [JsonPropertyName("version")]
    public int? Version { get; set; }

    /// <summary>
    /// Version tag of this process definition.
    /// </summary>
    [JsonPropertyName("versionTag")]
    public string? VersionTag { get; set; }

    /// <summary>
    /// Process definition ID of this process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public StringFilterProperty? ProcessDefinitionId { get; set; }

    /// <summary>
    /// Tenant ID of this process definition.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The key for this process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// Indicates whether the start event of the process has an associated Form Key.
    /// </summary>
    [JsonPropertyName("hasStartForm")]
    public bool? HasStartForm { get; set; }

}

/// <summary>
/// Id of a process definition, from the model. Only ids of process definitions that are deployed are useful.
/// </summary>
public readonly record struct ProcessDefinitionId : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private ProcessDefinitionId(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="ProcessDefinitionId"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static ProcessDefinitionId AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "ProcessDefinitionId", pattern: @"^[a-zA-Z_][a-zA-Z0-9_\-\.]*$", minLength: 1);
        return new ProcessDefinitionId(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^[a-zA-Z_][a-zA-Z0-9_\-\.]*$", minLength: 1);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// ProcessDefinitionInstanceStatisticsQuery
/// </summary>
public sealed class ProcessDefinitionInstanceStatisticsQuery
{
    [JsonPropertyName("page")]
    public OffsetPagination? Page { get; set; }

    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<ProcessDefinitionInstanceStatisticsQuerySortRequest>? Sort { get; set; }

}

/// <summary>
/// ProcessDefinitionInstanceStatisticsQueryResult
/// </summary>
public sealed class ProcessDefinitionInstanceStatisticsQueryResult
{
    /// <summary>
    /// The process definition instance statistics result.
    /// </summary>
    [JsonPropertyName("items")]
    public List<ProcessDefinitionInstanceStatisticsResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// ProcessDefinitionInstanceStatisticsQuerySortRequest
/// </summary>
public sealed class ProcessDefinitionInstanceStatisticsQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// Process definition instance statistics response.
/// </summary>
public sealed class ProcessDefinitionInstanceStatisticsResult
{
    /// <summary>
    /// Id of a process definition, from the model. Only ids of process definitions that are deployed are useful.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId? ProcessDefinitionId { get; set; }

    /// <summary>
    /// The unique identifier of the tenant.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// Name of the latest deployed process definition instance version.
    /// </summary>
    [JsonPropertyName("latestProcessDefinitionName")]
    public string? LatestProcessDefinitionName { get; set; }

    /// <summary>
    /// Indicates whether multiple versions of this process definition instance are deployed.
    /// </summary>
    [JsonPropertyName("hasMultipleVersions")]
    public bool? HasMultipleVersions { get; set; }

    /// <summary>
    /// Total number of currently active process instances of this definition that do not have incidents.
    /// </summary>
    [JsonPropertyName("activeInstancesWithoutIncidentCount")]
    public long? ActiveInstancesWithoutIncidentCount { get; set; }

    /// <summary>
    /// Total number of currently active process instances of this definition that have at least one incident.
    /// </summary>
    [JsonPropertyName("activeInstancesWithIncidentCount")]
    public long? ActiveInstancesWithIncidentCount { get; set; }

}

/// <summary>
/// Process definition instance version statistics search filter.
/// </summary>
public sealed class ProcessDefinitionInstanceVersionStatisticsFilter
{
    /// <summary>
    /// The ID of the process definition to retrieve version statistics for.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId ProcessDefinitionId { get; set; }

    /// <summary>
    /// Tenant ID of this process definition.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

}

/// <summary>
/// ProcessDefinitionInstanceVersionStatisticsQuery
/// </summary>
public sealed class ProcessDefinitionInstanceVersionStatisticsQuery
{
    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public OffsetPagination? Page { get; set; }

    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<ProcessDefinitionInstanceVersionStatisticsQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The process definition instance version statistics search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public ProcessDefinitionInstanceVersionStatisticsFilter Filter { get; set; } = null!;

}

/// <summary>
/// ProcessDefinitionInstanceVersionStatisticsQueryResult
/// </summary>
public sealed class ProcessDefinitionInstanceVersionStatisticsQueryResult
{
    /// <summary>
    /// The process definition instance version statistics result.
    /// </summary>
    [JsonPropertyName("items")]
    public List<ProcessDefinitionInstanceVersionStatisticsResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// ProcessDefinitionInstanceVersionStatisticsQuerySortRequest
/// </summary>
public sealed class ProcessDefinitionInstanceVersionStatisticsQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// Process definition instance version statistics response.
/// </summary>
public sealed class ProcessDefinitionInstanceVersionStatisticsResult
{
    /// <summary>
    /// The ID associated with the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId ProcessDefinitionId { get; set; }

    /// <summary>
    /// The unique key of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The name of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionName")]
    public string ProcessDefinitionName { get; set; } = null!;

    /// <summary>
    /// The tenant ID associated with the process definition.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId TenantId { get; set; }

    /// <summary>
    /// The version number of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionVersion")]
    public int ProcessDefinitionVersion { get; set; }

    /// <summary>
    /// The number of active process instances for this version that currently have incidents.
    /// </summary>
    [JsonPropertyName("activeInstancesWithIncidentCount")]
    public long ActiveInstancesWithIncidentCount { get; set; }

    /// <summary>
    /// The number of active process instances for this version that do not have any incidents.
    /// </summary>
    [JsonPropertyName("activeInstancesWithoutIncidentCount")]
    public long ActiveInstancesWithoutIncidentCount { get; set; }

}

/// <summary>
/// System-generated key for a deployed process definition.
/// </summary>
public readonly record struct ProcessDefinitionKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private ProcessDefinitionKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="ProcessDefinitionKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static ProcessDefinitionKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "ProcessDefinitionKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new ProcessDefinitionKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct ProcessDefinitionKeyExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private ProcessDefinitionKeyExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="ProcessDefinitionKeyExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static ProcessDefinitionKeyExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "ProcessDefinitionKeyExactMatch");
        return new ProcessDefinitionKeyExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// ProcessDefinitionKey property with full advanced search capabilities.
/// </summary>
public sealed class ProcessDefinitionKeyFilterProperty
{
}

/// <summary>
/// ProcessDefinitionMessageSubscriptionStatisticsQuery
/// </summary>
public sealed class ProcessDefinitionMessageSubscriptionStatisticsQuery
{
    [JsonPropertyName("page")]
    public CursorForwardPagination? Page { get; set; }

    /// <summary>
    /// The message subscription filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public MessageSubscriptionFilter? Filter { get; set; }

}

/// <summary>
/// ProcessDefinitionMessageSubscriptionStatisticsQueryResult
/// </summary>
public sealed class ProcessDefinitionMessageSubscriptionStatisticsQueryResult
{
    /// <summary>
    /// The matching process definition message subscription statistics.
    /// </summary>
    [JsonPropertyName("items")]
    public List<ProcessDefinitionMessageSubscriptionStatisticsResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// ProcessDefinitionMessageSubscriptionStatisticsResult
/// </summary>
public sealed class ProcessDefinitionMessageSubscriptionStatisticsResult
{
    /// <summary>
    /// The process definition ID associated with this message subscription.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId? ProcessDefinitionId { get; set; }

    /// <summary>
    /// The tenant ID associated with this message subscription.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The process definition key associated with this message subscription.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The number of process instances with active message subscriptions.
    /// </summary>
    [JsonPropertyName("processInstancesWithActiveSubscriptions")]
    public long? ProcessInstancesWithActiveSubscriptions { get; set; }

    /// <summary>
    /// The total number of active message subscriptions for this process definition key.
    /// </summary>
    [JsonPropertyName("activeSubscriptions")]
    public long? ActiveSubscriptions { get; set; }

}

/// <summary>
/// ProcessDefinitionResult
/// </summary>
public sealed class ProcessDefinitionResult
{
    /// <summary>
    /// Name of this process definition.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// Resource name for this process definition.
    /// </summary>
    [JsonPropertyName("resourceName")]
    public string? ResourceName { get; set; }

    /// <summary>
    /// Version of this process definition.
    /// </summary>
    [JsonPropertyName("version")]
    public int? Version { get; set; }

    /// <summary>
    /// Version tag of this process definition.
    /// </summary>
    [JsonPropertyName("versionTag")]
    public string? VersionTag { get; set; }

    /// <summary>
    /// Process definition ID of this process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId? ProcessDefinitionId { get; set; }

    /// <summary>
    /// Tenant ID of this process definition.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The key for this process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// Indicates whether the start event of the process has an associated Form Key.
    /// </summary>
    [JsonPropertyName("hasStartForm")]
    public bool? HasStartForm { get; set; }

}

/// <summary>
/// ProcessDefinitionSearchQuery
/// </summary>
public sealed class ProcessDefinitionSearchQuery
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<ProcessDefinitionSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The process definition search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public ProcessDefinitionFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// ProcessDefinitionSearchQueryResult
/// </summary>
public sealed class ProcessDefinitionSearchQueryResult
{
    /// <summary>
    /// The matching process definitions.
    /// </summary>
    [JsonPropertyName("items")]
    public List<ProcessDefinitionResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// ProcessDefinitionSearchQuerySortRequest
/// </summary>
public sealed class ProcessDefinitionSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// Process definition statistics search filter.
/// </summary>
public sealed class ProcessDefinitionStatisticsFilter
{
    /// <summary>
    /// The start date.
    /// </summary>
    [JsonPropertyName("startDate")]
    public DateTimeFilterProperty? StartDate { get; set; }

    /// <summary>
    /// The end date.
    /// </summary>
    [JsonPropertyName("endDate")]
    public DateTimeFilterProperty? EndDate { get; set; }

    /// <summary>
    /// The process instance state.
    /// </summary>
    [JsonPropertyName("state")]
    public ProcessInstanceStateFilterProperty? State { get; set; }

    /// <summary>
    /// Whether this process instance has a related incident or not.
    /// </summary>
    [JsonPropertyName("hasIncident")]
    public bool? HasIncident { get; set; }

    /// <summary>
    /// The tenant id.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public StringFilterProperty? TenantId { get; set; }

    /// <summary>
    /// The process instance variables.
    /// </summary>
    [JsonPropertyName("variables")]
    public List<VariableValueFilterProperty>? Variables { get; set; }

    /// <summary>
    /// The key of this process instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKeyFilterProperty? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The parent process instance key.
    /// </summary>
    [JsonPropertyName("parentProcessInstanceKey")]
    public ProcessInstanceKeyFilterProperty? ParentProcessInstanceKey { get; set; }

    /// <summary>
    /// The parent element instance key.
    /// </summary>
    [JsonPropertyName("parentElementInstanceKey")]
    public ElementInstanceKeyFilterProperty? ParentElementInstanceKey { get; set; }

    /// <summary>
    /// The batch operation id.
    /// </summary>
    [JsonPropertyName("batchOperationId")]
    public StringFilterProperty? BatchOperationId { get; set; }

    /// <summary>
    /// The error message related to the process.
    /// </summary>
    [JsonPropertyName("errorMessage")]
    public StringFilterProperty? ErrorMessage { get; set; }

    /// <summary>
    /// Whether the process has failed jobs with retries left.
    /// </summary>
    [JsonPropertyName("hasRetriesLeft")]
    public bool? HasRetriesLeft { get; set; }

    /// <summary>
    /// The state of the element instances associated with the process instance.
    /// </summary>
    [JsonPropertyName("elementInstanceState")]
    public ElementInstanceStateFilterProperty? ElementInstanceState { get; set; }

    /// <summary>
    /// The element id associated with the process instance.
    /// </summary>
    [JsonPropertyName("elementId")]
    public StringFilterProperty? ElementId { get; set; }

    /// <summary>
    /// Whether the element instance has an incident or not.
    /// </summary>
    [JsonPropertyName("hasElementInstanceIncident")]
    public bool? HasElementInstanceIncident { get; set; }

    /// <summary>
    /// The incident error hash code, associated with this process.
    /// </summary>
    [JsonPropertyName("incidentErrorHashCode")]
    public IntegerFilterProperty? IncidentErrorHashCode { get; set; }

    /// <summary>
    /// List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
    /// </summary>
    [JsonPropertyName("tags")]
    public List<Tag>? Tags { get; set; }

    /// <summary>
    /// Defines a list of alternative filter groups combined using OR logic. Each object in the array is evaluated independently, and the filter matches if any one of them is satisfied.
    /// 
    /// Top-level fields and the `$or` clause are combined using AND logic â€” meaning: (top-level filters) AND (any of the `$or` filters) must match.
    /// &lt;br&gt;
    /// &lt;em&gt;Example:&lt;/em&gt;
    /// 
    /// ```json
    /// {
    ///   "state": "ACTIVE",
    ///   "tenantId": 123,
    ///   "$or": [
    ///     { "processDefinitionId": "process_v1" },
    ///     { "processDefinitionId": "process_v2", "hasIncident": true }
    ///   ]
    /// }
    /// ```
    /// This matches process instances that:
    /// 
    /// &lt;ul style="padding-left: 20px; margin-left: 20px;"&gt;
    ///   &lt;li style="list-style-type: disc;"&gt;are in &lt;em&gt;ACTIVE&lt;/em&gt; state&lt;/li&gt;
    ///   &lt;li style="list-style-type: disc;"&gt;have tenant id equal to &lt;em&gt;123&lt;/em&gt;&lt;/li&gt;
    ///   &lt;li style="list-style-type: disc;"&gt;and match either:
    ///     &lt;ul style="padding-left: 20px; margin-left: 20px;"&gt;
    ///       &lt;li style="list-style-type: circle;"&gt;&lt;code&gt;processDefinitionId&lt;/code&gt; is &lt;em&gt;process_v1&lt;/em&gt;, or&lt;/li&gt;
    ///       &lt;li style="list-style-type: circle;"&gt;&lt;code&gt;processDefinitionId&lt;/code&gt; is &lt;em&gt;process_v2&lt;/em&gt; and &lt;code&gt;hasIncident&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt;&lt;/li&gt;
    ///     &lt;/ul&gt;
    ///   &lt;/li&gt;
    /// &lt;/ul&gt;
    /// &lt;br&gt;
    /// &lt;p&gt;Note: Using complex &lt;code&gt;$or&lt;/code&gt; conditions may impact performance, use with caution in high-volume environments.
    /// 
    /// </summary>
    [JsonPropertyName("$or")]
    public List<BaseProcessInstanceFilterFields>? Or { get; set; }

}

/// <summary>
/// Process element statistics response.
/// </summary>
public sealed class ProcessElementStatisticsResult
{
    /// <summary>
    /// The element ID for which the results are aggregated.
    /// </summary>
    [JsonPropertyName("elementId")]
    public ElementId? ElementId { get; set; }

    /// <summary>
    /// The total number of active instances of the element.
    /// </summary>
    [JsonPropertyName("active")]
    public long? Active { get; set; }

    /// <summary>
    /// The total number of canceled instances of the element.
    /// </summary>
    [JsonPropertyName("canceled")]
    public long? Canceled { get; set; }

    /// <summary>
    /// The total number of incidents for the element.
    /// </summary>
    [JsonPropertyName("incidents")]
    public long? Incidents { get; set; }

    /// <summary>
    /// The total number of completed instances of the element.
    /// </summary>
    [JsonPropertyName("completed")]
    public long? Completed { get; set; }

}

/// <summary>
/// ProcessInstanceCallHierarchyEntry
/// </summary>
public sealed class ProcessInstanceCallHierarchyEntry
{
    /// <summary>
    /// The key of the process instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey ProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The name of the process definition (fall backs to the process definition id if not available).
    /// </summary>
    [JsonPropertyName("processDefinitionName")]
    public string ProcessDefinitionName { get; set; } = null!;

}

/// <summary>
/// The process instance filter that defines which process instances should be canceled.
/// </summary>
public sealed class ProcessInstanceCancellationBatchOperationRequest
{
    /// <summary>
    /// The process instance filter.
    /// </summary>
    [JsonPropertyName("filter")]
    public ProcessInstanceFilter Filter { get; set; } = null!;

    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public OperationReference? OperationReference { get; set; }

}

/// <summary>
/// Instructions for creating a process instance. The process definition can be specified
/// either by id or by key.
/// 
/// </summary>
/// <remarks>
/// Use one of the following concrete types:
/// <list type="bullet">
/// <item><description><see cref="ProcessInstanceCreationInstructionById"/></description></item>
/// <item><description><see cref="ProcessInstanceCreationInstructionByKey"/></description></item>
/// </list>
/// </remarks>
/// <seealso cref="ProcessInstanceCreationInstructionById"/>
/// <seealso cref="ProcessInstanceCreationInstructionByKey"/>
[JsonDerivedType(typeof(ProcessInstanceCreationInstructionById))]
[JsonDerivedType(typeof(ProcessInstanceCreationInstructionByKey))]
public abstract class ProcessInstanceCreationInstruction { }

/// <summary>
/// ProcessInstanceCreationInstructionById
/// </summary>
public sealed class ProcessInstanceCreationInstructionById : ProcessInstanceCreationInstruction, global::Camunda.Orchestration.Sdk.Runtime.ITenantIdSettable
{
    /// <summary>
    /// The BPMN process id of the process definition to start an instance of.
    /// 
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId ProcessDefinitionId { get; set; }

    /// <summary>
    /// The version of the process. By default, the latest version of the process is used.
    /// 
    /// </summary>
    [JsonPropertyName("processDefinitionVersion")]
    public int? ProcessDefinitionVersion { get; set; }

    /// <summary>
    /// JSON object that will instantiate the variables for the root variable scope
    /// of the process instance.
    /// 
    /// </summary>
    [JsonPropertyName("variables")]
    public object? Variables { get; set; }

    /// <summary>
    /// The tenant id of the process definition.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public OperationReference? OperationReference { get; set; }

    /// <summary>
    /// List of start instructions. By default, the process instance will start at
    /// the start event. If provided, the process instance will apply start instructions
    /// after it has been created.
    /// 
    /// </summary>
    [JsonPropertyName("startInstructions")]
    public List<ProcessInstanceCreationStartInstruction>? StartInstructions { get; set; }

    /// <summary>
    /// Runtime instructions (alpha). List of instructions that affect the runtime behavior of
    /// the process instance. Refer to specific instruction types for more details.
    /// 
    /// This parameter is an alpha feature and may be subject to change
    /// in future releases.
    /// 
    /// </summary>
    [JsonPropertyName("runtimeInstructions")]
    public List<ProcessInstanceCreationRuntimeInstruction>? RuntimeInstructions { get; set; }

    /// <summary>
    /// Wait for the process instance to complete. If the process instance completion does
    /// not occur within the requestTimeout, the request will be closed. This can lead to a 504
    /// response status. Disabled by default.
    /// 
    /// </summary>
    [JsonPropertyName("awaitCompletion")]
    public bool? AwaitCompletion { get; set; }

    /// <summary>
    /// List of variables by name to be included in the response when awaitCompletion is set to true.
    /// If empty, all visible variables in the root scope will be returned.
    /// 
    /// </summary>
    [JsonPropertyName("fetchVariables")]
    public List<string>? FetchVariables { get; set; }

    /// <summary>
    /// Timeout (in ms) the request waits for the process to complete. By default or
    /// when set to 0, the generic request timeout configured in the cluster is applied.
    /// 
    /// </summary>
    [JsonPropertyName("requestTimeout")]
    public long? RequestTimeout { get; set; }

    /// <summary>
    /// List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
    /// </summary>
    [JsonPropertyName("tags")]
    public List<Tag>? Tags { get; set; }

    /// <inheritdoc />
    public void SetDefaultTenantId(string tenantId) { TenantId ??= global::Camunda.Orchestration.Sdk.Api.TenantId.AssumeExists(tenantId); }

}

/// <summary>
/// ProcessInstanceCreationInstructionByKey
/// </summary>
public sealed class ProcessInstanceCreationInstructionByKey : ProcessInstanceCreationInstruction, global::Camunda.Orchestration.Sdk.Runtime.ITenantIdSettable
{
    /// <summary>
    /// The unique key identifying the process definition, for example, returned for a process in the
    /// deploy resources endpoint.
    /// 
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey ProcessDefinitionKey { get; set; }

    /// <summary>
    /// As the version is already identified by the `processDefinitionKey`, the value of this field is ignored.
    /// It's here for backwards-compatibility only as previous releases accepted it in request bodies.
    /// 
    /// </summary>
    [JsonPropertyName("processDefinitionVersion")]
    public int? ProcessDefinitionVersion { get; set; }

    /// <summary>
    /// JSON object that will instantiate the variables for the root variable scope
    /// of the process instance.
    /// 
    /// </summary>
    [JsonPropertyName("variables")]
    public object? Variables { get; set; }

    /// <summary>
    /// List of start instructions. By default, the process instance will start at
    /// the start event. If provided, the process instance will apply start instructions
    /// after it has been created.
    /// 
    /// </summary>
    [JsonPropertyName("startInstructions")]
    public List<ProcessInstanceCreationStartInstruction>? StartInstructions { get; set; }

    /// <summary>
    /// Runtime instructions (alpha). List of instructions that affect the runtime behavior of
    /// the process instance. Refer to specific instruction types for more details.
    /// 
    /// This parameter is an alpha feature and may be subject to change
    /// in future releases.
    /// 
    /// </summary>
    [JsonPropertyName("runtimeInstructions")]
    public List<ProcessInstanceCreationRuntimeInstruction>? RuntimeInstructions { get; set; }

    /// <summary>
    /// The tenant id of the process definition.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public OperationReference? OperationReference { get; set; }

    /// <summary>
    /// Wait for the process instance to complete. If the process instance completion does
    /// not occur within the requestTimeout, the request will be closed. This can lead to a 504
    /// response status. Disabled by default.
    /// 
    /// </summary>
    [JsonPropertyName("awaitCompletion")]
    public bool? AwaitCompletion { get; set; }

    /// <summary>
    /// Timeout (in ms) the request waits for the process to complete. By default or
    /// when set to 0, the generic request timeout configured in the cluster is applied.
    /// 
    /// </summary>
    [JsonPropertyName("requestTimeout")]
    public long? RequestTimeout { get; set; }

    /// <summary>
    /// List of variables by name to be included in the response when awaitCompletion is set to true.
    /// If empty, all visible variables in the root scope will be returned.
    /// 
    /// </summary>
    [JsonPropertyName("fetchVariables")]
    public List<string>? FetchVariables { get; set; }

    /// <summary>
    /// List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
    /// </summary>
    [JsonPropertyName("tags")]
    public List<Tag>? Tags { get; set; }

    /// <inheritdoc />
    public void SetDefaultTenantId(string tenantId) { TenantId ??= global::Camunda.Orchestration.Sdk.Api.TenantId.AssumeExists(tenantId); }

}

/// <summary>
/// ProcessInstanceCreationRuntimeInstruction
/// </summary>
/// <remarks>
/// Use one of the following concrete types:
/// <list type="bullet">
/// <item><description><see cref="ProcessInstanceCreationTerminateInstruction"/></description></item>
/// </list>
/// </remarks>
/// <seealso cref="ProcessInstanceCreationTerminateInstruction"/>
[JsonDerivedType(typeof(ProcessInstanceCreationTerminateInstruction))]
public abstract class ProcessInstanceCreationRuntimeInstruction { }

/// <summary>
/// ProcessInstanceCreationStartInstruction
/// </summary>
public sealed class ProcessInstanceCreationStartInstruction
{
    /// <summary>
    /// Future extensions might include:
    ///   - different types of start instructions
    ///   - ability to set local variables for different flow scopes
    /// 
    /// For now, however, the start instruction is implicitly a "startBeforeElement" instruction
    /// 
    /// </summary>
    [JsonPropertyName("elementId")]
    public ElementId ElementId { get; set; }

}

/// <summary>
/// Terminates the process instance after a specific BPMN element is completed or terminated.
/// 
/// </summary>
public sealed class ProcessInstanceCreationTerminateInstruction : ProcessInstanceCreationRuntimeInstruction
{
    /// <summary>
    /// The type of the runtime instruction
    /// </summary>
    [JsonPropertyName("type")]
    public string? Type { get; set; }

    /// <summary>
    /// The id of the element that, once completed or terminated, will cause the process to be terminated.
    /// 
    /// </summary>
    [JsonPropertyName("afterElementId")]
    public ElementId AfterElementId { get; set; }

}

/// <summary>
/// The process instance filter that defines which process instances should be deleted.
/// </summary>
public sealed class ProcessInstanceDeletionBatchOperationRequest
{
    /// <summary>
    /// The process instance filter.
    /// </summary>
    [JsonPropertyName("filter")]
    public ProcessInstanceFilter Filter { get; set; } = null!;

    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public OperationReference? OperationReference { get; set; }

}

/// <summary>
/// Process instance element statistics query response.
/// </summary>
public sealed class ProcessInstanceElementStatisticsQueryResult
{
    /// <summary>
    /// The element statistics.
    /// </summary>
    [JsonPropertyName("items")]
    public List<ProcessElementStatisticsResult>? Items { get; set; }

}

/// <summary>
/// Process instance search filter.
/// </summary>
public sealed class ProcessInstanceFilter
{
    /// <summary>
    /// The process definition id.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public StringFilterProperty? ProcessDefinitionId { get; set; }

    /// <summary>
    /// The process definition name.
    /// </summary>
    [JsonPropertyName("processDefinitionName")]
    public StringFilterProperty? ProcessDefinitionName { get; set; }

    /// <summary>
    /// The process definition version.
    /// </summary>
    [JsonPropertyName("processDefinitionVersion")]
    public IntegerFilterProperty? ProcessDefinitionVersion { get; set; }

    /// <summary>
    /// The process definition version tag.
    /// </summary>
    [JsonPropertyName("processDefinitionVersionTag")]
    public StringFilterProperty? ProcessDefinitionVersionTag { get; set; }

    /// <summary>
    /// The process definition key.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKeyFilterProperty? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// Defines a list of alternative filter groups combined using OR logic. Each object in the array is evaluated independently, and the filter matches if any one of them is satisfied.
    /// 
    /// Top-level fields and the `$or` clause are combined using AND logic â€” meaning: (top-level filters) AND (any of the `$or` filters) must match.
    /// &lt;br&gt;
    /// &lt;em&gt;Example:&lt;/em&gt;
    /// 
    /// ```json
    /// {
    ///   "state": "ACTIVE",
    ///   "tenantId": 123,
    ///   "$or": [
    ///     { "processDefinitionId": "process_v1" },
    ///     { "processDefinitionId": "process_v2", "hasIncident": true }
    ///   ]
    /// }
    /// ```
    /// This matches process instances that:
    /// 
    /// &lt;ul style="padding-left: 20px; margin-left: 20px;"&gt;
    ///   &lt;li style="list-style-type: disc;"&gt;are in &lt;em&gt;ACTIVE&lt;/em&gt; state&lt;/li&gt;
    ///   &lt;li style="list-style-type: disc;"&gt;have tenant id equal to &lt;em&gt;123&lt;/em&gt;&lt;/li&gt;
    ///   &lt;li style="list-style-type: disc;"&gt;and match either:
    ///     &lt;ul style="padding-left: 20px; margin-left: 20px;"&gt;
    ///       &lt;li style="list-style-type: circle;"&gt;&lt;code&gt;processDefinitionId&lt;/code&gt; is &lt;em&gt;process_v1&lt;/em&gt;, or&lt;/li&gt;
    ///       &lt;li style="list-style-type: circle;"&gt;&lt;code&gt;processDefinitionId&lt;/code&gt; is &lt;em&gt;process_v2&lt;/em&gt; and &lt;code&gt;hasIncident&lt;/code&gt; is &lt;em&gt;true&lt;/em&gt;&lt;/li&gt;
    ///     &lt;/ul&gt;
    ///   &lt;/li&gt;
    /// &lt;/ul&gt;
    /// &lt;br&gt;
    /// &lt;p&gt;Note: Using complex &lt;code&gt;$or&lt;/code&gt; conditions may impact performance, use with caution in high-volume environments.
    /// 
    /// </summary>
    [JsonPropertyName("$or")]
    public List<ProcessInstanceFilterFields>? Or { get; set; }

}

/// <summary>
/// Process instance search filter.
/// </summary>
public sealed class ProcessInstanceFilterFields
{
    /// <summary>
    /// The process definition id.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public StringFilterProperty? ProcessDefinitionId { get; set; }

    /// <summary>
    /// The process definition name.
    /// </summary>
    [JsonPropertyName("processDefinitionName")]
    public StringFilterProperty? ProcessDefinitionName { get; set; }

    /// <summary>
    /// The process definition version.
    /// </summary>
    [JsonPropertyName("processDefinitionVersion")]
    public IntegerFilterProperty? ProcessDefinitionVersion { get; set; }

    /// <summary>
    /// The process definition version tag.
    /// </summary>
    [JsonPropertyName("processDefinitionVersionTag")]
    public StringFilterProperty? ProcessDefinitionVersionTag { get; set; }

    /// <summary>
    /// The process definition key.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKeyFilterProperty? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The start date.
    /// </summary>
    [JsonPropertyName("startDate")]
    public DateTimeFilterProperty? StartDate { get; set; }

    /// <summary>
    /// The end date.
    /// </summary>
    [JsonPropertyName("endDate")]
    public DateTimeFilterProperty? EndDate { get; set; }

    /// <summary>
    /// The process instance state.
    /// </summary>
    [JsonPropertyName("state")]
    public ProcessInstanceStateFilterProperty? State { get; set; }

    /// <summary>
    /// Whether this process instance has a related incident or not.
    /// </summary>
    [JsonPropertyName("hasIncident")]
    public bool? HasIncident { get; set; }

    /// <summary>
    /// The tenant id.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public StringFilterProperty? TenantId { get; set; }

    /// <summary>
    /// The process instance variables.
    /// </summary>
    [JsonPropertyName("variables")]
    public List<VariableValueFilterProperty>? Variables { get; set; }

    /// <summary>
    /// The key of this process instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKeyFilterProperty? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The parent process instance key.
    /// </summary>
    [JsonPropertyName("parentProcessInstanceKey")]
    public ProcessInstanceKeyFilterProperty? ParentProcessInstanceKey { get; set; }

    /// <summary>
    /// The parent element instance key.
    /// </summary>
    [JsonPropertyName("parentElementInstanceKey")]
    public ElementInstanceKeyFilterProperty? ParentElementInstanceKey { get; set; }

    /// <summary>
    /// The batch operation id.
    /// </summary>
    [JsonPropertyName("batchOperationId")]
    public StringFilterProperty? BatchOperationId { get; set; }

    /// <summary>
    /// The error message related to the process.
    /// </summary>
    [JsonPropertyName("errorMessage")]
    public StringFilterProperty? ErrorMessage { get; set; }

    /// <summary>
    /// Whether the process has failed jobs with retries left.
    /// </summary>
    [JsonPropertyName("hasRetriesLeft")]
    public bool? HasRetriesLeft { get; set; }

    /// <summary>
    /// The state of the element instances associated with the process instance.
    /// </summary>
    [JsonPropertyName("elementInstanceState")]
    public ElementInstanceStateFilterProperty? ElementInstanceState { get; set; }

    /// <summary>
    /// The element id associated with the process instance.
    /// </summary>
    [JsonPropertyName("elementId")]
    public StringFilterProperty? ElementId { get; set; }

    /// <summary>
    /// Whether the element instance has an incident or not.
    /// </summary>
    [JsonPropertyName("hasElementInstanceIncident")]
    public bool? HasElementInstanceIncident { get; set; }

    /// <summary>
    /// The incident error hash code, associated with this process.
    /// </summary>
    [JsonPropertyName("incidentErrorHashCode")]
    public IntegerFilterProperty? IncidentErrorHashCode { get; set; }

    /// <summary>
    /// List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
    /// </summary>
    [JsonPropertyName("tags")]
    public List<Tag>? Tags { get; set; }

}

/// <summary>
/// The process instance filter that defines which process instances should have their incidents resolved.
/// </summary>
public sealed class ProcessInstanceIncidentResolutionBatchOperationRequest
{
    /// <summary>
    /// The process instance filter.
    /// </summary>
    [JsonPropertyName("filter")]
    public ProcessInstanceFilter Filter { get; set; } = null!;

    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public OperationReference? OperationReference { get; set; }

}

/// <summary>
/// System-generated key for a process instance.
/// </summary>
public readonly record struct ProcessInstanceKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private ProcessInstanceKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="ProcessInstanceKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static ProcessInstanceKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "ProcessInstanceKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new ProcessInstanceKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct ProcessInstanceKeyExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private ProcessInstanceKeyExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="ProcessInstanceKeyExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static ProcessInstanceKeyExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "ProcessInstanceKeyExactMatch");
        return new ProcessInstanceKeyExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// ProcessInstanceKey property with full advanced search capabilities.
/// </summary>
public sealed class ProcessInstanceKeyFilterProperty
{
}

/// <summary>
/// The migration instructions describe how to migrate a process instance from one process definition to another.
/// 
/// </summary>
public sealed class ProcessInstanceMigrationBatchOperationPlan
{
    /// <summary>
    /// The target process definition key.
    /// </summary>
    [JsonPropertyName("targetProcessDefinitionKey")]
    public ProcessDefinitionKey TargetProcessDefinitionKey { get; set; }

    /// <summary>
    /// The mapping instructions.
    /// </summary>
    [JsonPropertyName("mappingInstructions")]
    public List<MigrateProcessInstanceMappingInstruction> MappingInstructions { get; set; } = null!;

}

/// <summary>
/// ProcessInstanceMigrationBatchOperationRequest
/// </summary>
public sealed class ProcessInstanceMigrationBatchOperationRequest
{
    /// <summary>
    /// The process instance filter.
    /// </summary>
    [JsonPropertyName("filter")]
    public ProcessInstanceFilter Filter { get; set; } = null!;

    /// <summary>
    /// The migration plan.
    /// </summary>
    [JsonPropertyName("migrationPlan")]
    public ProcessInstanceMigrationBatchOperationPlan MigrationPlan { get; set; } = null!;

    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public OperationReference? OperationReference { get; set; }

}

/// <summary>
/// The migration instructions describe how to migrate a process instance from one process definition to another.
/// 
/// </summary>
public sealed class ProcessInstanceMigrationInstruction
{
    /// <summary>
    /// The key of process definition to migrate the process instance to.
    /// </summary>
    [JsonPropertyName("targetProcessDefinitionKey")]
    public ProcessDefinitionKey TargetProcessDefinitionKey { get; set; }

    /// <summary>
    /// Element mappings from the source process instance to the target process instance.
    /// </summary>
    [JsonPropertyName("mappingInstructions")]
    public List<MigrateProcessInstanceMappingInstruction> MappingInstructions { get; set; } = null!;

    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public OperationReference? OperationReference { get; set; }

}

/// <summary>
/// Instruction describing an element to activate.
/// </summary>
public sealed class ProcessInstanceModificationActivateInstruction
{
    /// <summary>
    /// The id of the element to activate.
    /// </summary>
    [JsonPropertyName("elementId")]
    public ElementId ElementId { get; set; }

    /// <summary>
    /// Instructions describing which variables to create or update.
    /// </summary>
    [JsonPropertyName("variableInstructions")]
    public List<ModifyProcessInstanceVariableInstruction>? VariableInstructions { get; set; }

    /// <summary>
    /// The key of the ancestor scope the element instance should be created in.
    /// Set to -1 to create the new element instance within an existing element instance of the
    /// flow scope. If multiple instances of the target element's flow scope exist, choose one
    /// specifically with this property by providing its key.
    /// 
    /// </summary>
    [JsonPropertyName("ancestorElementInstanceKey")]
    public object? AncestorElementInstanceKey { get; set; }

}

/// <summary>
/// The process instance filter to define on which process instances tokens should be moved,
/// and new element instances should be activated or terminated.
/// 
/// </summary>
public sealed class ProcessInstanceModificationBatchOperationRequest
{
    /// <summary>
    /// The process instance filter.
    /// </summary>
    [JsonPropertyName("filter")]
    public ProcessInstanceFilter Filter { get; set; } = null!;

    /// <summary>
    /// Instructions for moving tokens between elements.
    /// </summary>
    [JsonPropertyName("moveInstructions")]
    public List<ProcessInstanceModificationMoveBatchOperationInstruction> MoveInstructions { get; set; } = null!;

    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public OperationReference? OperationReference { get; set; }

}

/// <summary>
/// ProcessInstanceModificationInstruction
/// </summary>
public sealed class ProcessInstanceModificationInstruction
{
    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public OperationReference? OperationReference { get; set; }

    /// <summary>
    /// Instructions describing which elements to activate in which scopes and which variables to create or update.
    /// </summary>
    [JsonPropertyName("activateInstructions")]
    public List<ProcessInstanceModificationActivateInstruction>? ActivateInstructions { get; set; }

    /// <summary>
    /// Instructions describing which elements to move from one scope to another.
    /// </summary>
    [JsonPropertyName("moveInstructions")]
    public List<ProcessInstanceModificationMoveInstruction>? MoveInstructions { get; set; }

    /// <summary>
    /// Instructions describing which elements to terminate.
    /// </summary>
    [JsonPropertyName("terminateInstructions")]
    public List<ProcessInstanceModificationTerminateInstruction>? TerminateInstructions { get; set; }

}

/// <summary>
/// Instructions describing a move operation. This instruction will terminate all active
/// element instances at `sourceElementId` and activate a new element instance for each
/// terminated one at `targetElementId`. The new element instances are created in the parent
/// scope of the source element instances.
/// 
/// </summary>
public sealed class ProcessInstanceModificationMoveBatchOperationInstruction
{
    /// <summary>
    /// The source element ID.
    /// </summary>
    [JsonPropertyName("sourceElementId")]
    public ElementId SourceElementId { get; set; }

    /// <summary>
    /// The target element ID.
    /// </summary>
    [JsonPropertyName("targetElementId")]
    public ElementId TargetElementId { get; set; }

}

/// <summary>
/// Instruction describing a move operation. This instruction will terminate active element
/// instances based on the sourceElementInstruction and activate a new element instance for each terminated
/// one at targetElementId. Note that, for multi-instance activities, only the multi-instance
/// body instances will activate new element instances at the target id.
/// 
/// </summary>
public sealed class ProcessInstanceModificationMoveInstruction
{
    /// <summary>
    /// Defines the source element identifier for the move instruction. It can either be a sourceElementId, or sourceElementInstanceKey.
    /// 
    /// </summary>
    [JsonPropertyName("sourceElementInstruction")]
    public SourceElementInstruction SourceElementInstruction { get; set; } = null!;

    /// <summary>
    /// The target element id.
    /// </summary>
    [JsonPropertyName("targetElementId")]
    public ElementId TargetElementId { get; set; }

    /// <summary>
    /// Defines the ancestor scope for the created element instances. The default behavior resembles
    /// a "direct" scope instruction with an `ancestorElementInstanceKey` of `"-1"`.
    /// 
    /// </summary>
    [JsonPropertyName("ancestorScopeInstruction")]
    public AncestorScopeInstruction? AncestorScopeInstruction { get; set; }

    /// <summary>
    /// Instructions describing which variables to create or update.
    /// </summary>
    [JsonPropertyName("variableInstructions")]
    public List<ModifyProcessInstanceVariableInstruction>? VariableInstructions { get; set; }

}

/// <summary>
/// Instruction describing which elements to terminate. The element instances are determined
/// at runtime by the given id.
/// 
/// </summary>
public sealed class ProcessInstanceModificationTerminateByIdInstruction : ProcessInstanceModificationTerminateInstruction
{
    /// <summary>
    /// The id of the elements to terminate. The element instances are determined at runtime.
    /// </summary>
    [JsonPropertyName("elementId")]
    public ElementId ElementId { get; set; }

}

/// <summary>
/// Instruction providing the key of the element instance to terminate.
/// </summary>
public sealed class ProcessInstanceModificationTerminateByKeyInstruction : ProcessInstanceModificationTerminateInstruction
{
    /// <summary>
    /// The key of the element instance to terminate.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKey ElementInstanceKey { get; set; }

}

/// <summary>
/// Instruction describing which elements to terminate.
/// </summary>
/// <remarks>
/// Use one of the following concrete types:
/// <list type="bullet">
/// <item><description><see cref="ProcessInstanceModificationTerminateByIdInstruction"/></description></item>
/// <item><description><see cref="ProcessInstanceModificationTerminateByKeyInstruction"/></description></item>
/// </list>
/// </remarks>
/// <seealso cref="ProcessInstanceModificationTerminateByIdInstruction"/>
/// <seealso cref="ProcessInstanceModificationTerminateByKeyInstruction"/>
[JsonDerivedType(typeof(ProcessInstanceModificationTerminateByIdInstruction))]
[JsonDerivedType(typeof(ProcessInstanceModificationTerminateByKeyInstruction))]
public abstract class ProcessInstanceModificationTerminateInstruction { }

/// <summary>
/// ProcessInstanceReference
/// </summary>
public sealed class ProcessInstanceReference
{
    /// <summary>
    /// The key of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The key of the created process instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

}

/// <summary>
/// Process instance search response item.
/// </summary>
public sealed class ProcessInstanceResult
{
    /// <summary>
    /// Id of a process definition, from the model. Only ids of process definitions that are deployed are useful.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId ProcessDefinitionId { get; set; }

    /// <summary>
    /// The process definition name.
    /// </summary>
    [JsonPropertyName("processDefinitionName")]
    public string ProcessDefinitionName { get; set; } = null!;

    [JsonPropertyName("processDefinitionVersion")]
    public int ProcessDefinitionVersion { get; set; }

    /// <summary>
    /// The process definition version tag.
    /// </summary>
    [JsonPropertyName("processDefinitionVersionTag")]
    public string? ProcessDefinitionVersionTag { get; set; }

    [JsonPropertyName("startDate")]
    public DateTimeOffset StartDate { get; set; }

    [JsonPropertyName("endDate")]
    public DateTimeOffset? EndDate { get; set; }

    /// <summary>
    /// Process instance states
    /// </summary>
    [JsonPropertyName("state")]
    public ProcessInstanceStateEnum State { get; set; }

    /// <summary>
    /// Whether this process instance has a related incident or not.
    /// </summary>
    [JsonPropertyName("hasIncident")]
    public bool HasIncident { get; set; }

    /// <summary>
    /// The unique identifier of the tenant.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId TenantId { get; set; }

    /// <summary>
    /// The key of this process instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey ProcessInstanceKey { get; set; }

    /// <summary>
    /// The process definition key.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The parent process instance key.
    /// </summary>
    [JsonPropertyName("parentProcessInstanceKey")]
    public ProcessInstanceKey? ParentProcessInstanceKey { get; set; }

    /// <summary>
    /// The parent element instance key.
    /// </summary>
    [JsonPropertyName("parentElementInstanceKey")]
    public ElementInstanceKey? ParentElementInstanceKey { get; set; }

    /// <summary>
    /// The key of the root process instance. The root process instance is the top-level
    /// ancestor in the process instance hierarchy. This field is only present for data
    /// belonging to process instance hierarchies created in version 8.9 or later.
    /// 
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public RootProcessInstanceKey? RootProcessInstanceKey { get; set; }

    /// <summary>
    /// List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
    /// </summary>
    [JsonPropertyName("tags")]
    public List<Tag>? Tags { get; set; }

}

/// <summary>
/// Process instance search request.
/// </summary>
public sealed class ProcessInstanceSearchQuery
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<ProcessInstanceSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The process instance search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public ProcessInstanceFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// Process instance search response.
/// </summary>
public sealed class ProcessInstanceSearchQueryResult
{
    /// <summary>
    /// The matching process instances.
    /// </summary>
    [JsonPropertyName("items")]
    public List<ProcessInstanceResult> Items { get; set; } = null!;

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// ProcessInstanceSearchQuerySortRequest
/// </summary>
public sealed class ProcessInstanceSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// Process instance sequence flow result.
/// </summary>
public sealed class ProcessInstanceSequenceFlowResult
{
    /// <summary>
    /// The sequence flow id.
    /// </summary>
    [JsonPropertyName("sequenceFlowId")]
    public string? SequenceFlowId { get; set; }

    /// <summary>
    /// The key of this process instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the root process instance. The root process instance is the top-level
    /// ancestor in the process instance hierarchy. This field is only present for data
    /// belonging to process instance hierarchies created in version 8.9 or later.
    /// 
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public RootProcessInstanceKey? RootProcessInstanceKey { get; set; }

    /// <summary>
    /// The process definition key.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The process definition id.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId? ProcessDefinitionId { get; set; }

    /// <summary>
    /// The element id for this sequence flow, as provided in the BPMN process.
    /// </summary>
    [JsonPropertyName("elementId")]
    public ElementId? ElementId { get; set; }

    /// <summary>
    /// The unique identifier of the tenant.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

}

/// <summary>
/// Process instance sequence flows query response.
/// </summary>
public sealed class ProcessInstanceSequenceFlowsQueryResult
{
    /// <summary>
    /// The sequence flows.
    /// </summary>
    [JsonPropertyName("items")]
    public List<ProcessInstanceSequenceFlowResult>? Items { get; set; }

}

/// <summary>
/// Process instance states
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum ProcessInstanceStateEnum
{
    [JsonPropertyName("ACTIVE")]
    ACTIVE,
    [JsonPropertyName("COMPLETED")]
    COMPLETED,
    [JsonPropertyName("TERMINATED")]
    TERMINATED,
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct ProcessInstanceStateExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private ProcessInstanceStateExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="ProcessInstanceStateExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static ProcessInstanceStateExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "ProcessInstanceStateExactMatch");
        return new ProcessInstanceStateExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// ProcessInstanceStateEnum property with full advanced search capabilities.
/// </summary>
public sealed class ProcessInstanceStateFilterProperty
{
}

/// <summary>
/// The system-assigned key for this resource.
/// </summary>
public readonly record struct ResourceKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private ResourceKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="ResourceKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static ResourceKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "ResourceKey");
        return new ResourceKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct ResourceKeyExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private ResourceKeyExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="ResourceKeyExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static ResourceKeyExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "ResourceKeyExactMatch");
        return new ResourceKeyExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// ResourceKey property with full advanced search capabilities.
/// </summary>
public sealed class ResourceKeyFilterProperty
{
}

/// <summary>
/// ResourceResult
/// </summary>
public sealed class ResourceResult
{
    /// <summary>
    /// The resource name from which this resource was parsed.
    /// </summary>
    [JsonPropertyName("resourceName")]
    public string? ResourceName { get; set; }

    /// <summary>
    /// The assigned resource version.
    /// </summary>
    [JsonPropertyName("version")]
    public int? Version { get; set; }

    /// <summary>
    /// The version tag of this resource.
    /// </summary>
    [JsonPropertyName("versionTag")]
    public string? VersionTag { get; set; }

    /// <summary>
    /// The resource ID of this resource.
    /// </summary>
    [JsonPropertyName("resourceId")]
    public string? ResourceId { get; set; }

    /// <summary>
    /// The tenant ID of this resource.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The unique key of this resource.
    /// </summary>
    [JsonPropertyName("resourceKey")]
    public ResourceKey? ResourceKey { get; set; }

}

/// <summary>
/// The type of resource to add/remove permissions to/from.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum ResourceTypeEnum
{
    [JsonPropertyName("AUDIT_LOG")]
    AUDITLOG,
    [JsonPropertyName("AUTHORIZATION")]
    AUTHORIZATION,
    [JsonPropertyName("BATCH")]
    BATCH,
    [JsonPropertyName("CLUSTER_VARIABLE")]
    CLUSTERVARIABLE,
    [JsonPropertyName("COMPONENT")]
    COMPONENT,
    [JsonPropertyName("DECISION_DEFINITION")]
    DECISIONDEFINITION,
    [JsonPropertyName("DECISION_REQUIREMENTS_DEFINITION")]
    DECISIONREQUIREMENTSDEFINITION,
    [JsonPropertyName("DOCUMENT")]
    DOCUMENT,
    [JsonPropertyName("EXPRESSION")]
    EXPRESSION,
    [JsonPropertyName("GLOBAL_LISTENER")]
    GLOBALLISTENER,
    [JsonPropertyName("GROUP")]
    GROUP,
    [JsonPropertyName("MAPPING_RULE")]
    MAPPINGRULE,
    [JsonPropertyName("MESSAGE")]
    MESSAGE,
    [JsonPropertyName("PROCESS_DEFINITION")]
    PROCESSDEFINITION,
    [JsonPropertyName("RESOURCE")]
    RESOURCE,
    [JsonPropertyName("ROLE")]
    ROLE,
    [JsonPropertyName("SYSTEM")]
    SYSTEM,
    [JsonPropertyName("TENANT")]
    TENANT,
    [JsonPropertyName("USER")]
    USER,
    [JsonPropertyName("USER_TASK")]
    USERTASK,
}

/// <summary>
/// RoleClientResult
/// </summary>
public sealed class RoleClientResult
{
    /// <summary>
    /// The ID of the client.
    /// </summary>
    [JsonPropertyName("clientId")]
    public string? ClientId { get; set; }

}

/// <summary>
/// RoleClientSearchQueryRequest
/// </summary>
public sealed class RoleClientSearchQueryRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<RoleClientSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// RoleClientSearchQuerySortRequest
/// </summary>
public sealed class RoleClientSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// RoleClientSearchResult
/// </summary>
public sealed class RoleClientSearchResult
{
    /// <summary>
    /// The matching clients.
    /// </summary>
    [JsonPropertyName("items")]
    public List<RoleClientResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// RoleCreateRequest
/// </summary>
public sealed class RoleCreateRequest
{
    /// <summary>
    /// The ID of the new role.
    /// </summary>
    [JsonPropertyName("roleId")]
    public string RoleId { get; set; } = null!;

    /// <summary>
    /// The display name of the new role.
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; } = null!;

    /// <summary>
    /// The description of the new role.
    /// </summary>
    [JsonPropertyName("description")]
    public string? Description { get; set; }

}

/// <summary>
/// RoleCreateResult
/// </summary>
public sealed class RoleCreateResult
{
    /// <summary>
    /// The ID of the created role.
    /// </summary>
    [JsonPropertyName("roleId")]
    public string? RoleId { get; set; }

    /// <summary>
    /// The display name of the created role.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The description of the created role.
    /// </summary>
    [JsonPropertyName("description")]
    public string? Description { get; set; }

}

/// <summary>
/// Role filter request
/// </summary>
public sealed class RoleFilter
{
    /// <summary>
    /// The role ID search filters.
    /// </summary>
    [JsonPropertyName("roleId")]
    public string? RoleId { get; set; }

    /// <summary>
    /// The role name search filters.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

}

/// <summary>
/// RoleGroupResult
/// </summary>
public sealed class RoleGroupResult
{
    /// <summary>
    /// The id of the group.
    /// </summary>
    [JsonPropertyName("groupId")]
    public string? GroupId { get; set; }

}

/// <summary>
/// RoleGroupSearchQueryRequest
/// </summary>
public sealed class RoleGroupSearchQueryRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<RoleGroupSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// RoleGroupSearchQuerySortRequest
/// </summary>
public sealed class RoleGroupSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// RoleGroupSearchResult
/// </summary>
public sealed class RoleGroupSearchResult
{
    /// <summary>
    /// The matching groups.
    /// </summary>
    [JsonPropertyName("items")]
    public List<RoleGroupResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// Role search response item.
/// </summary>
public sealed class RoleResult
{
    /// <summary>
    /// The role name.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The role id.
    /// </summary>
    [JsonPropertyName("roleId")]
    public string? RoleId { get; set; }

    /// <summary>
    /// The description of the role.
    /// </summary>
    [JsonPropertyName("description")]
    public string? Description { get; set; }

}

/// <summary>
/// Role search request.
/// </summary>
public sealed class RoleSearchQueryRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<RoleSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The role search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public RoleFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// Role search response.
/// </summary>
public sealed class RoleSearchQueryResult
{
    /// <summary>
    /// The matching roles.
    /// </summary>
    [JsonPropertyName("items")]
    public List<RoleResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// RoleSearchQuerySortRequest
/// </summary>
public sealed class RoleSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// RoleUpdateRequest
/// </summary>
public sealed class RoleUpdateRequest
{
    /// <summary>
    /// The display name of the new role.
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; } = null!;

    /// <summary>
    /// The description of the new role.
    /// </summary>
    [JsonPropertyName("description")]
    public string? Description { get; set; }

}

/// <summary>
/// RoleUpdateResult
/// </summary>
public sealed class RoleUpdateResult
{
    /// <summary>
    /// The display name of the updated role.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The description of the updated role.
    /// </summary>
    [JsonPropertyName("description")]
    public string? Description { get; set; }

    /// <summary>
    /// The ID of the updated role.
    /// </summary>
    [JsonPropertyName("roleId")]
    public string? RoleId { get; set; }

}

/// <summary>
/// RoleUserResult
/// </summary>
public sealed class RoleUserResult
{
    /// <summary>
    /// The unique name of a user.
    /// </summary>
    [JsonPropertyName("username")]
    public Username? Username { get; set; }

}

/// <summary>
/// RoleUserSearchQueryRequest
/// </summary>
public sealed class RoleUserSearchQueryRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<RoleUserSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// RoleUserSearchQuerySortRequest
/// </summary>
public sealed class RoleUserSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// RoleUserSearchResult
/// </summary>
public sealed class RoleUserSearchResult
{
    /// <summary>
    /// The matching users.
    /// </summary>
    [JsonPropertyName("items")]
    public List<RoleUserResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// The key of the root process instance. The root process instance is the top-level
/// ancestor in the process instance hierarchy. This field is only present for data
/// belonging to process instance hierarchies created in version 8.9 or later.
/// 
/// </summary>
public readonly record struct RootProcessInstanceKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private RootProcessInstanceKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="RootProcessInstanceKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static RootProcessInstanceKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "RootProcessInstanceKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new RootProcessInstanceKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// System-generated key for a scope.
/// </summary>
public readonly record struct ScopeKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private ScopeKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="ScopeKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static ScopeKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "ScopeKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new ScopeKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct ScopeKeyExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private ScopeKeyExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="ScopeKeyExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static ScopeKeyExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "ScopeKeyExactMatch");
        return new ScopeKeyExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// ScopeKey property with full advanced search capabilities.
/// </summary>
public sealed class ScopeKeyFilterProperty
{
}

/// <summary>
/// Pagination criteria. Can use offset-based pagination (from/limit) OR cursor-based pagination (after/before + limit), but not both.
/// </summary>
/// <remarks>
/// Use one of the following concrete types:
/// <list type="bullet">
/// <item><description><see cref="LimitPagination"/></description></item>
/// <item><description><see cref="OffsetPagination"/></description></item>
/// <item><description><see cref="CursorForwardPagination"/></description></item>
/// <item><description><see cref="CursorBackwardPagination"/></description></item>
/// </list>
/// </remarks>
/// <seealso cref="LimitPagination"/>
/// <seealso cref="OffsetPagination"/>
/// <seealso cref="CursorForwardPagination"/>
/// <seealso cref="CursorBackwardPagination"/>
[JsonDerivedType(typeof(LimitPagination))]
[JsonDerivedType(typeof(OffsetPagination))]
[JsonDerivedType(typeof(CursorForwardPagination))]
[JsonDerivedType(typeof(CursorBackwardPagination))]
public abstract class SearchQueryPageRequest { }

/// <summary>
/// Pagination information about the search results.
/// </summary>
public sealed class SearchQueryPageResponse
{
    /// <summary>
    /// Total items matching the criteria.
    /// </summary>
    [JsonPropertyName("totalItems")]
    public long TotalItems { get; set; }

    /// <summary>
    /// Indicates whether there are more items matching the criteria beyond the returned items.
    /// This is useful for determining if additional requests are needed to retrieve all results.
    /// 
    /// </summary>
    [JsonPropertyName("hasMoreTotalItems")]
    public bool? HasMoreTotalItems { get; set; }

    /// <summary>
    /// The cursor value for getting the previous page of results. Use this in the `before` field of an ensuing request.
    /// </summary>
    [JsonPropertyName("startCursor")]
    public StartCursor? StartCursor { get; set; }

    /// <summary>
    /// The cursor value for getting the next page of results. Use this in the `after` field of an ensuing request.
    /// </summary>
    [JsonPropertyName("endCursor")]
    public EndCursor? EndCursor { get; set; }

}

/// <summary>
/// SearchQueryRequest
/// </summary>
public sealed class SearchQueryRequest
{
    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// SearchQueryResponse
/// </summary>
public sealed class SearchQueryResponse
{
    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// SetVariableRequest
/// </summary>
public sealed class SetVariableRequest
{
    /// <summary>
    /// JSON object representing the variables to set in the elementâ€™s scope.
    /// </summary>
    [JsonPropertyName("variables")]
    public object Variables { get; set; } = null!;

    /// <summary>
    /// If set to true, the variables are merged strictly into the local scope (as specified by the `elementInstanceKey`).
    /// Otherwise, the variables are propagated to upper scopes and set at the outermost one.
    /// Letâ€™s consider the following example:
    /// There are two scopes '1' and '2'.
    /// Scope '1' is the parent scope of '2'. The effective variables of the scopes are:
    /// 1 =&gt; { "foo" : 2 }
    /// 2 =&gt; { "bar" : 1 }
    /// An update request with elementInstanceKey as '2', variables { "foo" : 5 }, and local set
    /// to true leaves scope '1' unchanged and adjusts scope '2' to { "bar" : 1, "foo" 5 }.
    /// By default, with local set to false, scope '1' will be { "foo": 5 }
    /// and scope '2' will be { "bar" : 1 }.
    /// 
    /// </summary>
    [JsonPropertyName("local")]
    public bool? Local { get; set; }

    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public OperationReference? OperationReference { get; set; }

}

/// <summary>
/// SignalBroadcastRequest
/// </summary>
public sealed class SignalBroadcastRequest : global::Camunda.Orchestration.Sdk.Runtime.ITenantIdSettable
{
    /// <summary>
    /// The name of the signal to broadcast.
    /// </summary>
    [JsonPropertyName("signalName")]
    public string SignalName { get; set; } = null!;

    /// <summary>
    /// The signal variables as a JSON object.
    /// </summary>
    [JsonPropertyName("variables")]
    public object? Variables { get; set; }

    /// <summary>
    /// The ID of the tenant that owns the signal.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <inheritdoc />
    public void SetDefaultTenantId(string tenantId) { TenantId ??= global::Camunda.Orchestration.Sdk.Api.TenantId.AssumeExists(tenantId); }

}

/// <summary>
/// SignalBroadcastResult
/// </summary>
public sealed class SignalBroadcastResult
{
    /// <summary>
    /// The tenant ID of the signal that was broadcast.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId TenantId { get; set; }

    /// <summary>
    /// The key of the broadcasted signal.
    /// </summary>
    [JsonPropertyName("signalKey")]
    public SignalKey SignalKey { get; set; }

}

/// <summary>
/// System-generated key for an signal.
/// </summary>
public readonly record struct SignalKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private SignalKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="SignalKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static SignalKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "SignalKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new SignalKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// The order in which to sort the related field.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum SortOrderEnum
{
    [JsonPropertyName("ASC")]
    ASC,
    [JsonPropertyName("DESC")]
    DESC,
}

/// <summary>
/// Defines an instruction with a sourceElementId. The move instruction with this sourceType will terminate all active element
/// instances with the sourceElementId and activate a new element instance for each terminated
/// one at targetElementId.
/// 
/// </summary>
public sealed class SourceElementIdInstruction : SourceElementInstruction
{
    /// <summary>
    /// The type of source element instruction.
    /// </summary>
    [JsonPropertyName("sourceType")]
    public string SourceType { get; set; } = null!;

    /// <summary>
    /// The id of the source element for the move instruction.
    /// 
    /// </summary>
    [JsonPropertyName("sourceElementId")]
    public ElementId SourceElementId { get; set; }

}

/// <summary>
/// Defines an instruction with a sourceElementInstanceKey. The move instruction with this sourceType will terminate one active element
/// instance with the sourceElementInstanceKey and activate a new element instance at targetElementId.
/// 
/// </summary>
public sealed class SourceElementInstanceKeyInstruction : SourceElementInstruction
{
    /// <summary>
    /// The type of source element instruction.
    /// </summary>
    [JsonPropertyName("sourceType")]
    public string SourceType { get; set; } = null!;

    /// <summary>
    /// The source element instance key for the move instruction.
    /// 
    /// </summary>
    [JsonPropertyName("sourceElementInstanceKey")]
    public ElementInstanceKey SourceElementInstanceKey { get; set; }

}

/// <summary>
/// Defines the source element identifier for the move instruction. It can either be a sourceElementId, or sourceElementInstanceKey.
/// 
/// </summary>
/// <remarks>
/// Use one of the following concrete types:
/// <list type="bullet">
/// <item><description><see cref="SourceElementIdInstruction"/></description></item>
/// <item><description><see cref="SourceElementInstanceKeyInstruction"/></description></item>
/// </list>
/// </remarks>
/// <seealso cref="SourceElementIdInstruction"/>
/// <seealso cref="SourceElementInstanceKeyInstruction"/>
[JsonDerivedType(typeof(SourceElementIdInstruction))]
[JsonDerivedType(typeof(SourceElementInstanceKeyInstruction))]
public abstract class SourceElementInstruction { }

/// <summary>
/// The start cursor in a search query result set.
/// </summary>
public readonly record struct StartCursor : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private StartCursor(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="StartCursor"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static StartCursor AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "StartCursor", pattern: @"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}=)?$", minLength: 2, maxLength: 300);
        return new StartCursor(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}(?:==)?|[A-Za-z0-9+/]{3}=)?$", minLength: 2, maxLength: 300);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Metric for a single job status.
/// </summary>
public sealed class StatusMetric
{
    /// <summary>
    /// Number of jobs in this status.
    /// </summary>
    [JsonPropertyName("count")]
    public long Count { get; set; }

    /// <summary>
    /// ISO 8601 timestamp of the last update for this status.
    /// </summary>
    [JsonPropertyName("lastUpdatedAt")]
    public DateTimeOffset LastUpdatedAt { get; set; }

}

/// <summary>
/// String property with full advanced search capabilities.
/// </summary>
public sealed class StringFilterProperty
{
}

/// <summary>
/// A tag. Needs to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
/// </summary>
public readonly record struct Tag : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private Tag(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="Tag"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static Tag AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "Tag", pattern: @"^[A-Za-z][A-Za-z0-9_\-:.]{0,99}$", minLength: 1, maxLength: 100);
        return new Tag(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^[A-Za-z][A-Za-z0-9_\-:.]{0,99}$", minLength: 1, maxLength: 100);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// TenantClientResult
/// </summary>
public sealed class TenantClientResult
{
    /// <summary>
    /// The ID of the client.
    /// </summary>
    [JsonPropertyName("clientId")]
    public string? ClientId { get; set; }

}

/// <summary>
/// TenantClientSearchQueryRequest
/// </summary>
public sealed class TenantClientSearchQueryRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<TenantClientSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// TenantClientSearchQuerySortRequest
/// </summary>
public sealed class TenantClientSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// TenantClientSearchResult
/// </summary>
public sealed class TenantClientSearchResult
{
    /// <summary>
    /// The matching clients.
    /// </summary>
    [JsonPropertyName("items")]
    public List<TenantClientResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// TenantCreateRequest
/// </summary>
public sealed class TenantCreateRequest
{
    /// <summary>
    /// The unique ID for the tenant. Must be 255 characters or less. Can contain letters, numbers, [`_`, `-`, `+`, `.`, `@`].
    /// </summary>
    [JsonPropertyName("tenantId")]
    public string TenantId { get; set; } = null!;

    /// <summary>
    /// The name of the tenant.
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; } = null!;

    /// <summary>
    /// The description of the tenant.
    /// </summary>
    [JsonPropertyName("description")]
    public string? Description { get; set; }

}

/// <summary>
/// TenantCreateResult
/// </summary>
public sealed class TenantCreateResult
{
    /// <summary>
    /// The unique identifier of the tenant.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The name of the tenant.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The description of the tenant.
    /// </summary>
    [JsonPropertyName("description")]
    public string? Description { get; set; }

}

/// <summary>
/// Tenant filter request
/// </summary>
public sealed class TenantFilter
{
    /// <summary>
    /// The unique identifier of the tenant.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The name of the tenant.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

}

/// <summary>
/// The tenant filtering strategy for job activation. Determines whether to use tenant IDs provided in the request or tenant IDs assigned to the authenticated principal.
/// 
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum TenantFilterEnum
{
    [JsonPropertyName("PROVIDED")]
    PROVIDED,
    [JsonPropertyName("ASSIGNED")]
    ASSIGNED,
}

/// <summary>
/// TenantGroupResult
/// </summary>
public sealed class TenantGroupResult
{
    /// <summary>
    /// The groupId of the group.
    /// </summary>
    [JsonPropertyName("groupId")]
    public string? GroupId { get; set; }

}

/// <summary>
/// TenantGroupSearchQueryRequest
/// </summary>
public sealed class TenantGroupSearchQueryRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<TenantGroupSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// TenantGroupSearchQuerySortRequest
/// </summary>
public sealed class TenantGroupSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// TenantGroupSearchResult
/// </summary>
public sealed class TenantGroupSearchResult
{
    /// <summary>
    /// The matching groups.
    /// </summary>
    [JsonPropertyName("items")]
    public List<TenantGroupResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// The unique identifier of the tenant.
/// </summary>
public readonly record struct TenantId : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private TenantId(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="TenantId"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static TenantId AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "TenantId", pattern: @"^(<default>|[A-Za-z0-9_@.+-]+)$", minLength: 1, maxLength: 256);
        return new TenantId(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^(<default>|[A-Za-z0-9_@.+-]+)$", minLength: 1, maxLength: 256);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Tenant search response item.
/// </summary>
public sealed class TenantResult
{
    /// <summary>
    /// The tenant name.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The unique identifier of the tenant.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The tenant description.
    /// </summary>
    [JsonPropertyName("description")]
    public string? Description { get; set; }

}

/// <summary>
/// Tenant search request
/// </summary>
public sealed class TenantSearchQueryRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<TenantSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The tenant search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public TenantFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// Tenant search response.
/// </summary>
public sealed class TenantSearchQueryResult
{
    /// <summary>
    /// The matching tenants.
    /// </summary>
    [JsonPropertyName("items")]
    public List<TenantResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// TenantSearchQuerySortRequest
/// </summary>
public sealed class TenantSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// TenantUpdateRequest
/// </summary>
public sealed class TenantUpdateRequest
{
    /// <summary>
    /// The new name of the tenant.
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; } = null!;

    /// <summary>
    /// The new description of the tenant.
    /// </summary>
    [JsonPropertyName("description")]
    public string? Description { get; set; }

}

/// <summary>
/// TenantUpdateResult
/// </summary>
public sealed class TenantUpdateResult
{
    /// <summary>
    /// The unique identifier of the tenant.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The name of the tenant.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The description of the tenant.
    /// </summary>
    [JsonPropertyName("description")]
    public string? Description { get; set; }

}

/// <summary>
/// TenantUserResult
/// </summary>
public sealed class TenantUserResult
{
    /// <summary>
    /// The unique name of a user.
    /// </summary>
    [JsonPropertyName("username")]
    public Username? Username { get; set; }

}

/// <summary>
/// TenantUserSearchQueryRequest
/// </summary>
public sealed class TenantUserSearchQueryRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<TenantUserSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// TenantUserSearchQuerySortRequest
/// </summary>
public sealed class TenantUserSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// TenantUserSearchResult
/// </summary>
public sealed class TenantUserSearchResult
{
    /// <summary>
    /// The matching users.
    /// </summary>
    [JsonPropertyName("items")]
    public List<TenantUserResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// The response of a topology request.
/// </summary>
public sealed class TopologyResponse
{
    /// <summary>
    /// A list of brokers that are part of this cluster.
    /// </summary>
    [JsonPropertyName("brokers")]
    public List<BrokerInfo> Brokers { get; set; } = null!;

    /// <summary>
    /// The cluster Id.
    /// </summary>
    [JsonPropertyName("clusterId")]
    public string? ClusterId { get; set; }

    /// <summary>
    /// The number of brokers in the cluster.
    /// </summary>
    [JsonPropertyName("clusterSize")]
    public int ClusterSize { get; set; }

    /// <summary>
    /// The number of partitions are spread across the cluster.
    /// </summary>
    [JsonPropertyName("partitionsCount")]
    public int PartitionsCount { get; set; }

    /// <summary>
    /// The configured replication factor for this cluster.
    /// </summary>
    [JsonPropertyName("replicationFactor")]
    public int ReplicationFactor { get; set; }

    /// <summary>
    /// The version of the Zeebe Gateway.
    /// </summary>
    [JsonPropertyName("gatewayVersion")]
    public string GatewayVersion { get; set; } = null!;

    /// <summary>
    /// ID of the last completed change
    /// </summary>
    [JsonPropertyName("lastCompletedChangeId")]
    public string LastCompletedChangeId { get; set; } = null!;

}

/// <summary>
/// UpdateClusterVariableRequest
/// </summary>
public sealed class UpdateClusterVariableRequest
{
    /// <summary>
    /// The new value of the cluster variable. Can be any JSON object or primitive value. Will be serialized as a JSON string in responses.
    /// </summary>
    [JsonPropertyName("value")]
    public object Value { get; set; } = null!;

}

/// <summary>
/// UsageMetricsResponse
/// </summary>
public sealed class UsageMetricsResponse
{
    /// <summary>
    /// The amount of active tenants.
    /// </summary>
    [JsonPropertyName("activeTenants")]
    public long? ActiveTenants { get; set; }

    /// <summary>
    /// The usage metrics by tenants. Only available if request `withTenants` query parameter was `true`.
    /// </summary>
    [JsonPropertyName("tenants")]
    public Dictionary<string, object>? Tenants { get; set; }

    /// <summary>
    /// The amount of created root process instances.
    /// </summary>
    [JsonPropertyName("processInstances")]
    public long? ProcessInstances { get; set; }

    /// <summary>
    /// The amount of executed decision instances.
    /// </summary>
    [JsonPropertyName("decisionInstances")]
    public long? DecisionInstances { get; set; }

    /// <summary>
    /// The amount of unique active task users.
    /// </summary>
    [JsonPropertyName("assignees")]
    public long? Assignees { get; set; }

}

/// <summary>
/// UsageMetricsResponseItem
/// </summary>
public sealed class UsageMetricsResponseItem
{
    /// <summary>
    /// The amount of created root process instances.
    /// </summary>
    [JsonPropertyName("processInstances")]
    public long? ProcessInstances { get; set; }

    /// <summary>
    /// The amount of executed decision instances.
    /// </summary>
    [JsonPropertyName("decisionInstances")]
    public long? DecisionInstances { get; set; }

    /// <summary>
    /// The amount of unique active task users.
    /// </summary>
    [JsonPropertyName("assignees")]
    public long? Assignees { get; set; }

}

/// <summary>
/// UserCreateResult
/// </summary>
public sealed class UserCreateResult
{
    /// <summary>
    /// The unique name of a user.
    /// </summary>
    [JsonPropertyName("username")]
    public Username? Username { get; set; }

    /// <summary>
    /// The name of the user.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The email of the user.
    /// </summary>
    [JsonPropertyName("email")]
    public string? Email { get; set; }

}

/// <summary>
/// User search filter.
/// </summary>
public sealed class UserFilter
{
    /// <summary>
    /// The username of the user.
    /// </summary>
    [JsonPropertyName("username")]
    public StringFilterProperty? Username { get; set; }

    /// <summary>
    /// The name of the user.
    /// </summary>
    [JsonPropertyName("name")]
    public StringFilterProperty? Name { get; set; }

    /// <summary>
    /// The email of the user.
    /// </summary>
    [JsonPropertyName("email")]
    public StringFilterProperty? Email { get; set; }

}

/// <summary>
/// The unique name of a user.
/// </summary>
public readonly record struct Username : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private Username(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="Username"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static Username AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "Username", pattern: @"^(<default>|[A-Za-z0-9_@.+-]+)$", minLength: 1, maxLength: 256);
        return new Username(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^(<default>|[A-Za-z0-9_@.+-]+)$", minLength: 1, maxLength: 256);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// UserRequest
/// </summary>
public sealed class UserRequest
{
    /// <summary>
    /// The password of the user.
    /// </summary>
    [JsonPropertyName("password")]
    public string Password { get; set; } = null!;

    /// <summary>
    /// The username of the user.
    /// </summary>
    [JsonPropertyName("username")]
    public string Username { get; set; } = null!;

    /// <summary>
    /// The name of the user.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The email of the user.
    /// </summary>
    [JsonPropertyName("email")]
    public string? Email { get; set; }

}

/// <summary>
/// UserResult
/// </summary>
public sealed class UserResult
{
    /// <summary>
    /// The unique name of a user.
    /// </summary>
    [JsonPropertyName("username")]
    public Username? Username { get; set; }

    /// <summary>
    /// The name of the user.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The email of the user.
    /// </summary>
    [JsonPropertyName("email")]
    public string? Email { get; set; }

}

/// <summary>
/// UserSearchQueryRequest
/// </summary>
public sealed class UserSearchQueryRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<UserSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The user search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public UserFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// UserSearchQuerySortRequest
/// </summary>
public sealed class UserSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// UserSearchResult
/// </summary>
public sealed class UserSearchResult
{
    /// <summary>
    /// The matching users.
    /// </summary>
    [JsonPropertyName("items")]
    public List<UserResult> Items { get; set; } = null!;

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// UserTaskAssignmentRequest
/// </summary>
public sealed class UserTaskAssignmentRequest
{
    /// <summary>
    /// The assignee for the user task. The assignee must not be empty or `null`.
    /// </summary>
    [JsonPropertyName("assignee")]
    public string? Assignee { get; set; }

    /// <summary>
    /// By default, the task is reassigned if it was already assigned. Set this to `false` to return an error in such cases. The task must then first be unassigned to be assigned again. Use this when you have users picking from group task queues to prevent race conditions.
    /// 
    /// </summary>
    [JsonPropertyName("allowOverride")]
    public bool? AllowOverride { get; set; }

    /// <summary>
    /// A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "assign".
    /// 
    /// </summary>
    [JsonPropertyName("action")]
    public string? Action { get; set; }

}

/// <summary>
/// The user task audit log search filters.
/// </summary>
public sealed class UserTaskAuditLogFilter
{
    /// <summary>
    /// The audit log operation type search filter.
    /// </summary>
    [JsonPropertyName("operationType")]
    public OperationTypeFilterProperty? OperationType { get; set; }

    /// <summary>
    /// The audit log result search filter.
    /// </summary>
    [JsonPropertyName("result")]
    public AuditLogResultFilterProperty? Result { get; set; }

    /// <summary>
    /// The audit log timestamp filter.
    /// </summary>
    [JsonPropertyName("timestamp")]
    public DateTimeFilterProperty? Timestamp { get; set; }

    /// <summary>
    /// The actor type search filter.
    /// </summary>
    [JsonPropertyName("actorType")]
    public AuditLogActorTypeFilterProperty? ActorType { get; set; }

    /// <summary>
    /// The actor ID search filter.
    /// </summary>
    [JsonPropertyName("actorId")]
    public StringFilterProperty? ActorId { get; set; }

}

/// <summary>
/// User task search query request.
/// </summary>
public sealed class UserTaskAuditLogSearchQueryRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<AuditLogSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The user task audit log search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public UserTaskAuditLogFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// UserTaskCompletionRequest
/// </summary>
public sealed class UserTaskCompletionRequest
{
    /// <summary>
    /// The variables to complete the user task with.
    /// </summary>
    [JsonPropertyName("variables")]
    public object? Variables { get; set; }

    /// <summary>
    /// A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "complete".
    /// 
    /// </summary>
    [JsonPropertyName("action")]
    public string? Action { get; set; }

}

/// <summary>
/// User task filter request.
/// </summary>
public sealed class UserTaskFilter
{
    /// <summary>
    /// The user task state.
    /// </summary>
    [JsonPropertyName("state")]
    public UserTaskStateFilterProperty? State { get; set; }

    /// <summary>
    /// The assignee of the user task.
    /// </summary>
    [JsonPropertyName("assignee")]
    public StringFilterProperty? Assignee { get; set; }

    /// <summary>
    /// The priority of the user task.
    /// </summary>
    [JsonPropertyName("priority")]
    public IntegerFilterProperty? Priority { get; set; }

    /// <summary>
    /// The element ID of the user task.
    /// </summary>
    [JsonPropertyName("elementId")]
    public ElementId? ElementId { get; set; }

    /// <summary>
    /// The task name. This only works for data created with 8.8 and onwards. Instances from prior versions don't contain this data and cannot be found.
    /// 
    /// </summary>
    [JsonPropertyName("name")]
    public StringFilterProperty? Name { get; set; }

    /// <summary>
    /// The candidate group for this user task.
    /// </summary>
    [JsonPropertyName("candidateGroup")]
    public StringFilterProperty? CandidateGroup { get; set; }

    /// <summary>
    /// The candidate user for this user task.
    /// </summary>
    [JsonPropertyName("candidateUser")]
    public StringFilterProperty? CandidateUser { get; set; }

    /// <summary>
    /// Tenant ID of this user task.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public StringFilterProperty? TenantId { get; set; }

    /// <summary>
    /// The ID of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId? ProcessDefinitionId { get; set; }

    /// <summary>
    /// The user task creation date.
    /// </summary>
    [JsonPropertyName("creationDate")]
    public DateTimeFilterProperty? CreationDate { get; set; }

    /// <summary>
    /// The user task completion date.
    /// </summary>
    [JsonPropertyName("completionDate")]
    public DateTimeFilterProperty? CompletionDate { get; set; }

    /// <summary>
    /// The user task follow-up date.
    /// </summary>
    [JsonPropertyName("followUpDate")]
    public DateTimeFilterProperty? FollowUpDate { get; set; }

    /// <summary>
    /// The user task due date.
    /// </summary>
    [JsonPropertyName("dueDate")]
    public DateTimeFilterProperty? DueDate { get; set; }

    [JsonPropertyName("processInstanceVariables")]
    public List<VariableValueFilterProperty>? ProcessInstanceVariables { get; set; }

    [JsonPropertyName("localVariables")]
    public List<VariableValueFilterProperty>? LocalVariables { get; set; }

    /// <summary>
    /// The key for this user task.
    /// </summary>
    [JsonPropertyName("userTaskKey")]
    public UserTaskKey? UserTaskKey { get; set; }

    /// <summary>
    /// The key of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The key of the process instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the element instance.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKey? ElementInstanceKey { get; set; }

    /// <summary>
    /// List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
    /// </summary>
    [JsonPropertyName("tags")]
    public List<Tag>? Tags { get; set; }

}

/// <summary>
/// System-generated key for a user task.
/// </summary>
public readonly record struct UserTaskKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private UserTaskKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="UserTaskKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static UserTaskKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "UserTaskKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new UserTaskKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Contains properties of a user task.
/// </summary>
public sealed class UserTaskProperties
{
    /// <summary>
    /// The action performed on the user task.
    /// </summary>
    [JsonPropertyName("action")]
    public string? Action { get; set; }

    /// <summary>
    /// The user assigned to the task.
    /// </summary>
    [JsonPropertyName("assignee")]
    public string? Assignee { get; set; }

    /// <summary>
    /// The groups eligible to claim the task.
    /// </summary>
    [JsonPropertyName("candidateGroups")]
    public List<string>? CandidateGroups { get; set; }

    /// <summary>
    /// The users eligible to claim the task.
    /// </summary>
    [JsonPropertyName("candidateUsers")]
    public List<string>? CandidateUsers { get; set; }

    /// <summary>
    /// The attributes that were changed in the task.
    /// </summary>
    [JsonPropertyName("changedAttributes")]
    public List<string>? ChangedAttributes { get; set; }

    /// <summary>
    /// The due date of the user task in ISO 8601 format.
    /// </summary>
    [JsonPropertyName("dueDate")]
    public string? DueDate { get; set; }

    /// <summary>
    /// The follow-up date of the user task in ISO 8601 format.
    /// </summary>
    [JsonPropertyName("followUpDate")]
    public string? FollowUpDate { get; set; }

    /// <summary>
    /// The key of the form associated with the user task.
    /// </summary>
    [JsonPropertyName("formKey")]
    public FormKey? FormKey { get; set; }

    /// <summary>
    /// The priority of the user task.
    /// </summary>
    [JsonPropertyName("priority")]
    public int? Priority { get; set; }

    /// <summary>
    /// The unique key identifying the user task.
    /// </summary>
    [JsonPropertyName("userTaskKey")]
    public UserTaskKey? UserTaskKey { get; set; }

}

/// <summary>
/// UserTaskResult
/// </summary>
public sealed class UserTaskResult
{
    /// <summary>
    /// The name for this user task.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The state of the user task.
    /// </summary>
    [JsonPropertyName("state")]
    public UserTaskStateEnum? State { get; set; }

    /// <summary>
    /// The assignee of the user task.
    /// </summary>
    [JsonPropertyName("assignee")]
    public string? Assignee { get; set; }

    /// <summary>
    /// The element ID of the user task.
    /// </summary>
    [JsonPropertyName("elementId")]
    public ElementId? ElementId { get; set; }

    /// <summary>
    /// The candidate groups for this user task.
    /// </summary>
    [JsonPropertyName("candidateGroups")]
    public List<string>? CandidateGroups { get; set; }

    /// <summary>
    /// The candidate users for this user task.
    /// </summary>
    [JsonPropertyName("candidateUsers")]
    public List<string>? CandidateUsers { get; set; }

    /// <summary>
    /// The ID of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId? ProcessDefinitionId { get; set; }

    /// <summary>
    /// The creation date of a user task.
    /// </summary>
    [JsonPropertyName("creationDate")]
    public DateTimeOffset? CreationDate { get; set; }

    /// <summary>
    /// The completion date of a user task.
    /// </summary>
    [JsonPropertyName("completionDate")]
    public DateTimeOffset? CompletionDate { get; set; }

    /// <summary>
    /// The follow date of a user task.
    /// </summary>
    [JsonPropertyName("followUpDate")]
    public DateTimeOffset? FollowUpDate { get; set; }

    /// <summary>
    /// The due date of a user task.
    /// </summary>
    [JsonPropertyName("dueDate")]
    public DateTimeOffset? DueDate { get; set; }

    /// <summary>
    /// The unique identifier of the tenant.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The external form reference.
    /// </summary>
    [JsonPropertyName("externalFormReference")]
    public string? ExternalFormReference { get; set; }

    /// <summary>
    /// The version of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionVersion")]
    public int? ProcessDefinitionVersion { get; set; }

    /// <summary>
    /// Custom headers for the user task.
    /// </summary>
    [JsonPropertyName("customHeaders")]
    public Dictionary<string, string>? CustomHeaders { get; set; }

    /// <summary>
    /// The priority of a user task. The higher the value the higher the priority.
    /// </summary>
    [JsonPropertyName("priority")]
    public int? Priority { get; set; }

    /// <summary>
    /// The key of the user task.
    /// </summary>
    [JsonPropertyName("userTaskKey")]
    public UserTaskKey? UserTaskKey { get; set; }

    /// <summary>
    /// The key of the element instance.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKey? ElementInstanceKey { get; set; }

    /// <summary>
    /// The name of the process definition.
    /// </summary>
    [JsonPropertyName("processName")]
    public string? ProcessName { get; set; }

    /// <summary>
    /// The key of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The key of the process instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the root process instance. The root process instance is the top-level
    /// ancestor in the process instance hierarchy. This field is only present for data
    /// belonging to process instance hierarchies created in version 8.9 or later.
    /// 
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public RootProcessInstanceKey? RootProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the form.
    /// </summary>
    [JsonPropertyName("formKey")]
    public FormKey? FormKey { get; set; }

    /// <summary>
    /// List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
    /// </summary>
    [JsonPropertyName("tags")]
    public List<Tag>? Tags { get; set; }

}

/// <summary>
/// User task search query request.
/// </summary>
public sealed class UserTaskSearchQuery
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<UserTaskSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The user task search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public UserTaskFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// User task search query response.
/// </summary>
public sealed class UserTaskSearchQueryResult
{
    /// <summary>
    /// The matching user tasks.
    /// </summary>
    [JsonPropertyName("items")]
    public List<UserTaskResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// UserTaskSearchQuerySortRequest
/// </summary>
public sealed class UserTaskSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// The state of the user task.
/// </summary>
[JsonConverter(typeof(JsonStringEnumConverter))]
public enum UserTaskStateEnum
{
    [JsonPropertyName("CREATING")]
    CREATING,
    [JsonPropertyName("CREATED")]
    CREATED,
    [JsonPropertyName("ASSIGNING")]
    ASSIGNING,
    [JsonPropertyName("UPDATING")]
    UPDATING,
    [JsonPropertyName("COMPLETING")]
    COMPLETING,
    [JsonPropertyName("COMPLETED")]
    COMPLETED,
    [JsonPropertyName("CANCELING")]
    CANCELING,
    [JsonPropertyName("CANCELED")]
    CANCELED,
    [JsonPropertyName("FAILED")]
    FAILED,
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct UserTaskStateExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private UserTaskStateExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="UserTaskStateExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static UserTaskStateExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "UserTaskStateExactMatch");
        return new UserTaskStateExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// UserTaskStateEnum property with full advanced search capabilities.
/// </summary>
public sealed class UserTaskStateFilterProperty
{
}

/// <summary>
/// UserTaskUpdateRequest
/// </summary>
public sealed class UserTaskUpdateRequest
{
    /// <summary>
    /// JSON object with changed task attribute values.
    /// 
    /// The following attributes can be adjusted with this endpoint, additional attributes
    /// will be ignored:
    /// 
    /// * `candidateGroups` - reset by providing an empty list
    /// * `candidateUsers` - reset by providing an empty list
    /// * `dueDate` - reset by providing an empty String
    /// * `followUpDate` - reset by providing an empty String
    /// * `priority` - minimum 0, maximum 100, default 50
    /// 
    /// Providing any of those attributes with a `null` value or omitting it preserves
    /// the persisted attribute's value.
    /// 
    /// The assignee cannot be adjusted with this endpoint, use the Assign task endpoint.
    /// This ensures correct event emission for assignee changes.
    /// 
    /// </summary>
    [JsonPropertyName("changeset")]
    public Changeset? Changeset { get; set; }

    /// <summary>
    /// A custom action value that will be accessible from user task events resulting from this endpoint invocation. If not provided, it will default to "update".
    /// 
    /// </summary>
    [JsonPropertyName("action")]
    public string? Action { get; set; }

}

/// <summary>
/// The user task variable search filters.
/// </summary>
public sealed class UserTaskVariableFilter
{
    /// <summary>
    /// Name of the variable.
    /// </summary>
    [JsonPropertyName("name")]
    public StringFilterProperty? Name { get; set; }

}

/// <summary>
/// User task search query request.
/// </summary>
public sealed class UserTaskVariableSearchQueryRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<UserTaskVariableSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The user task variable search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public UserTaskVariableFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// UserTaskVariableSearchQuerySortRequest
/// </summary>
public sealed class UserTaskVariableSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// UserUpdateRequest
/// </summary>
public sealed class UserUpdateRequest
{
    /// <summary>
    /// The password of the user. If blank, the password is unchanged.
    /// </summary>
    [JsonPropertyName("password")]
    public string? Password { get; set; }

    /// <summary>
    /// The name of the user.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The email of the user.
    /// </summary>
    [JsonPropertyName("email")]
    public string? Email { get; set; }

}

/// <summary>
/// UserUpdateResult
/// </summary>
public sealed class UserUpdateResult
{
    /// <summary>
    /// The unique name of a user.
    /// </summary>
    [JsonPropertyName("username")]
    public Username? Username { get; set; }

    /// <summary>
    /// The name of the user.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The email of the user.
    /// </summary>
    [JsonPropertyName("email")]
    public string? Email { get; set; }

}

/// <summary>
/// Instructs the engine to use the source's direct parent key as the ancestor scope key for the target element. This is a simpler alternative to `inferred` that skips hierarchy traversal and directly uses the source's parent key. This is useful when the source and target elements are siblings within the same flow scope.
/// 
/// </summary>
public sealed class UseSourceParentKeyInstruction : AncestorScopeInstruction
{
    /// <summary>
    /// The type of ancestor scope instruction.
    /// </summary>
    [JsonPropertyName("ancestorScopeType")]
    public string AncestorScopeType { get; set; } = null!;

}

/// <summary>
/// Variable filter request.
/// </summary>
public sealed class VariableFilter
{
    /// <summary>
    /// Name of the variable.
    /// </summary>
    [JsonPropertyName("name")]
    public StringFilterProperty? Name { get; set; }

    /// <summary>
    /// The value of the variable.
    /// </summary>
    [JsonPropertyName("value")]
    public StringFilterProperty? Value { get; set; }

    /// <summary>
    /// Tenant ID of this variable.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// Whether the value is truncated or not.
    /// </summary>
    [JsonPropertyName("isTruncated")]
    public bool? IsTruncated { get; set; }

    /// <summary>
    /// The key for this variable.
    /// </summary>
    [JsonPropertyName("variableKey")]
    public VariableKeyFilterProperty? VariableKey { get; set; }

    /// <summary>
    /// The key of the scope of this variable.
    /// </summary>
    [JsonPropertyName("scopeKey")]
    public ScopeKeyFilterProperty? ScopeKey { get; set; }

    /// <summary>
    /// The key of the process instance of this variable.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKeyFilterProperty? ProcessInstanceKey { get; set; }

}

/// <summary>
/// System-generated key for a variable.
/// </summary>
public readonly record struct VariableKey : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private VariableKey(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="VariableKey"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static VariableKey AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "VariableKey", pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);
        return new VariableKey(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value, pattern: @"^-?[0-9]+$", minLength: 1, maxLength: 25);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// Matches the value exactly.
/// </summary>
public readonly record struct VariableKeyExactMatch : global::Camunda.Orchestration.Sdk.Runtime.ICamundaKey
{
    /// <summary>The underlying string value.</summary>
    public string Value { get; }

    private VariableKeyExactMatch(string value) => Value = value;

    /// <summary>
    /// Creates a <see cref="VariableKeyExactMatch"/> from a raw string value.
    /// Use this when side-loading values not received from an API call.
    /// </summary>
    public static VariableKeyExactMatch AssumeExists(string value)
    {
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.AssertConstraints(value, "VariableKeyExactMatch");
        return new VariableKeyExactMatch(value);
    }

    /// <summary>Returns true if the value satisfies this type's constraints.</summary>
    public static bool IsValid(string value) =>
        global::Camunda.Orchestration.Sdk.Runtime.CamundaKeyValidation.CheckConstraints(value);

    /// <inheritdoc />
    public override string ToString() => Value.ToString()!;
}

/// <summary>
/// VariableKey property with full advanced search capabilities.
/// </summary>
public sealed class VariableKeyFilterProperty
{
}

/// <summary>
/// Variable search response item.
/// </summary>
public sealed class VariableResult
{
    /// <summary>
    /// Full value of this variable.
    /// </summary>
    [JsonPropertyName("value")]
    public string? Value { get; set; }

    /// <summary>
    /// Name of this variable.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// Tenant ID of this variable.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The key for this variable.
    /// </summary>
    [JsonPropertyName("variableKey")]
    public VariableKey? VariableKey { get; set; }

    /// <summary>
    /// The key of the scope of this variable.
    /// </summary>
    [JsonPropertyName("scopeKey")]
    public ScopeKey? ScopeKey { get; set; }

    /// <summary>
    /// The key of the process instance of this variable.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the root process instance. The root process instance is the top-level
    /// ancestor in the process instance hierarchy. This field is only present for data
    /// belonging to process instance hierarchies created in version 8.9 or later.
    /// 
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public RootProcessInstanceKey? RootProcessInstanceKey { get; set; }

}

/// <summary>
/// Variable response item.
/// </summary>
public sealed class VariableResultBase
{
    /// <summary>
    /// Name of this variable.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// Tenant ID of this variable.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The key for this variable.
    /// </summary>
    [JsonPropertyName("variableKey")]
    public VariableKey? VariableKey { get; set; }

    /// <summary>
    /// The key of the scope of this variable.
    /// </summary>
    [JsonPropertyName("scopeKey")]
    public ScopeKey? ScopeKey { get; set; }

    /// <summary>
    /// The key of the process instance of this variable.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the root process instance. The root process instance is the top-level
    /// ancestor in the process instance hierarchy. This field is only present for data
    /// belonging to process instance hierarchies created in version 8.9 or later.
    /// 
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public RootProcessInstanceKey? RootProcessInstanceKey { get; set; }

}

/// <summary>
/// Variable search query request.
/// </summary>
public sealed class VariableSearchQuery
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<VariableSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The variable search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public VariableFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// Variable search query response.
/// </summary>
public sealed class VariableSearchQueryResult
{
    /// <summary>
    /// The matching variables.
    /// </summary>
    [JsonPropertyName("items")]
    public List<VariableSearchResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// VariableSearchQuerySortRequest
/// </summary>
public sealed class VariableSearchQuerySortRequest
{
    /// <summary>
    /// The field to sort by.
    /// </summary>
    [JsonPropertyName("field")]
    public string Field { get; set; } = null!;

    /// <summary>
    /// The order in which to sort the related field.
    /// </summary>
    [JsonPropertyName("order")]
    public SortOrderEnum? Order { get; set; }

}

/// <summary>
/// Variable search response item.
/// </summary>
public sealed class VariableSearchResult
{
    /// <summary>
    /// Value of this variable. Can be truncated.
    /// </summary>
    [JsonPropertyName("value")]
    public string? Value { get; set; }

    /// <summary>
    /// Whether the value is truncated or not.
    /// </summary>
    [JsonPropertyName("isTruncated")]
    public bool? IsTruncated { get; set; }

    /// <summary>
    /// Name of this variable.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// Tenant ID of this variable.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The key for this variable.
    /// </summary>
    [JsonPropertyName("variableKey")]
    public VariableKey? VariableKey { get; set; }

    /// <summary>
    /// The key of the scope of this variable.
    /// </summary>
    [JsonPropertyName("scopeKey")]
    public ScopeKey? ScopeKey { get; set; }

    /// <summary>
    /// The key of the process instance of this variable.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the root process instance. The root process instance is the top-level
    /// ancestor in the process instance hierarchy. This field is only present for data
    /// belonging to process instance hierarchies created in version 8.9 or later.
    /// 
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public RootProcessInstanceKey? RootProcessInstanceKey { get; set; }

}

/// <summary>
/// VariableValueFilterProperty
/// </summary>
public sealed class VariableValueFilterProperty
{
    /// <summary>
    /// Name of the variable.
    /// </summary>
    [JsonPropertyName("name")]
    public string Name { get; set; } = null!;

    /// <summary>
    /// The value of the variable.
    /// </summary>
    [JsonPropertyName("value")]
    public StringFilterProperty Value { get; set; } = null!;

}

/// <summary>
/// The list of activated jobs
/// </summary>
public sealed class ActivateJobsResponse
{
    /// <summary>
    /// The activated jobs.
    /// </summary>
    [JsonPropertyName("jobs")]
    public List<ActivatedJobResult> Jobs { get; set; } = null!;

}

/// <summary>
/// The process instance filter that defines which process instances should be canceled.
/// </summary>
public sealed class CancelProcessInstancesBatchOperationRequest
{
    /// <summary>
    /// The process instance filter.
    /// </summary>
    [JsonPropertyName("filter")]
    public ProcessInstanceFilter Filter { get; set; } = null!;

    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public long? OperationReference { get; set; }

}

/// <summary>
/// CreateDeploymentResponse
/// </summary>
public sealed class CreateDeploymentResponse
{
    /// <summary>
    /// The unique key identifying the deployment.
    /// </summary>
    [JsonPropertyName("deploymentKey")]
    public DeploymentKey DeploymentKey { get; set; }

    /// <summary>
    /// The tenant ID associated with the deployment.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId TenantId { get; set; }

    /// <summary>
    /// Items deployed by the request.
    /// </summary>
    [JsonPropertyName("deployments")]
    public List<DeploymentMetadataResult> Deployments { get; set; } = null!;

}

/// <summary>
/// The process instance filter that defines which process instances should be deleted.
/// </summary>
public sealed class DeleteProcessInstancesBatchOperationRequest
{
    /// <summary>
    /// The process instance filter.
    /// </summary>
    [JsonPropertyName("filter")]
    public ProcessInstanceFilter Filter { get; set; } = null!;

    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public long? OperationReference { get; set; }

}

/// <summary>
/// Audit log item.
/// </summary>
public sealed class GetAuditLogResponse
{
    /// <summary>
    /// The unique key of the audit log entry.
    /// </summary>
    [JsonPropertyName("auditLogKey")]
    public AuditLogKey? AuditLogKey { get; set; }

    /// <summary>
    /// System-generated entity key for an audit log entry.
    /// </summary>
    [JsonPropertyName("entityKey")]
    public AuditLogEntityKey? EntityKey { get; set; }

    /// <summary>
    /// The type of entity affected by the operation.
    /// </summary>
    [JsonPropertyName("entityType")]
    public AuditLogEntityTypeEnum? EntityType { get; set; }

    /// <summary>
    /// The type of operation performed.
    /// </summary>
    [JsonPropertyName("operationType")]
    public AuditLogOperationTypeEnum? OperationType { get; set; }

    /// <summary>
    /// Key of the batch operation.
    /// </summary>
    [JsonPropertyName("batchOperationKey")]
    public BatchOperationKey? BatchOperationKey { get; set; }

    /// <summary>
    /// The type of batch operation performed, if this is part of a batch.
    /// </summary>
    [JsonPropertyName("batchOperationType")]
    public BatchOperationTypeEnum? BatchOperationType { get; set; }

    /// <summary>
    /// The timestamp when the operation occurred.
    /// </summary>
    [JsonPropertyName("timestamp")]
    public DateTimeOffset? Timestamp { get; set; }

    /// <summary>
    /// The ID of the actor who performed the operation.
    /// </summary>
    [JsonPropertyName("actorId")]
    public string? ActorId { get; set; }

    /// <summary>
    /// The type of actor who performed the operation.
    /// </summary>
    [JsonPropertyName("actorType")]
    public AuditLogActorTypeEnum? ActorType { get; set; }

    /// <summary>
    /// The tenant ID of the audit log.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The result status of the operation.
    /// </summary>
    [JsonPropertyName("result")]
    public AuditLogResultEnum? Result { get; set; }

    /// <summary>
    /// Additional notes about the operation.
    /// </summary>
    [JsonPropertyName("annotation")]
    public string? Annotation { get; set; }

    /// <summary>
    /// The category of the audit log operation.
    /// </summary>
    [JsonPropertyName("category")]
    public AuditLogCategoryEnum? Category { get; set; }

    /// <summary>
    /// The process definition ID.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId? ProcessDefinitionId { get; set; }

    /// <summary>
    /// The key of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The key of the process instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// System-generated key for a process instance.
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public ProcessInstanceKey? RootProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the element instance.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKey? ElementInstanceKey { get; set; }

    /// <summary>
    /// The key of the job.
    /// </summary>
    [JsonPropertyName("jobKey")]
    public JobKey? JobKey { get; set; }

    /// <summary>
    /// The key of the user task.
    /// </summary>
    [JsonPropertyName("userTaskKey")]
    public UserTaskKey? UserTaskKey { get; set; }

    /// <summary>
    /// The decision requirements ID.
    /// </summary>
    [JsonPropertyName("decisionRequirementsId")]
    public string? DecisionRequirementsId { get; set; }

    /// <summary>
    /// The assigned key of the decision requirements.
    /// </summary>
    [JsonPropertyName("decisionRequirementsKey")]
    public DecisionRequirementsKey? DecisionRequirementsKey { get; set; }

    /// <summary>
    /// The decision definition ID.
    /// </summary>
    [JsonPropertyName("decisionDefinitionId")]
    public DecisionDefinitionId? DecisionDefinitionId { get; set; }

    /// <summary>
    /// The key of the decision definition.
    /// </summary>
    [JsonPropertyName("decisionDefinitionKey")]
    public DecisionDefinitionKey? DecisionDefinitionKey { get; set; }

    /// <summary>
    /// The key of the decision evaluation.
    /// </summary>
    [JsonPropertyName("decisionEvaluationKey")]
    public DecisionEvaluationKey? DecisionEvaluationKey { get; set; }

    /// <summary>
    /// The key of the deployment.
    /// </summary>
    [JsonPropertyName("deploymentKey")]
    public DeploymentKey? DeploymentKey { get; set; }

    /// <summary>
    /// The key of the form.
    /// </summary>
    [JsonPropertyName("formKey")]
    public object? FormKey { get; set; }

    /// <summary>
    /// The system-assigned key for this resource.
    /// </summary>
    [JsonPropertyName("resourceKey")]
    public ResourceKey? ResourceKey { get; set; }

    /// <summary>
    /// The key of the related entity. The content depends on the operation type and entity type.
    /// For example, for authorization operations, this will contain the ID of the owner (e.g., user or group) the authorization belongs to.
    /// 
    /// </summary>
    [JsonPropertyName("relatedEntityKey")]
    public AuditLogEntityKey? RelatedEntityKey { get; set; }

    /// <summary>
    /// The type of the related entity. The content depends on the operation type and entity type.
    /// For example, for authorization operations, this will contain the type of the owner (e.g., USER or GROUP) the authorization belongs to.
    /// 
    /// </summary>
    [JsonPropertyName("relatedEntityType")]
    public AuditLogEntityTypeEnum? RelatedEntityType { get; set; }

    /// <summary>
    /// Additional description of the entity affected by the operation.
    /// For example, for variable operations, this will contain the variable name.
    /// 
    /// </summary>
    [JsonPropertyName("entityDescription")]
    public string? EntityDescription { get; set; }

}

/// <summary>
/// GetElementInstanceResponse
/// </summary>
public sealed class GetElementInstanceResponse
{
    /// <summary>
    /// The process definition ID associated to this element instance.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId ProcessDefinitionId { get; set; }

    /// <summary>
    /// Date when element instance started.
    /// </summary>
    [JsonPropertyName("startDate")]
    public DateTimeOffset StartDate { get; set; }

    /// <summary>
    /// Date when element instance finished.
    /// </summary>
    [JsonPropertyName("endDate")]
    public DateTimeOffset? EndDate { get; set; }

    /// <summary>
    /// The element ID for this element instance.
    /// </summary>
    [JsonPropertyName("elementId")]
    public ElementId ElementId { get; set; }

    /// <summary>
    /// The element name for this element instance.
    /// </summary>
    [JsonPropertyName("elementName")]
    public string ElementName { get; set; } = null!;

    /// <summary>
    /// Type of element as defined set of values.
    /// </summary>
    [JsonPropertyName("type")]
    public string Type { get; set; } = null!;

    /// <summary>
    /// State of element instance as defined set of values.
    /// </summary>
    [JsonPropertyName("state")]
    public ElementInstanceStateEnum State { get; set; }

    /// <summary>
    /// Shows whether this element instance has an incident. If true also an incidentKey is provided.
    /// </summary>
    [JsonPropertyName("hasIncident")]
    public bool HasIncident { get; set; }

    /// <summary>
    /// The tenant ID of the incident.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId TenantId { get; set; }

    /// <summary>
    /// The assigned key, which acts as a unique identifier for this element instance.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKey ElementInstanceKey { get; set; }

    /// <summary>
    /// The process instance key associated to this element instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey ProcessInstanceKey { get; set; }

    /// <summary>
    /// System-generated key for a process instance.
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public ProcessInstanceKey? RootProcessInstanceKey { get; set; }

    /// <summary>
    /// The process definition key associated to this element instance.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey ProcessDefinitionKey { get; set; }

    /// <summary>
    /// Incident key associated with this element instance.
    /// </summary>
    [JsonPropertyName("incidentKey")]
    public IncidentKey? IncidentKey { get; set; }

}

/// <summary>
/// GetIncidentResponse
/// </summary>
public sealed class GetIncidentResponse
{
    /// <summary>
    /// The process definition ID associated to this incident.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId? ProcessDefinitionId { get; set; }

    [JsonPropertyName("errorType")]
    public IncidentErrorTypeEnum? ErrorType { get; set; }

    /// <summary>
    /// Error message which describes the error in more detail.
    /// </summary>
    [JsonPropertyName("errorMessage")]
    public string? ErrorMessage { get; set; }

    /// <summary>
    /// The element ID associated to this incident.
    /// </summary>
    [JsonPropertyName("elementId")]
    public ElementId? ElementId { get; set; }

    [JsonPropertyName("creationTime")]
    public DateTimeOffset? CreationTime { get; set; }

    [JsonPropertyName("state")]
    public IncidentStateEnum? State { get; set; }

    /// <summary>
    /// The tenant ID of the incident.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The assigned key, which acts as a unique identifier for this incident.
    /// </summary>
    [JsonPropertyName("incidentKey")]
    public IncidentKey? IncidentKey { get; set; }

    /// <summary>
    /// The process definition key associated to this incident.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The process instance key associated to this incident.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// System-generated key for a process instance.
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public ProcessInstanceKey? RootProcessInstanceKey { get; set; }

    /// <summary>
    /// The element instance key associated to this incident.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKey? ElementInstanceKey { get; set; }

    /// <summary>
    /// The job key, if exists, associated with this incident.
    /// </summary>
    [JsonPropertyName("jobKey")]
    public JobKey? JobKey { get; set; }

}

/// <summary>
/// Process definition element statistics request.
/// </summary>
public sealed class GetProcessDefinitionStatisticsRequest
{
    /// <summary>
    /// The process definition statistics search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public object? Filter { get; set; }

}

/// <summary>
/// Process instance search response item.
/// </summary>
public sealed class GetProcessInstanceResponse
{
    /// <summary>
    /// Id of a process definition, from the model. Only ids of process definitions that are deployed are useful.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId ProcessDefinitionId { get; set; }

    /// <summary>
    /// The process definition name.
    /// </summary>
    [JsonPropertyName("processDefinitionName")]
    public string ProcessDefinitionName { get; set; } = null!;

    [JsonPropertyName("processDefinitionVersion")]
    public int ProcessDefinitionVersion { get; set; }

    /// <summary>
    /// The process definition version tag.
    /// </summary>
    [JsonPropertyName("processDefinitionVersionTag")]
    public string? ProcessDefinitionVersionTag { get; set; }

    [JsonPropertyName("startDate")]
    public DateTimeOffset StartDate { get; set; }

    [JsonPropertyName("endDate")]
    public DateTimeOffset? EndDate { get; set; }

    /// <summary>
    /// Process instance states
    /// </summary>
    [JsonPropertyName("state")]
    public ProcessInstanceStateEnum State { get; set; }

    /// <summary>
    /// Whether this process instance has a related incident or not.
    /// </summary>
    [JsonPropertyName("hasIncident")]
    public bool HasIncident { get; set; }

    /// <summary>
    /// The unique identifier of the tenant.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId TenantId { get; set; }

    /// <summary>
    /// The key of this process instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey ProcessInstanceKey { get; set; }

    /// <summary>
    /// The process definition key.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The parent process instance key.
    /// </summary>
    [JsonPropertyName("parentProcessInstanceKey")]
    public ProcessInstanceKey? ParentProcessInstanceKey { get; set; }

    /// <summary>
    /// The parent element instance key.
    /// </summary>
    [JsonPropertyName("parentElementInstanceKey")]
    public ElementInstanceKey? ParentElementInstanceKey { get; set; }

    /// <summary>
    /// System-generated key for a process instance.
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public ProcessInstanceKey? RootProcessInstanceKey { get; set; }

    /// <summary>
    /// List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
    /// </summary>
    [JsonPropertyName("tags")]
    public List<string>? Tags { get; set; }

}

/// <summary>
/// Process instance sequence flows query response.
/// </summary>
public sealed class GetProcessInstanceSequenceFlowsResponse
{
    /// <summary>
    /// The sequence flows.
    /// </summary>
    [JsonPropertyName("items")]
    public List<ProcessInstanceSequenceFlowResult>? Items { get; set; }

}

/// <summary>
/// GetStartProcessFormResponse
/// </summary>
public sealed class GetStartProcessFormResponse
{
    /// <summary>
    /// The tenant ID of the form.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The user-provided identifier of the form.
    /// </summary>
    [JsonPropertyName("formId")]
    public FormId? FormId { get; set; }

    /// <summary>
    /// The form content.
    /// </summary>
    [JsonPropertyName("schema")]
    public object? Schema { get; set; }

    /// <summary>
    /// The version of the the deployed form.
    /// </summary>
    [JsonPropertyName("version")]
    public long? Version { get; set; }

    /// <summary>
    /// The assigned key, which acts as a unique identifier for this form.
    /// </summary>
    [JsonPropertyName("formKey")]
    public object? FormKey { get; set; }

}

/// <summary>
/// GetUserTaskFormResponse
/// </summary>
public sealed class GetUserTaskFormResponse
{
    /// <summary>
    /// The tenant ID of the form.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The user-provided identifier of the form.
    /// </summary>
    [JsonPropertyName("formId")]
    public FormId? FormId { get; set; }

    /// <summary>
    /// The form content.
    /// </summary>
    [JsonPropertyName("schema")]
    public object? Schema { get; set; }

    /// <summary>
    /// The version of the the deployed form.
    /// </summary>
    [JsonPropertyName("version")]
    public long? Version { get; set; }

    /// <summary>
    /// The assigned key, which acts as a unique identifier for this form.
    /// </summary>
    [JsonPropertyName("formKey")]
    public object? FormKey { get; set; }

}

/// <summary>
/// GetUserTaskResponse
/// </summary>
public sealed class GetUserTaskResponse
{
    /// <summary>
    /// The name for this user task.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// The state of the user task.
    /// </summary>
    [JsonPropertyName("state")]
    public UserTaskStateEnum? State { get; set; }

    /// <summary>
    /// The assignee of the user task.
    /// </summary>
    [JsonPropertyName("assignee")]
    public string? Assignee { get; set; }

    /// <summary>
    /// The element ID of the user task.
    /// </summary>
    [JsonPropertyName("elementId")]
    public ElementId? ElementId { get; set; }

    /// <summary>
    /// The candidate groups for this user task.
    /// </summary>
    [JsonPropertyName("candidateGroups")]
    public List<string>? CandidateGroups { get; set; }

    /// <summary>
    /// The candidate users for this user task.
    /// </summary>
    [JsonPropertyName("candidateUsers")]
    public List<string>? CandidateUsers { get; set; }

    /// <summary>
    /// The ID of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionId")]
    public ProcessDefinitionId? ProcessDefinitionId { get; set; }

    /// <summary>
    /// The creation date of a user task.
    /// </summary>
    [JsonPropertyName("creationDate")]
    public DateTimeOffset? CreationDate { get; set; }

    /// <summary>
    /// The completion date of a user task.
    /// </summary>
    [JsonPropertyName("completionDate")]
    public DateTimeOffset? CompletionDate { get; set; }

    /// <summary>
    /// The follow date of a user task.
    /// </summary>
    [JsonPropertyName("followUpDate")]
    public DateTimeOffset? FollowUpDate { get; set; }

    /// <summary>
    /// The due date of a user task.
    /// </summary>
    [JsonPropertyName("dueDate")]
    public DateTimeOffset? DueDate { get; set; }

    /// <summary>
    /// The unique identifier of the tenant.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The external form reference.
    /// </summary>
    [JsonPropertyName("externalFormReference")]
    public string? ExternalFormReference { get; set; }

    /// <summary>
    /// The version of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionVersion")]
    public int? ProcessDefinitionVersion { get; set; }

    /// <summary>
    /// Custom headers for the user task.
    /// </summary>
    [JsonPropertyName("customHeaders")]
    public Dictionary<string, string>? CustomHeaders { get; set; }

    /// <summary>
    /// The priority of a user task. The higher the value the higher the priority.
    /// </summary>
    [JsonPropertyName("priority")]
    public int? Priority { get; set; }

    /// <summary>
    /// The key of the user task.
    /// </summary>
    [JsonPropertyName("userTaskKey")]
    public UserTaskKey? UserTaskKey { get; set; }

    /// <summary>
    /// The key of the element instance.
    /// </summary>
    [JsonPropertyName("elementInstanceKey")]
    public ElementInstanceKey? ElementInstanceKey { get; set; }

    /// <summary>
    /// The name of the process definition.
    /// </summary>
    [JsonPropertyName("processName")]
    public string? ProcessName { get; set; }

    /// <summary>
    /// The key of the process definition.
    /// </summary>
    [JsonPropertyName("processDefinitionKey")]
    public ProcessDefinitionKey? ProcessDefinitionKey { get; set; }

    /// <summary>
    /// The key of the process instance.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// System-generated key for a process instance.
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public ProcessInstanceKey? RootProcessInstanceKey { get; set; }

    /// <summary>
    /// The key of the form.
    /// </summary>
    [JsonPropertyName("formKey")]
    public object? FormKey { get; set; }

    /// <summary>
    /// List of tags. Tags need to start with a letter; then alphanumerics, `_`, `-`, `:`, or `.`; length â‰¤ 100.
    /// </summary>
    [JsonPropertyName("tags")]
    public List<string>? Tags { get; set; }

}

/// <summary>
/// Variable search response item.
/// </summary>
public sealed class GetVariableResponse
{
    /// <summary>
    /// Full value of this variable.
    /// </summary>
    [JsonPropertyName("value")]
    public string? Value { get; set; }

    /// <summary>
    /// Name of this variable.
    /// </summary>
    [JsonPropertyName("name")]
    public string? Name { get; set; }

    /// <summary>
    /// Tenant ID of this variable.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The key for this variable.
    /// </summary>
    [JsonPropertyName("variableKey")]
    public VariableKey? VariableKey { get; set; }

    /// <summary>
    /// The key of the scope of this variable.
    /// </summary>
    [JsonPropertyName("scopeKey")]
    public ScopeKey? ScopeKey { get; set; }

    /// <summary>
    /// The key of the process instance of this variable.
    /// </summary>
    [JsonPropertyName("processInstanceKey")]
    public ProcessInstanceKey? ProcessInstanceKey { get; set; }

    /// <summary>
    /// System-generated key for a process instance.
    /// </summary>
    [JsonPropertyName("rootProcessInstanceKey")]
    public ProcessInstanceKey? RootProcessInstanceKey { get; set; }

}

/// <summary>
/// The migration instructions describe how to migrate a process instance from one process definition to another.
/// 
/// </summary>
public sealed class MigrateProcessInstanceRequest
{
    /// <summary>
    /// The key of process definition to migrate the process instance to.
    /// </summary>
    [JsonPropertyName("targetProcessDefinitionKey")]
    public ProcessDefinitionKey TargetProcessDefinitionKey { get; set; }

    /// <summary>
    /// Element mappings from the source process instance to the target process instance.
    /// </summary>
    [JsonPropertyName("mappingInstructions")]
    public List<MigrateProcessInstanceMappingInstruction> MappingInstructions { get; set; } = null!;

    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public long? OperationReference { get; set; }

}

/// <summary>
/// MigrateProcessInstancesBatchOperationRequest
/// </summary>
public sealed class MigrateProcessInstancesBatchOperationRequest
{
    /// <summary>
    /// The process instance filter.
    /// </summary>
    [JsonPropertyName("filter")]
    public ProcessInstanceFilter Filter { get; set; } = null!;

    /// <summary>
    /// The migration plan.
    /// </summary>
    [JsonPropertyName("migrationPlan")]
    public ProcessInstanceMigrationBatchOperationPlan MigrationPlan { get; set; } = null!;

    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public long? OperationReference { get; set; }

}

/// <summary>
/// ModifyProcessInstanceRequest
/// </summary>
public sealed class ModifyProcessInstanceRequest
{
    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public long? OperationReference { get; set; }

    /// <summary>
    /// Instructions describing which elements to activate in which scopes and which variables to create or update.
    /// </summary>
    [JsonPropertyName("activateInstructions")]
    public List<ProcessInstanceModificationActivateInstruction>? ActivateInstructions { get; set; }

    /// <summary>
    /// Instructions describing which elements to move from one scope to another.
    /// </summary>
    [JsonPropertyName("moveInstructions")]
    public List<ProcessInstanceModificationMoveInstruction>? MoveInstructions { get; set; }

    /// <summary>
    /// Instructions describing which elements to terminate.
    /// </summary>
    [JsonPropertyName("terminateInstructions")]
    public List<ProcessInstanceModificationTerminateInstruction>? TerminateInstructions { get; set; }

}

/// <summary>
/// The process instance filter to define on which process instances tokens should be moved,
/// and new element instances should be activated or terminated.
/// 
/// </summary>
public sealed class ModifyProcessInstancesBatchOperationRequest
{
    /// <summary>
    /// The process instance filter.
    /// </summary>
    [JsonPropertyName("filter")]
    public ProcessInstanceFilter Filter { get; set; } = null!;

    /// <summary>
    /// Instructions for moving tokens between elements.
    /// </summary>
    [JsonPropertyName("moveInstructions")]
    public List<ProcessInstanceModificationMoveBatchOperationInstruction> MoveInstructions { get; set; } = null!;

    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public long? OperationReference { get; set; }

}

/// <summary>
/// The message key of the published message.
/// </summary>
public sealed class PublishMessageResponse
{
    /// <summary>
    /// The tenant ID of the message.
    /// </summary>
    [JsonPropertyName("tenantId")]
    public TenantId? TenantId { get; set; }

    /// <summary>
    /// The key of the published message.
    /// </summary>
    [JsonPropertyName("messageKey")]
    public object? MessageKey { get; set; }

}

/// <summary>
/// The process instance filter that defines which process instances should have their incidents resolved.
/// </summary>
public sealed class ResolveIncidentsBatchOperationRequest
{
    /// <summary>
    /// The process instance filter.
    /// </summary>
    [JsonPropertyName("filter")]
    public ProcessInstanceFilter Filter { get; set; } = null!;

    /// <summary>
    /// A reference key chosen by the user that will be part of all records resulting from this operation.
    /// Must be &gt; 0 if provided.
    /// 
    /// </summary>
    [JsonPropertyName("operationReference")]
    public long? OperationReference { get; set; }

}

/// <summary>
/// Audit log search response.
/// </summary>
public sealed class SearchAuditLogsResponse
{
    /// <summary>
    /// The matching audit logs.
    /// </summary>
    [JsonPropertyName("items")]
    public List<AuditLogResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// Batch operation item search request.
/// </summary>
public sealed class SearchBatchOperationItemsRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<BatchOperationItemSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The batch operation item search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public object? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// SearchBatchOperationItemsResponse
/// </summary>
public sealed class SearchBatchOperationItemsResponse
{
    /// <summary>
    /// The matching batch operation items.
    /// </summary>
    [JsonPropertyName("items")]
    public List<BatchOperationItemResponse>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// Batch operation search request.
/// </summary>
public sealed class SearchBatchOperationsRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<BatchOperationSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The batch operation search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public object? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// SearchClientsForGroupRequest
/// </summary>
public sealed class SearchClientsForGroupRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<TenantClientSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// SearchClientsForRoleRequest
/// </summary>
public sealed class SearchClientsForRoleRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<TenantClientSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public object? Page { get; set; }

}

/// <summary>
/// SearchClientsForTenantRequest
/// </summary>
public sealed class SearchClientsForTenantRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<TenantClientSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public object? Page { get; set; }

}

/// <summary>
/// SearchCorrelatedMessageSubscriptionsResponse
/// </summary>
public sealed class SearchCorrelatedMessageSubscriptionsResponse
{
    /// <summary>
    /// The matching correlated message subscriptions.
    /// </summary>
    [JsonPropertyName("items")]
    public List<CorrelatedMessageSubscriptionResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// SearchDecisionInstancesResponse
/// </summary>
public sealed class SearchDecisionInstancesResponse
{
    /// <summary>
    /// The matching decision instances.
    /// </summary>
    [JsonPropertyName("items")]
    public List<DecisionInstanceResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// SearchElementInstanceIncidentsResponse
/// </summary>
public sealed class SearchElementInstanceIncidentsResponse
{
    /// <summary>
    /// The matching incidents.
    /// </summary>
    [JsonPropertyName("items")]
    public List<IncidentResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// SearchElementInstancesResponse
/// </summary>
public sealed class SearchElementInstancesResponse
{
    /// <summary>
    /// The matching element instances.
    /// </summary>
    [JsonPropertyName("items")]
    public List<ElementInstanceResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// SearchGroupIdsForTenantRequest
/// </summary>
public sealed class SearchGroupIdsForTenantRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<TenantGroupSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public object? Page { get; set; }

}

/// <summary>
/// SearchGroupsForRoleRequest
/// </summary>
public sealed class SearchGroupsForRoleRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<RoleGroupSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public object? Page { get; set; }

}

/// <summary>
/// SearchIncidentsResponse
/// </summary>
public sealed class SearchIncidentsResponse
{
    /// <summary>
    /// The matching incidents.
    /// </summary>
    [JsonPropertyName("items")]
    public List<IncidentResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// Job search response.
/// </summary>
public sealed class SearchJobsResponse
{
    /// <summary>
    /// The matching jobs.
    /// </summary>
    [JsonPropertyName("items")]
    public List<JobSearchResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// SearchMessageSubscriptionsRequest
/// </summary>
public sealed class SearchMessageSubscriptionsRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<MessageSubscriptionSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The incident search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public MessageSubscriptionFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public object? Page { get; set; }

}

/// <summary>
/// SearchMessageSubscriptionsResponse
/// </summary>
public sealed class SearchMessageSubscriptionsResponse
{
    /// <summary>
    /// The matching message subscriptions.
    /// </summary>
    [JsonPropertyName("items")]
    public List<MessageSubscriptionResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// SearchProcessDefinitionsRequest
/// </summary>
public sealed class SearchProcessDefinitionsRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<ProcessDefinitionSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The process definition search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public ProcessDefinitionFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public object? Page { get; set; }

}

/// <summary>
/// SearchProcessInstanceIncidentsResponse
/// </summary>
public sealed class SearchProcessInstanceIncidentsResponse
{
    /// <summary>
    /// The matching incidents.
    /// </summary>
    [JsonPropertyName("items")]
    public List<IncidentResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// Process instance search request.
/// </summary>
public sealed class SearchProcessInstancesRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<ProcessInstanceSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The process instance search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public ProcessInstanceFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public object? Page { get; set; }

}

/// <summary>
/// Process instance search response.
/// </summary>
public sealed class SearchProcessInstancesResponse
{
    /// <summary>
    /// The matching process instances.
    /// </summary>
    [JsonPropertyName("items")]
    public List<ProcessInstanceResult> Items { get; set; } = null!;

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// Tenant search request
/// </summary>
public sealed class SearchTenantsRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<TenantSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The tenant search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public TenantFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public object? Page { get; set; }

}

/// <summary>
/// SearchUsersForGroupRequest
/// </summary>
public sealed class SearchUsersForGroupRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<TenantUserSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageRequest? Page { get; set; }

}

/// <summary>
/// SearchUsersForRoleRequest
/// </summary>
public sealed class SearchUsersForRoleRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<TenantUserSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public object? Page { get; set; }

}

/// <summary>
/// SearchUsersForTenantRequest
/// </summary>
public sealed class SearchUsersForTenantRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<TenantUserSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public object? Page { get; set; }

}

/// <summary>
/// SearchUsersRequest
/// </summary>
public sealed class SearchUsersRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<UserSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The user search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public UserFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public object? Page { get; set; }

}

/// <summary>
/// User task search query request.
/// </summary>
public sealed class SearchUserTaskAuditLogsRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<AuditLogSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The user task audit log search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public UserTaskAuditLogFilter? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public object? Page { get; set; }

}

/// <summary>
/// Audit log search response.
/// </summary>
public sealed class SearchUserTaskAuditLogsResponse
{
    /// <summary>
    /// The matching audit logs.
    /// </summary>
    [JsonPropertyName("items")]
    public List<AuditLogResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// User task search query request.
/// </summary>
public sealed class SearchUserTasksRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<UserTaskSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The user task search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public object? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public object? Page { get; set; }

}

/// <summary>
/// User task search query response.
/// </summary>
public sealed class SearchUserTasksResponse
{
    /// <summary>
    /// The matching user tasks.
    /// </summary>
    [JsonPropertyName("items")]
    public List<UserTaskResult>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// User task search query request.
/// </summary>
public sealed class SearchUserTaskVariablesRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<VariableSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The user task variable search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public object? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public object? Page { get; set; }

}

/// <summary>
/// Variable search query response.
/// </summary>
public sealed class SearchUserTaskVariablesResponse
{
    /// <summary>
    /// The matching variables.
    /// </summary>
    [JsonPropertyName("items")]
    public List<object>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

/// <summary>
/// Variable search query request.
/// </summary>
public sealed class SearchVariablesRequest
{
    /// <summary>
    /// Sort field criteria.
    /// </summary>
    [JsonPropertyName("sort")]
    public List<VariableSearchQuerySortRequest>? Sort { get; set; }

    /// <summary>
    /// The variable search filters.
    /// </summary>
    [JsonPropertyName("filter")]
    public object? Filter { get; set; }

    /// <summary>
    /// Pagination criteria.
    /// </summary>
    [JsonPropertyName("page")]
    public object? Page { get; set; }

}

/// <summary>
/// Variable search query response.
/// </summary>
public sealed class SearchVariablesResponse
{
    /// <summary>
    /// The matching variables.
    /// </summary>
    [JsonPropertyName("items")]
    public List<object>? Items { get; set; }

    /// <summary>
    /// Pagination information about the search results.
    /// </summary>
    [JsonPropertyName("page")]
    public SearchQueryPageResponse Page { get; set; } = null!;

}

