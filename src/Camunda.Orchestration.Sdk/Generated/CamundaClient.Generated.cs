// <auto-generated />
// Generated from OpenAPI spec. DO NOT EDIT.

#nullable enable

using Camunda.Orchestration.Sdk.Api;
using Camunda.Orchestration.Sdk.Runtime;

namespace Camunda.Orchestration.Sdk;

public partial class CamundaClient
{
    /// <summary>
    /// Activate activities within an ad-hoc sub-process
    /// Activates selected activities within an ad-hoc sub-process identified by element ID.
    /// The provided element IDs must exist within the ad-hoc sub-process instance identified by the
    /// provided adHocSubProcessInstanceKey.
    /// 
    /// </summary>
    /// <remarks>Operation: activateAdHocSubProcessActivities</remarks>
    public async Task ActivateAdHocSubProcessActivitiesAsync(ElementInstanceKey adHocSubProcessInstanceKey, AdHocSubProcessActivateActivitiesInstruction body, CancellationToken ct = default)
    {
        var path = $"/element-instances/ad-hoc-activities/{Uri.EscapeDataString(adHocSubProcessInstanceKey.ToString()!)}/activation";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Post, path, body, ct); return 0; }, "activateAdHocSubProcessActivities", false, ct);
    }

    /// <summary>
    /// Activate jobs
    /// Iterate through all known partitions and activate jobs up to the requested maximum.
    /// 
    /// </summary>
    /// <remarks>Operation: activateJobs</remarks>
    public async Task<ActivateJobsResponse> ActivateJobsAsync(JobActivationRequest body, CancellationToken ct = default)
    {
        var path = $"/jobs/activation";
        return await InvokeWithRetryAsync(() => SendAsync<ActivateJobsResponse>(HttpMethod.Post, path, body, ct), "activateJobs", false, ct);
    }

    /// <summary>
    /// Assign a client to a group
    /// Assigns a client to a group, making it a member of the group.
    /// Members of the group inherit the group authorizations, roles, and tenant assignments.
    /// 
    /// </summary>
    /// <remarks>Operation: assignClientToGroup</remarks>
    public async Task AssignClientToGroupAsync(string groupId, string clientId, CancellationToken ct = default)
    {
        var path = $"/groups/{Uri.EscapeDataString(groupId.ToString()!)}/clients/{Uri.EscapeDataString(clientId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Put, path, null, ct); return 0; }, "assignClientToGroup", false, ct);
    }

    /// <summary>
    /// Assign a client to a tenant
    /// Assign the client to the specified tenant.
    /// The client can then access tenant data and perform authorized actions.
    /// 
    /// </summary>
    /// <remarks>Operation: assignClientToTenant</remarks>
    public async Task AssignClientToTenantAsync(TenantId tenantId, string clientId, CancellationToken ct = default)
    {
        var path = $"/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}/clients/{Uri.EscapeDataString(clientId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Put, path, null, ct); return 0; }, "assignClientToTenant", false, ct);
    }

    /// <summary>
    /// Assign a group to a tenant
    /// Assigns a group to a specified tenant.
    /// Group members (users, clients) can then access tenant data and perform authorized actions.
    /// 
    /// </summary>
    /// <remarks>Operation: assignGroupToTenant</remarks>
    public async Task AssignGroupToTenantAsync(TenantId tenantId, string groupId, CancellationToken ct = default)
    {
        var path = $"/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}/groups/{Uri.EscapeDataString(groupId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Put, path, null, ct); return 0; }, "assignGroupToTenant", false, ct);
    }

    /// <summary>
    /// Assign a mapping rule to a group
    /// Assigns a mapping rule to a group.
    /// </summary>
    /// <remarks>Operation: assignMappingRuleToGroup</remarks>
    public async Task AssignMappingRuleToGroupAsync(string groupId, string mappingRuleId, CancellationToken ct = default)
    {
        var path = $"/groups/{Uri.EscapeDataString(groupId.ToString()!)}/mapping-rules/{Uri.EscapeDataString(mappingRuleId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Put, path, null, ct); return 0; }, "assignMappingRuleToGroup", false, ct);
    }

    /// <summary>
    /// Assign a mapping rule to a tenant
    /// Assign a single mapping rule to a specified tenant.
    /// </summary>
    /// <remarks>Operation: assignMappingRuleToTenant</remarks>
    public async Task AssignMappingRuleToTenantAsync(TenantId tenantId, string mappingRuleId, CancellationToken ct = default)
    {
        var path = $"/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}/mapping-rules/{Uri.EscapeDataString(mappingRuleId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Put, path, null, ct); return 0; }, "assignMappingRuleToTenant", false, ct);
    }

    /// <summary>
    /// Assign a role to a client
    /// Assigns the specified role to the client. The client will inherit the authorizations associated with this role.
    /// </summary>
    /// <remarks>Operation: assignRoleToClient</remarks>
    public async Task AssignRoleToClientAsync(string roleId, string clientId, CancellationToken ct = default)
    {
        var path = $"/roles/{Uri.EscapeDataString(roleId.ToString()!)}/clients/{Uri.EscapeDataString(clientId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Put, path, null, ct); return 0; }, "assignRoleToClient", false, ct);
    }

    /// <summary>
    /// Assign a role to a group
    /// Assigns the specified role to the group. Every member of the group (user or client) will inherit the authorizations associated with this role.
    /// </summary>
    /// <remarks>Operation: assignRoleToGroup</remarks>
    public async Task AssignRoleToGroupAsync(string roleId, string groupId, CancellationToken ct = default)
    {
        var path = $"/roles/{Uri.EscapeDataString(roleId.ToString()!)}/groups/{Uri.EscapeDataString(groupId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Put, path, null, ct); return 0; }, "assignRoleToGroup", false, ct);
    }

    /// <summary>
    /// Assign a role to a mapping rule
    /// Assigns a role to a mapping rule.
    /// </summary>
    /// <remarks>Operation: assignRoleToMappingRule</remarks>
    public async Task AssignRoleToMappingRuleAsync(string roleId, string mappingRuleId, CancellationToken ct = default)
    {
        var path = $"/roles/{Uri.EscapeDataString(roleId.ToString()!)}/mapping-rules/{Uri.EscapeDataString(mappingRuleId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Put, path, null, ct); return 0; }, "assignRoleToMappingRule", false, ct);
    }

    /// <summary>
    /// Assign a role to a tenant
    /// Assigns a role to a specified tenant.
    /// Users, Clients or Groups, that have the role assigned, will get access to the tenant's data and can perform actions according to their authorizations.
    /// 
    /// </summary>
    /// <remarks>Operation: assignRoleToTenant</remarks>
    public async Task AssignRoleToTenantAsync(TenantId tenantId, string roleId, CancellationToken ct = default)
    {
        var path = $"/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}/roles/{Uri.EscapeDataString(roleId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Put, path, null, ct); return 0; }, "assignRoleToTenant", false, ct);
    }

    /// <summary>
    /// Assign a role to a user
    /// Assigns the specified role to the user. The user will inherit the authorizations associated with this role.
    /// </summary>
    /// <remarks>Operation: assignRoleToUser</remarks>
    public async Task AssignRoleToUserAsync(string roleId, Username username, CancellationToken ct = default)
    {
        var path = $"/roles/{Uri.EscapeDataString(roleId.ToString()!)}/users/{Uri.EscapeDataString(username.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Put, path, null, ct); return 0; }, "assignRoleToUser", false, ct);
    }

    /// <summary>
    /// Assign user task
    /// Assigns a user task with the given key to the given assignee.
    /// </summary>
    /// <remarks>Operation: assignUserTask</remarks>
    public async Task AssignUserTaskAsync(UserTaskKey userTaskKey, UserTaskAssignmentRequest body, CancellationToken ct = default)
    {
        var path = $"/user-tasks/{Uri.EscapeDataString(userTaskKey.ToString()!)}/assignment";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Post, path, body, ct); return 0; }, "assignUserTask", false, ct);
    }

    /// <summary>
    /// Assign a user to a group
    /// Assigns a user to a group, making the user a member of the group.
    /// Group members inherit the group authorizations, roles, and tenant assignments.
    /// 
    /// </summary>
    /// <remarks>Operation: assignUserToGroup</remarks>
    public async Task AssignUserToGroupAsync(string groupId, Username username, CancellationToken ct = default)
    {
        var path = $"/groups/{Uri.EscapeDataString(groupId.ToString()!)}/users/{Uri.EscapeDataString(username.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Put, path, null, ct); return 0; }, "assignUserToGroup", false, ct);
    }

    /// <summary>
    /// Assign a user to a tenant
    /// Assign a single user to a specified tenant. The user can then access tenant data and perform authorized actions.
    /// </summary>
    /// <remarks>Operation: assignUserToTenant</remarks>
    public async Task AssignUserToTenantAsync(TenantId tenantId, Username username, CancellationToken ct = default)
    {
        var path = $"/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}/users/{Uri.EscapeDataString(username.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Put, path, null, ct); return 0; }, "assignUserToTenant", false, ct);
    }

    /// <summary>
    /// Broadcast signal
    /// Broadcasts a signal.
    /// </summary>
    /// <remarks>Operation: broadcastSignal</remarks>
    public async Task<SignalBroadcastResult> BroadcastSignalAsync(SignalBroadcastRequest body, CancellationToken ct = default)
    {
        var path = $"/signals/broadcast";
        if (body is Runtime.ITenantIdSettable __t) __t.SetDefaultTenantId(_config.DefaultTenantId);
        return await InvokeWithRetryAsync(() => SendAsync<SignalBroadcastResult>(HttpMethod.Post, path, body, ct), "broadcastSignal", false, ct);
    }

    /// <summary>
    /// Cancel Batch operation
    /// Cancels a running batch operation.
    /// This is done asynchronously, the progress can be tracked using the batch operation status endpoint (/batch-operations/{batchOperationKey}).
    /// 
    /// </summary>
    /// <remarks>Operation: cancelBatchOperation</remarks>
    public async Task CancelBatchOperationAsync(BatchOperationKey batchOperationKey, ConsistencyOptions<object>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/batch-operations/{Uri.EscapeDataString(batchOperationKey.ToString()!)}/cancellation";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            await EventualPoller.PollAsync("cancelBatchOperation", false,
                async () => { await SendVoidAsync(HttpMethod.Post, path, null, ct); return new object(); },
                consistency!, _logger, ct);
            return;
        }

        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Post, path, null, ct); return 0; }, "cancelBatchOperation", false, ct);
    }

    /// <summary>
    /// Cancel process instance
    /// Cancels a running process instance. As a cancellation includes more than just the removal of the process instance resource, the cancellation resource must be posted.
    /// </summary>
    /// <remarks>Operation: cancelProcessInstance</remarks>
    public async Task CancelProcessInstanceAsync(ProcessInstanceKey processInstanceKey, CancelProcessInstanceRequest body, CancellationToken ct = default)
    {
        var path = $"/process-instances/{Uri.EscapeDataString(processInstanceKey.ToString()!)}/cancellation";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Post, path, body, ct); return 0; }, "cancelProcessInstance", false, ct);
    }

    /// <summary>
    /// Cancel process instances (batch)
    /// Cancels multiple running process instances.
    /// Since only ACTIVE root instances can be cancelled, any given filters for state and
    /// parentProcessInstanceKey are ignored and overridden during this batch operation.
    /// This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
    /// 
    /// </summary>
    /// <remarks>Operation: cancelProcessInstancesBatchOperation</remarks>
    public async Task<BatchOperationCreatedResult> CancelProcessInstancesBatchOperationAsync(CancelProcessInstancesBatchOperationRequest body, ConsistencyOptions<BatchOperationCreatedResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-instances/cancellation";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("cancelProcessInstancesBatchOperation", false,
                () => InvokeWithRetryAsync(() => SendAsync<BatchOperationCreatedResult>(HttpMethod.Post, path, body, ct), "cancelProcessInstancesBatchOperation", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<BatchOperationCreatedResult>(HttpMethod.Post, path, body, ct), "cancelProcessInstancesBatchOperation", false, ct);
    }

    /// <summary>
    /// Complete job
    /// Complete a job with the given payload, which allows completing the associated service task.
    /// 
    /// </summary>
    /// <remarks>Operation: completeJob</remarks>
    public async Task CompleteJobAsync(JobKey jobKey, JobCompletionRequest body, CancellationToken ct = default)
    {
        var path = $"/jobs/{Uri.EscapeDataString(jobKey.ToString()!)}/completion";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Post, path, body, ct); return 0; }, "completeJob", true, ct);
    }

    /// <summary>
    /// Complete user task
    /// Completes a user task with the given key.
    /// </summary>
    /// <remarks>Operation: completeUserTask</remarks>
    public async Task CompleteUserTaskAsync(UserTaskKey userTaskKey, UserTaskCompletionRequest body, CancellationToken ct = default)
    {
        var path = $"/user-tasks/{Uri.EscapeDataString(userTaskKey.ToString()!)}/completion";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Post, path, body, ct); return 0; }, "completeUserTask", true, ct);
    }

    /// <summary>
    /// Correlate message
    /// Publishes a message and correlates it to a subscription.
    /// If correlation is successful it will return the first process instance key the message correlated with.
    /// The message is not buffered.
    /// Use the publish message endpoint to send messages that can be buffered.
    /// 
    /// </summary>
    /// <remarks>Operation: correlateMessage</remarks>
    public async Task<MessageCorrelationResult> CorrelateMessageAsync(MessageCorrelationRequest body, CancellationToken ct = default)
    {
        var path = $"/messages/correlation";
        if (body is Runtime.ITenantIdSettable __t) __t.SetDefaultTenantId(_config.DefaultTenantId);
        return await InvokeWithRetryAsync(() => SendAsync<MessageCorrelationResult>(HttpMethod.Post, path, body, ct), "correlateMessage", false, ct);
    }

    /// <summary>
    /// Create admin user
    /// Creates a new user and assigns the admin role to it. This endpoint is only usable when users are managed in the Orchestration Cluster and while no user is assigned to the admin role.
    /// </summary>
    /// <remarks>Operation: createAdminUser</remarks>
    public async Task<object> CreateAdminUserAsync(UserRequest body, ConsistencyOptions<object>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/setup/user";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("createAdminUser", false,
                () => InvokeWithRetryAsync(() => SendAsync<object>(HttpMethod.Post, path, body, ct), "createAdminUser", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<object>(HttpMethod.Post, path, body, ct), "createAdminUser", false, ct);
    }

    /// <summary>
    /// Create authorization
    /// Create the authorization.
    /// </summary>
    /// <remarks>Operation: createAuthorization</remarks>
    public async Task<AuthorizationCreateResult> CreateAuthorizationAsync(AuthorizationRequest body, CancellationToken ct = default)
    {
        var path = $"/authorizations";
        return await InvokeWithRetryAsync(() => SendAsync<AuthorizationCreateResult>(HttpMethod.Post, path, body, ct), "createAuthorization", false, ct);
    }

    /// <summary>
    /// Deploy resources
    /// Deploys one or more resources (e.g. processes, decision models, or forms).
    /// This is an atomic call, i.e. either all resources are deployed or none of them are.
    /// 
    /// </summary>
    /// <remarks>Operation: createDeployment</remarks>
    public async Task<CreateDeploymentResponse> CreateDeploymentAsync(MultipartFormDataContent content, CancellationToken ct = default)
    {
        var path = $"/deployments";
        return await InvokeWithRetryAsync(() => SendMultipartAsync<CreateDeploymentResponse>(path, content, ct), "createDeployment", false, ct);
    }

    /// <summary>
    /// Upload document
    /// Upload a document to the Camunda 8 cluster.
    /// 
    /// Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
    /// 
    /// </summary>
    /// <remarks>Operation: createDocument</remarks>
    public async Task<DocumentReference> CreateDocumentAsync(MultipartFormDataContent content, string? storeId = null, DocumentId? documentId = null, CancellationToken ct = default)
    {
        var queryParts = new List<string>();
        if (storeId != null) queryParts.Add($"storeId={Uri.EscapeDataString(storeId.ToString()!)}");
        if (documentId != null) queryParts.Add($"documentId={Uri.EscapeDataString(documentId.ToString()!)}");
        var path = queryParts.Count > 0 ? $"/documents?{string.Join("&", queryParts)}" : $"/documents";
        return await InvokeWithRetryAsync(() => SendMultipartAsync<DocumentReference>(path, content, ct), "createDocument", false, ct);
    }

    /// <summary>
    /// Create document link
    /// Create a link to a document in the Camunda 8 cluster.
    /// 
    /// Note that this is currently supported for document stores of type: AWS, GCP
    /// 
    /// </summary>
    /// <remarks>Operation: createDocumentLink</remarks>
    public async Task<DocumentLink> CreateDocumentLinkAsync(DocumentId documentId, DocumentLinkRequest body, string? storeId = null, string? contentHash = null, CancellationToken ct = default)
    {
        var queryParts = new List<string>();
        if (storeId != null) queryParts.Add($"storeId={Uri.EscapeDataString(storeId.ToString()!)}");
        if (contentHash != null) queryParts.Add($"contentHash={Uri.EscapeDataString(contentHash.ToString()!)}");
        var path = queryParts.Count > 0 ? $"/documents/{Uri.EscapeDataString(documentId.ToString()!)}/links?{string.Join("&", queryParts)}" : $"/documents/{Uri.EscapeDataString(documentId.ToString()!)}/links";
        return await InvokeWithRetryAsync(() => SendAsync<DocumentLink>(HttpMethod.Post, path, body, ct), "createDocumentLink", false, ct);
    }

    /// <summary>
    /// Upload multiple documents
    /// Upload multiple documents to the Camunda 8 cluster.
    /// 
    /// The caller must provide a file name for each document, which will be used in case of a multi-status response
    /// to identify which documents failed to upload. The file name can be provided in the `Content-Disposition` header
    /// of the file part or in the `fileName` field of the metadata. You can add a parallel array of metadata objects. These
    /// are matched with the files based on index, and must have the same length as the files array.
    /// To pass homogenous metadata for all files, spread the metadata over the metadata array.
    /// A filename value provided explicitly via the metadata array in the request overrides the `Content-Disposition` header
    /// of the file part.
    /// 
    /// In case of a multi-status response, the response body will contain a list of `DocumentBatchProblemDetail` objects,
    /// each of which contains the file name of the document that failed to upload and the reason for the failure.
    /// The client can choose to retry the whole batch or individual documents based on the response.
    /// 
    /// Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
    /// 
    /// </summary>
    /// <remarks>Operation: createDocuments</remarks>
    public async Task<DocumentCreationBatchResponse> CreateDocumentsAsync(MultipartFormDataContent content, string? storeId = null, CancellationToken ct = default)
    {
        var queryParts = new List<string>();
        if (storeId != null) queryParts.Add($"storeId={Uri.EscapeDataString(storeId.ToString()!)}");
        var path = queryParts.Count > 0 ? $"/documents/batch?{string.Join("&", queryParts)}" : $"/documents/batch";
        return await InvokeWithRetryAsync(() => SendMultipartAsync<DocumentCreationBatchResponse>(path, content, ct), "createDocuments", false, ct);
    }

    /// <summary>
    /// Update element instance variables
    /// Updates all the variables of a particular scope (for example, process instance, element instance) with the given variable data.
    /// Specify the element instance in the `elementInstanceKey` parameter.
    /// 
    /// </summary>
    /// <remarks>Operation: createElementInstanceVariables</remarks>
    public async Task CreateElementInstanceVariablesAsync(ElementInstanceKey elementInstanceKey, SetVariableRequest body, CancellationToken ct = default)
    {
        var path = $"/element-instances/{Uri.EscapeDataString(elementInstanceKey.ToString()!)}/variables";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Put, path, body, ct); return 0; }, "createElementInstanceVariables", false, ct);
    }

    /// <summary>
    /// Create a global-scoped cluster variable
    /// </summary>
    /// <remarks>Operation: createGlobalClusterVariable</remarks>
    public async Task<ClusterVariableResult> CreateGlobalClusterVariableAsync(CreateClusterVariableRequest body, CancellationToken ct = default)
    {
        var path = $"/cluster-variables/global";
        return await InvokeWithRetryAsync(() => SendAsync<ClusterVariableResult>(HttpMethod.Post, path, body, ct), "createGlobalClusterVariable", false, ct);
    }

    /// <summary>
    /// Create group
    /// Create a new group.
    /// </summary>
    /// <remarks>Operation: createGroup</remarks>
    public async Task<GroupCreateResult> CreateGroupAsync(GroupCreateRequest body, CancellationToken ct = default)
    {
        var path = $"/groups";
        return await InvokeWithRetryAsync(() => SendAsync<GroupCreateResult>(HttpMethod.Post, path, body, ct), "createGroup", false, ct);
    }

    /// <summary>
    /// Create mapping rule
    /// Create a new mapping rule
    /// 
    /// </summary>
    /// <remarks>Operation: createMappingRule</remarks>
    public async Task<MappingRuleUpdateResult> CreateMappingRuleAsync(MappingRuleCreateRequest body, CancellationToken ct = default)
    {
        var path = $"/mapping-rules";
        return await InvokeWithRetryAsync(() => SendAsync<MappingRuleUpdateResult>(HttpMethod.Post, path, body, ct), "createMappingRule", false, ct);
    }

    /// <summary>
    /// Create process instance
    /// Creates and starts an instance of the specified process.
    /// The process definition to use to create the instance can be specified either using its unique key
    /// (as returned by Deploy resources), or using the BPMN process id and a version.
    /// 
    /// Waits for the completion of the process instance before returning a result
    /// when awaitCompletion is enabled.
    /// 
    /// </summary>
    /// <remarks>Operation: createProcessInstance</remarks>
    public async Task<CreateProcessInstanceResult> CreateProcessInstanceAsync(ProcessInstanceCreationInstruction body, CancellationToken ct = default)
    {
        var path = $"/process-instances";
        if (body is Runtime.ITenantIdSettable __t) __t.SetDefaultTenantId(_config.DefaultTenantId);
        return await InvokeWithRetryAsync(() => SendAsync<CreateProcessInstanceResult>(HttpMethod.Post, path, body, ct), "createProcessInstance", false, ct);
    }

    /// <summary>
    /// Create role
    /// Create a new role.
    /// </summary>
    /// <remarks>Operation: createRole</remarks>
    public async Task<RoleCreateResult> CreateRoleAsync(RoleCreateRequest body, CancellationToken ct = default)
    {
        var path = $"/roles";
        return await InvokeWithRetryAsync(() => SendAsync<RoleCreateResult>(HttpMethod.Post, path, body, ct), "createRole", false, ct);
    }

    /// <summary>
    /// Create tenant
    /// Creates a new tenant.
    /// </summary>
    /// <remarks>Operation: createTenant</remarks>
    public async Task<TenantCreateResult> CreateTenantAsync(TenantCreateRequest body, CancellationToken ct = default)
    {
        var path = $"/tenants";
        return await InvokeWithRetryAsync(() => SendAsync<TenantCreateResult>(HttpMethod.Post, path, body, ct), "createTenant", false, ct);
    }

    /// <summary>
    /// Create a tenant-scoped cluster variable
    /// </summary>
    /// <remarks>Operation: createTenantClusterVariable</remarks>
    public async Task<ClusterVariableResult> CreateTenantClusterVariableAsync(TenantId tenantId, CreateClusterVariableRequest body, CancellationToken ct = default)
    {
        var path = $"/cluster-variables/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}";
        return await InvokeWithRetryAsync(() => SendAsync<ClusterVariableResult>(HttpMethod.Post, path, body, ct), "createTenantClusterVariable", false, ct);
    }

    /// <summary>
    /// Create user
    /// Create a new user.
    /// </summary>
    /// <remarks>Operation: createUser</remarks>
    public async Task<UserCreateResult> CreateUserAsync(UserRequest body, ConsistencyOptions<UserCreateResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/users";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("createUser", false,
                () => InvokeWithRetryAsync(() => SendAsync<UserCreateResult>(HttpMethod.Post, path, body, ct), "createUser", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<UserCreateResult>(HttpMethod.Post, path, body, ct), "createUser", false, ct);
    }

    /// <summary>
    /// Delete authorization
    /// Deletes the authorization with the given key.
    /// </summary>
    /// <remarks>Operation: deleteAuthorization</remarks>
    public async Task DeleteAuthorizationAsync(AuthorizationKey authorizationKey, CancellationToken ct = default)
    {
        var path = $"/authorizations/{Uri.EscapeDataString(authorizationKey.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "deleteAuthorization", false, ct);
    }

    /// <summary>
    /// Delete decision instance
    /// Delete all associated decision evaluations based on provided key.
    /// </summary>
    /// <remarks>Operation: deleteDecisionInstance</remarks>
    public async Task DeleteDecisionInstanceAsync(DecisionInstanceKey decisionInstanceKey, DeleteProcessInstanceRequest body, ConsistencyOptions<object>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/decision-instances/{Uri.EscapeDataString(decisionInstanceKey.ToString()!)}/deletion";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            await EventualPoller.PollAsync("deleteDecisionInstance", false,
                async () => { await SendVoidAsync(HttpMethod.Post, path, body, ct); return new object(); },
                consistency!, _logger, ct);
            return;
        }

        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Post, path, body, ct); return 0; }, "deleteDecisionInstance", false, ct);
    }

    /// <summary>
    /// Delete decision instances (batch)
    /// Delete multiple decision instances. This will delete the historic data from secondary storage.
    /// This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
    /// 
    /// </summary>
    /// <remarks>Operation: deleteDecisionInstancesBatchOperation</remarks>
    public async Task<BatchOperationCreatedResult> DeleteDecisionInstancesBatchOperationAsync(DecisionInstanceDeletionBatchOperationRequest body, ConsistencyOptions<BatchOperationCreatedResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/decision-instances/deletion";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("deleteDecisionInstancesBatchOperation", false,
                () => InvokeWithRetryAsync(() => SendAsync<BatchOperationCreatedResult>(HttpMethod.Post, path, body, ct), "deleteDecisionInstancesBatchOperation", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<BatchOperationCreatedResult>(HttpMethod.Post, path, body, ct), "deleteDecisionInstancesBatchOperation", false, ct);
    }

    /// <summary>
    /// Delete document
    /// Delete a document from the Camunda 8 cluster.
    /// 
    /// Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
    /// 
    /// </summary>
    /// <remarks>Operation: deleteDocument</remarks>
    public async Task DeleteDocumentAsync(DocumentId documentId, string? storeId = null, CancellationToken ct = default)
    {
        var queryParts = new List<string>();
        if (storeId != null) queryParts.Add($"storeId={Uri.EscapeDataString(storeId.ToString()!)}");
        var path = queryParts.Count > 0 ? $"/documents/{Uri.EscapeDataString(documentId.ToString()!)}?{string.Join("&", queryParts)}" : $"/documents/{Uri.EscapeDataString(documentId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "deleteDocument", false, ct);
    }

    /// <summary>
    /// Delete a global-scoped cluster variable
    /// </summary>
    /// <remarks>Operation: deleteGlobalClusterVariable</remarks>
    public async Task DeleteGlobalClusterVariableAsync(string name, CancellationToken ct = default)
    {
        var path = $"/cluster-variables/global/{Uri.EscapeDataString(name.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "deleteGlobalClusterVariable", false, ct);
    }

    /// <summary>
    /// Delete group
    /// Deletes the group with the given ID.
    /// </summary>
    /// <remarks>Operation: deleteGroup</remarks>
    public async Task DeleteGroupAsync(string groupId, CancellationToken ct = default)
    {
        var path = $"/groups/{Uri.EscapeDataString(groupId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "deleteGroup", false, ct);
    }

    /// <summary>
    /// Delete a mapping rule
    /// Deletes the mapping rule with the given ID.
    /// 
    /// </summary>
    /// <remarks>Operation: deleteMappingRule</remarks>
    public async Task DeleteMappingRuleAsync(string mappingRuleId, CancellationToken ct = default)
    {
        var path = $"/mapping-rules/{Uri.EscapeDataString(mappingRuleId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "deleteMappingRule", false, ct);
    }

    /// <summary>
    /// Delete process instance
    /// Deletes a process instance. Only instances that are completed or terminated can be deleted.
    /// </summary>
    /// <remarks>Operation: deleteProcessInstance</remarks>
    public async Task DeleteProcessInstanceAsync(ProcessInstanceKey processInstanceKey, DeleteProcessInstanceRequest body, ConsistencyOptions<object>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-instances/{Uri.EscapeDataString(processInstanceKey.ToString()!)}/deletion";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            await EventualPoller.PollAsync("deleteProcessInstance", false,
                async () => { await SendVoidAsync(HttpMethod.Post, path, body, ct); return new object(); },
                consistency!, _logger, ct);
            return;
        }

        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Post, path, body, ct); return 0; }, "deleteProcessInstance", false, ct);
    }

    /// <summary>
    /// Delete process instances (batch)
    /// Delete multiple process instances. This will delete the historic data from secondary storage.
    /// Only process instances in a final state (COMPLETED or TERMINATED) can be deleted.
    /// This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
    /// 
    /// </summary>
    /// <remarks>Operation: deleteProcessInstancesBatchOperation</remarks>
    public async Task<BatchOperationCreatedResult> DeleteProcessInstancesBatchOperationAsync(DeleteProcessInstancesBatchOperationRequest body, ConsistencyOptions<BatchOperationCreatedResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-instances/deletion";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("deleteProcessInstancesBatchOperation", false,
                () => InvokeWithRetryAsync(() => SendAsync<BatchOperationCreatedResult>(HttpMethod.Post, path, body, ct), "deleteProcessInstancesBatchOperation", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<BatchOperationCreatedResult>(HttpMethod.Post, path, body, ct), "deleteProcessInstancesBatchOperation", false, ct);
    }

    /// <summary>
    /// Delete resource
    /// Deletes a deployed resource. This can be a process definition, decision requirements
    /// definition, or form definition deployed using the deploy resources endpoint. Specify the
    /// resource you want to delete in the `resourceKey` parameter.
    /// 
    /// Once a resource has been deleted it cannot be recovered. If the resource needs to be
    /// available again, a new deployment of the resource is required.
    /// 
    /// By default, only the resource itself is deleted from the runtime state. To also delete the
    /// historic data associated with a resource, set the `deleteHistory` flag in the request body
    /// to `true`. The historic data is deleted asynchronously via a batch operation. The details of
    /// the created batch operation are included in the response. Note that history deletion is only
    /// supported for process resources; for other resource types this flag is ignored and no history
    /// will be deleted.
    /// </summary>
    /// <remarks>Operation: deleteResource</remarks>
    public async Task<DeleteResourceResponse> DeleteResourceAsync(ResourceKey resourceKey, DeleteResourceRequest body, CancellationToken ct = default)
    {
        var path = $"/resources/{Uri.EscapeDataString(resourceKey.ToString()!)}/deletion";
        return await InvokeWithRetryAsync(() => SendAsync<DeleteResourceResponse>(HttpMethod.Post, path, body, ct), "deleteResource", false, ct);
    }

    /// <summary>
    /// Delete role
    /// Deletes the role with the given ID.
    /// </summary>
    /// <remarks>Operation: deleteRole</remarks>
    public async Task DeleteRoleAsync(string roleId, CancellationToken ct = default)
    {
        var path = $"/roles/{Uri.EscapeDataString(roleId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "deleteRole", false, ct);
    }

    /// <summary>
    /// Delete tenant
    /// Deletes an existing tenant.
    /// </summary>
    /// <remarks>Operation: deleteTenant</remarks>
    public async Task DeleteTenantAsync(TenantId tenantId, CancellationToken ct = default)
    {
        var path = $"/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "deleteTenant", false, ct);
    }

    /// <summary>
    /// Delete a tenant-scoped cluster variable
    /// </summary>
    /// <remarks>Operation: deleteTenantClusterVariable</remarks>
    public async Task DeleteTenantClusterVariableAsync(TenantId tenantId, string name, CancellationToken ct = default)
    {
        var path = $"/cluster-variables/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}/{Uri.EscapeDataString(name.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "deleteTenantClusterVariable", false, ct);
    }

    /// <summary>
    /// Delete user
    /// Deletes a user.
    /// </summary>
    /// <remarks>Operation: deleteUser</remarks>
    public async Task DeleteUserAsync(Username username, ConsistencyOptions<object>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/users/{Uri.EscapeDataString(username.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            await EventualPoller.PollAsync("deleteUser", false,
                async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return new object(); },
                consistency!, _logger, ct);
            return;
        }

        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "deleteUser", false, ct);
    }

    /// <summary>
    /// Evaluate root level conditional start events
    /// Evaluates root-level conditional start events for process definitions.
    /// If the evaluation is successful, it will return the keys of all created process instances, along with their associated process definition key.
    /// Multiple root-level conditional start events of the same process definition can trigger if their conditions evaluate to true.
    /// 
    /// </summary>
    /// <remarks>Operation: evaluateConditionals</remarks>
    public async Task<EvaluateConditionalResult> EvaluateConditionalsAsync(ConditionalEvaluationInstruction body, CancellationToken ct = default)
    {
        var path = $"/conditionals/evaluation";
        if (body is Runtime.ITenantIdSettable __t) __t.SetDefaultTenantId(_config.DefaultTenantId);
        return await InvokeWithRetryAsync(() => SendAsync<EvaluateConditionalResult>(HttpMethod.Post, path, body, ct), "evaluateConditionals", false, ct);
    }

    /// <summary>
    /// Evaluate decision
    /// Evaluates a decision.
    /// You specify the decision to evaluate either by using its unique key (as returned by
    /// DeployResource), or using the decision ID. When using the decision ID, the latest deployed
    /// version of the decision is used.
    /// 
    /// </summary>
    /// <remarks>Operation: evaluateDecision</remarks>
    public async Task<EvaluateDecisionResult> EvaluateDecisionAsync(DecisionEvaluationInstruction body, CancellationToken ct = default)
    {
        var path = $"/decision-definitions/evaluation";
        if (body is Runtime.ITenantIdSettable __t) __t.SetDefaultTenantId(_config.DefaultTenantId);
        return await InvokeWithRetryAsync(() => SendAsync<EvaluateDecisionResult>(HttpMethod.Post, path, body, ct), "evaluateDecision", false, ct);
    }

    /// <summary>
    /// Evaluate an expression
    /// Evaluates a FEEL expression and returns the result. Supports references to tenant scoped cluster variables when a tenant ID is provided.
    /// </summary>
    /// <remarks>Operation: evaluateExpression</remarks>
    public async Task<ExpressionEvaluationResult> EvaluateExpressionAsync(ExpressionEvaluationRequest body, CancellationToken ct = default)
    {
        var path = $"/expression/evaluation";
        if (body is Runtime.ITenantIdSettable __t) __t.SetDefaultTenantId(_config.DefaultTenantId);
        return await InvokeWithRetryAsync(() => SendAsync<ExpressionEvaluationResult>(HttpMethod.Post, path, body, ct), "evaluateExpression", false, ct);
    }

    /// <summary>
    /// Fail job
    /// Mark the job as failed.
    /// 
    /// </summary>
    /// <remarks>Operation: failJob</remarks>
    public async Task FailJobAsync(JobKey jobKey, JobFailRequest body, CancellationToken ct = default)
    {
        var path = $"/jobs/{Uri.EscapeDataString(jobKey.ToString()!)}/failure";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Post, path, body, ct); return 0; }, "failJob", true, ct);
    }

    /// <summary>
    /// Get audit log
    /// Get an audit log entry by auditLogKey.
    /// </summary>
    /// <remarks>Operation: getAuditLog</remarks>
    public async Task<GetAuditLogResponse> GetAuditLogAsync(AuditLogKey auditLogKey, ConsistencyOptions<GetAuditLogResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/audit-logs/{Uri.EscapeDataString(auditLogKey.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getAuditLog", true,
                () => InvokeWithRetryAsync(() => SendAsync<GetAuditLogResponse>(HttpMethod.Get, path, null, ct), "getAuditLog", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<GetAuditLogResponse>(HttpMethod.Get, path, null, ct), "getAuditLog", false, ct);
    }

    /// <summary>
    /// Get current user
    /// Retrieves the current authenticated user.
    /// </summary>
    /// <remarks>Operation: getAuthentication</remarks>
    public async Task<CamundaUserResult> GetAuthenticationAsync(CancellationToken ct = default)
    {
        var path = $"/authentication/me";
        return await InvokeWithRetryAsync(() => SendAsync<CamundaUserResult>(HttpMethod.Get, path, null, ct), "getAuthentication", false, ct);
    }

    /// <summary>
    /// Get authorization
    /// Get authorization by the given key.
    /// </summary>
    /// <remarks>Operation: getAuthorization</remarks>
    public async Task<AuthorizationResult> GetAuthorizationAsync(AuthorizationKey authorizationKey, ConsistencyOptions<AuthorizationResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/authorizations/{Uri.EscapeDataString(authorizationKey.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getAuthorization", true,
                () => InvokeWithRetryAsync(() => SendAsync<AuthorizationResult>(HttpMethod.Get, path, null, ct), "getAuthorization", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<AuthorizationResult>(HttpMethod.Get, path, null, ct), "getAuthorization", false, ct);
    }

    /// <summary>
    /// Get batch operation
    /// Get batch operation by key.
    /// </summary>
    /// <remarks>Operation: getBatchOperation</remarks>
    public async Task<BatchOperationResponse> GetBatchOperationAsync(BatchOperationKey batchOperationKey, ConsistencyOptions<BatchOperationResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/batch-operations/{Uri.EscapeDataString(batchOperationKey.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getBatchOperation", true,
                () => InvokeWithRetryAsync(() => SendAsync<BatchOperationResponse>(HttpMethod.Get, path, null, ct), "getBatchOperation", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<BatchOperationResponse>(HttpMethod.Get, path, null, ct), "getBatchOperation", false, ct);
    }

    /// <summary>
    /// Get decision definition
    /// Returns a decision definition by key.
    /// </summary>
    /// <remarks>Operation: getDecisionDefinition</remarks>
    public async Task<DecisionDefinitionResult> GetDecisionDefinitionAsync(DecisionDefinitionKey decisionDefinitionKey, ConsistencyOptions<DecisionDefinitionResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/decision-definitions/{Uri.EscapeDataString(decisionDefinitionKey.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getDecisionDefinition", true,
                () => InvokeWithRetryAsync(() => SendAsync<DecisionDefinitionResult>(HttpMethod.Get, path, null, ct), "getDecisionDefinition", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<DecisionDefinitionResult>(HttpMethod.Get, path, null, ct), "getDecisionDefinition", false, ct);
    }

    /// <summary>
    /// Get decision definition XML
    /// Returns decision definition as XML.
    /// </summary>
    /// <remarks>Operation: getDecisionDefinitionXML</remarks>
    public async Task<object> GetDecisionDefinitionXmlAsync(DecisionDefinitionKey decisionDefinitionKey, ConsistencyOptions<object>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/decision-definitions/{Uri.EscapeDataString(decisionDefinitionKey.ToString()!)}/xml";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getDecisionDefinitionXML", true,
                () => InvokeWithRetryAsync(() => SendAsync<object>(HttpMethod.Get, path, null, ct), "getDecisionDefinitionXML", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<object>(HttpMethod.Get, path, null, ct), "getDecisionDefinitionXML", false, ct);
    }

    /// <summary>
    /// Get decision instance
    /// Returns a decision instance.
    /// </summary>
    /// <remarks>Operation: getDecisionInstance</remarks>
    public async Task<object> GetDecisionInstanceAsync(DecisionInstanceKey decisionEvaluationInstanceKey, ConsistencyOptions<object>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/decision-instances/{Uri.EscapeDataString(decisionEvaluationInstanceKey.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getDecisionInstance", true,
                () => InvokeWithRetryAsync(() => SendAsync<object>(HttpMethod.Get, path, null, ct), "getDecisionInstance", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<object>(HttpMethod.Get, path, null, ct), "getDecisionInstance", false, ct);
    }

    /// <summary>
    /// Get decision requirements
    /// Returns Decision Requirements as JSON.
    /// </summary>
    /// <remarks>Operation: getDecisionRequirements</remarks>
    public async Task<DecisionRequirementsResult> GetDecisionRequirementsAsync(DecisionRequirementsKey decisionRequirementsKey, ConsistencyOptions<DecisionRequirementsResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/decision-requirements/{Uri.EscapeDataString(decisionRequirementsKey.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getDecisionRequirements", true,
                () => InvokeWithRetryAsync(() => SendAsync<DecisionRequirementsResult>(HttpMethod.Get, path, null, ct), "getDecisionRequirements", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<DecisionRequirementsResult>(HttpMethod.Get, path, null, ct), "getDecisionRequirements", false, ct);
    }

    /// <summary>
    /// Get decision requirements XML
    /// Returns decision requirements as XML.
    /// </summary>
    /// <remarks>Operation: getDecisionRequirementsXML</remarks>
    public async Task<object> GetDecisionRequirementsXmlAsync(DecisionRequirementsKey decisionRequirementsKey, ConsistencyOptions<object>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/decision-requirements/{Uri.EscapeDataString(decisionRequirementsKey.ToString()!)}/xml";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getDecisionRequirementsXML", true,
                () => InvokeWithRetryAsync(() => SendAsync<object>(HttpMethod.Get, path, null, ct), "getDecisionRequirementsXML", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<object>(HttpMethod.Get, path, null, ct), "getDecisionRequirementsXML", false, ct);
    }

    /// <summary>
    /// Download document
    /// Download a document from the Camunda 8 cluster.
    /// 
    /// Note that this is currently supported for document stores of type: AWS, GCP, in-memory (non-production), local (non-production)
    /// 
    /// </summary>
    /// <remarks>Operation: getDocument</remarks>
    public async Task<object> GetDocumentAsync(DocumentId documentId, string? storeId = null, string? contentHash = null, CancellationToken ct = default)
    {
        var queryParts = new List<string>();
        if (storeId != null) queryParts.Add($"storeId={Uri.EscapeDataString(storeId.ToString()!)}");
        if (contentHash != null) queryParts.Add($"contentHash={Uri.EscapeDataString(contentHash.ToString()!)}");
        var path = queryParts.Count > 0 ? $"/documents/{Uri.EscapeDataString(documentId.ToString()!)}?{string.Join("&", queryParts)}" : $"/documents/{Uri.EscapeDataString(documentId.ToString()!)}";
        return await InvokeWithRetryAsync(() => SendAsync<object>(HttpMethod.Get, path, null, ct), "getDocument", false, ct);
    }

    /// <summary>
    /// Get element instance
    /// Returns element instance as JSON.
    /// </summary>
    /// <remarks>Operation: getElementInstance</remarks>
    public async Task<GetElementInstanceResponse> GetElementInstanceAsync(ElementInstanceKey elementInstanceKey, ConsistencyOptions<GetElementInstanceResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/element-instances/{Uri.EscapeDataString(elementInstanceKey.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getElementInstance", true,
                () => InvokeWithRetryAsync(() => SendAsync<GetElementInstanceResponse>(HttpMethod.Get, path, null, ct), "getElementInstance", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<GetElementInstanceResponse>(HttpMethod.Get, path, null, ct), "getElementInstance", false, ct);
    }

    /// <summary>
    /// Get a global-scoped cluster variable
    /// </summary>
    /// <remarks>Operation: getGlobalClusterVariable</remarks>
    public async Task<ClusterVariableResult> GetGlobalClusterVariableAsync(string name, ConsistencyOptions<ClusterVariableResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/cluster-variables/global/{Uri.EscapeDataString(name.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getGlobalClusterVariable", true,
                () => InvokeWithRetryAsync(() => SendAsync<ClusterVariableResult>(HttpMethod.Get, path, null, ct), "getGlobalClusterVariable", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<ClusterVariableResult>(HttpMethod.Get, path, null, ct), "getGlobalClusterVariable", false, ct);
    }

    /// <summary>
    /// Global job statistics
    /// Returns global aggregated counts for jobs. Optionally filter by the creation time window and/or jobType.
    /// 
    /// </summary>
    /// <remarks>Operation: getGlobalJobStatistics</remarks>
    public async Task<GlobalJobStatisticsQueryResult> GetGlobalJobStatisticsAsync(DateTimeOffset from, DateTimeOffset to, string? jobType = null, ConsistencyOptions<GlobalJobStatisticsQueryResult>? consistency = null, CancellationToken ct = default)
    {
        var queryParts = new List<string>();
        queryParts.Add($"from={Uri.EscapeDataString(from.ToString()!)}");
        queryParts.Add($"to={Uri.EscapeDataString(to.ToString()!)}");
        if (jobType != null) queryParts.Add($"jobType={Uri.EscapeDataString(jobType.ToString()!)}");
        var path = queryParts.Count > 0 ? $"/jobs/statistics/global?{string.Join("&", queryParts)}" : $"/jobs/statistics/global";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getGlobalJobStatistics", true,
                () => InvokeWithRetryAsync(() => SendAsync<GlobalJobStatisticsQueryResult>(HttpMethod.Get, path, null, ct), "getGlobalJobStatistics", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<GlobalJobStatisticsQueryResult>(HttpMethod.Get, path, null, ct), "getGlobalJobStatistics", false, ct);
    }

    /// <summary>
    /// Get group
    /// Get a group by its ID.
    /// </summary>
    /// <remarks>Operation: getGroup</remarks>
    public async Task<GroupResult> GetGroupAsync(string groupId, ConsistencyOptions<GroupResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/groups/{Uri.EscapeDataString(groupId.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getGroup", true,
                () => InvokeWithRetryAsync(() => SendAsync<GroupResult>(HttpMethod.Get, path, null, ct), "getGroup", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<GroupResult>(HttpMethod.Get, path, null, ct), "getGroup", false, ct);
    }

    /// <summary>
    /// Get incident
    /// Returns incident as JSON.
    /// 
    /// </summary>
    /// <remarks>Operation: getIncident</remarks>
    public async Task<GetIncidentResponse> GetIncidentAsync(IncidentKey incidentKey, ConsistencyOptions<GetIncidentResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/incidents/{Uri.EscapeDataString(incidentKey.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getIncident", true,
                () => InvokeWithRetryAsync(() => SendAsync<GetIncidentResponse>(HttpMethod.Get, path, null, ct), "getIncident", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<GetIncidentResponse>(HttpMethod.Get, path, null, ct), "getIncident", false, ct);
    }

    /// <summary>
    /// Get license status
    /// Obtains the status of the current Camunda license.
    /// </summary>
    /// <remarks>Operation: getLicense</remarks>
    public async Task<LicenseResponse> GetLicenseAsync(CancellationToken ct = default)
    {
        var path = $"/license";
        return await InvokeWithRetryAsync(() => SendAsync<LicenseResponse>(HttpMethod.Get, path, null, ct), "getLicense", false, ct);
    }

    /// <summary>
    /// Get a mapping rule
    /// Gets the mapping rule with the given ID.
    /// 
    /// </summary>
    /// <remarks>Operation: getMappingRule</remarks>
    public async Task<MappingRuleResult> GetMappingRuleAsync(string mappingRuleId, ConsistencyOptions<MappingRuleResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/mapping-rules/{Uri.EscapeDataString(mappingRuleId.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getMappingRule", true,
                () => InvokeWithRetryAsync(() => SendAsync<MappingRuleResult>(HttpMethod.Get, path, null, ct), "getMappingRule", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<MappingRuleResult>(HttpMethod.Get, path, null, ct), "getMappingRule", false, ct);
    }

    /// <summary>
    /// Get process definition
    /// Returns process definition as JSON.
    /// </summary>
    /// <remarks>Operation: getProcessDefinition</remarks>
    public async Task<ProcessDefinitionResult> GetProcessDefinitionAsync(ProcessDefinitionKey processDefinitionKey, ConsistencyOptions<ProcessDefinitionResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-definitions/{Uri.EscapeDataString(processDefinitionKey.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getProcessDefinition", true,
                () => InvokeWithRetryAsync(() => SendAsync<ProcessDefinitionResult>(HttpMethod.Get, path, null, ct), "getProcessDefinition", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<ProcessDefinitionResult>(HttpMethod.Get, path, null, ct), "getProcessDefinition", false, ct);
    }

    /// <summary>
    /// Get process instance statistics
    /// Get statistics about process instances, grouped by process definition and tenant.
    /// 
    /// </summary>
    /// <remarks>Operation: getProcessDefinitionInstanceStatistics</remarks>
    public async Task<ProcessDefinitionInstanceStatisticsQueryResult> GetProcessDefinitionInstanceStatisticsAsync(ProcessDefinitionInstanceStatisticsQuery body, ConsistencyOptions<ProcessDefinitionInstanceStatisticsQueryResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-definitions/statistics/process-instances";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getProcessDefinitionInstanceStatistics", false,
                () => InvokeWithRetryAsync(() => SendAsync<ProcessDefinitionInstanceStatisticsQueryResult>(HttpMethod.Post, path, body, ct), "getProcessDefinitionInstanceStatistics", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<ProcessDefinitionInstanceStatisticsQueryResult>(HttpMethod.Post, path, body, ct), "getProcessDefinitionInstanceStatistics", false, ct);
    }

    /// <summary>
    /// Get process instance statistics by version
    /// Get statistics about process instances, grouped by version for a given process definition.
    /// The process definition ID must be provided as a required field in the request body filter.
    /// 
    /// </summary>
    /// <remarks>Operation: getProcessDefinitionInstanceVersionStatistics</remarks>
    public async Task<ProcessDefinitionInstanceVersionStatisticsQueryResult> GetProcessDefinitionInstanceVersionStatisticsAsync(ProcessDefinitionInstanceVersionStatisticsQuery body, ConsistencyOptions<ProcessDefinitionInstanceVersionStatisticsQueryResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-definitions/statistics/process-instances-by-version";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getProcessDefinitionInstanceVersionStatistics", false,
                () => InvokeWithRetryAsync(() => SendAsync<ProcessDefinitionInstanceVersionStatisticsQueryResult>(HttpMethod.Post, path, body, ct), "getProcessDefinitionInstanceVersionStatistics", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<ProcessDefinitionInstanceVersionStatisticsQueryResult>(HttpMethod.Post, path, body, ct), "getProcessDefinitionInstanceVersionStatistics", false, ct);
    }

    /// <summary>
    /// Get message subscription statistics
    /// Get message subscription statistics, grouped by process definition.
    /// 
    /// </summary>
    /// <remarks>Operation: getProcessDefinitionMessageSubscriptionStatistics</remarks>
    public async Task<ProcessDefinitionMessageSubscriptionStatisticsQueryResult> GetProcessDefinitionMessageSubscriptionStatisticsAsync(ProcessDefinitionMessageSubscriptionStatisticsQuery body, ConsistencyOptions<ProcessDefinitionMessageSubscriptionStatisticsQueryResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-definitions/statistics/message-subscriptions";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getProcessDefinitionMessageSubscriptionStatistics", false,
                () => InvokeWithRetryAsync(() => SendAsync<ProcessDefinitionMessageSubscriptionStatisticsQueryResult>(HttpMethod.Post, path, body, ct), "getProcessDefinitionMessageSubscriptionStatistics", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<ProcessDefinitionMessageSubscriptionStatisticsQueryResult>(HttpMethod.Post, path, body, ct), "getProcessDefinitionMessageSubscriptionStatistics", false, ct);
    }

    /// <summary>
    /// Get process definition statistics
    /// Get statistics about elements in currently running process instances by process definition key and search filter.
    /// </summary>
    /// <remarks>Operation: getProcessDefinitionStatistics</remarks>
    public async Task<ProcessDefinitionElementStatisticsQueryResult> GetProcessDefinitionStatisticsAsync(ProcessDefinitionKey processDefinitionKey, GetProcessDefinitionStatisticsRequest body, ConsistencyOptions<ProcessDefinitionElementStatisticsQueryResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-definitions/{Uri.EscapeDataString(processDefinitionKey.ToString()!)}/statistics/element-instances";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getProcessDefinitionStatistics", false,
                () => InvokeWithRetryAsync(() => SendAsync<ProcessDefinitionElementStatisticsQueryResult>(HttpMethod.Post, path, body, ct), "getProcessDefinitionStatistics", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<ProcessDefinitionElementStatisticsQueryResult>(HttpMethod.Post, path, body, ct), "getProcessDefinitionStatistics", false, ct);
    }

    /// <summary>
    /// Get process definition XML
    /// Returns process definition as XML.
    /// </summary>
    /// <remarks>Operation: getProcessDefinitionXML</remarks>
    public async Task<object> GetProcessDefinitionXmlAsync(ProcessDefinitionKey processDefinitionKey, ConsistencyOptions<object>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-definitions/{Uri.EscapeDataString(processDefinitionKey.ToString()!)}/xml";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getProcessDefinitionXML", true,
                () => InvokeWithRetryAsync(() => SendAsync<object>(HttpMethod.Get, path, null, ct), "getProcessDefinitionXML", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<object>(HttpMethod.Get, path, null, ct), "getProcessDefinitionXML", false, ct);
    }

    /// <summary>
    /// Get process instance
    /// Get the process instance by the process instance key.
    /// </summary>
    /// <remarks>Operation: getProcessInstance</remarks>
    public async Task<GetProcessInstanceResponse> GetProcessInstanceAsync(ProcessInstanceKey processInstanceKey, ConsistencyOptions<GetProcessInstanceResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-instances/{Uri.EscapeDataString(processInstanceKey.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getProcessInstance", true,
                () => InvokeWithRetryAsync(() => SendAsync<GetProcessInstanceResponse>(HttpMethod.Get, path, null, ct), "getProcessInstance", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<GetProcessInstanceResponse>(HttpMethod.Get, path, null, ct), "getProcessInstance", false, ct);
    }

    /// <summary>
    /// Get call hierarchy
    /// Returns the call hierarchy for a given process instance, showing its ancestry up to the root instance.
    /// </summary>
    /// <remarks>Operation: getProcessInstanceCallHierarchy</remarks>
    public async Task<object> GetProcessInstanceCallHierarchyAsync(ProcessInstanceKey processInstanceKey, ConsistencyOptions<object>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-instances/{Uri.EscapeDataString(processInstanceKey.ToString()!)}/call-hierarchy";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getProcessInstanceCallHierarchy", true,
                () => InvokeWithRetryAsync(() => SendAsync<object>(HttpMethod.Get, path, null, ct), "getProcessInstanceCallHierarchy", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<object>(HttpMethod.Get, path, null, ct), "getProcessInstanceCallHierarchy", false, ct);
    }

    /// <summary>
    /// Get sequence flows
    /// Get sequence flows taken by the process instance.
    /// </summary>
    /// <remarks>Operation: getProcessInstanceSequenceFlows</remarks>
    public async Task<GetProcessInstanceSequenceFlowsResponse> GetProcessInstanceSequenceFlowsAsync(ProcessInstanceKey processInstanceKey, ConsistencyOptions<GetProcessInstanceSequenceFlowsResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-instances/{Uri.EscapeDataString(processInstanceKey.ToString()!)}/sequence-flows";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getProcessInstanceSequenceFlows", true,
                () => InvokeWithRetryAsync(() => SendAsync<GetProcessInstanceSequenceFlowsResponse>(HttpMethod.Get, path, null, ct), "getProcessInstanceSequenceFlows", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<GetProcessInstanceSequenceFlowsResponse>(HttpMethod.Get, path, null, ct), "getProcessInstanceSequenceFlows", false, ct);
    }

    /// <summary>
    /// Get element instance statistics
    /// Get statistics about elements by the process instance key.
    /// </summary>
    /// <remarks>Operation: getProcessInstanceStatistics</remarks>
    public async Task<ProcessInstanceElementStatisticsQueryResult> GetProcessInstanceStatisticsAsync(ProcessInstanceKey processInstanceKey, ConsistencyOptions<ProcessInstanceElementStatisticsQueryResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-instances/{Uri.EscapeDataString(processInstanceKey.ToString()!)}/statistics/element-instances";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getProcessInstanceStatistics", true,
                () => InvokeWithRetryAsync(() => SendAsync<ProcessInstanceElementStatisticsQueryResult>(HttpMethod.Get, path, null, ct), "getProcessInstanceStatistics", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<ProcessInstanceElementStatisticsQueryResult>(HttpMethod.Get, path, null, ct), "getProcessInstanceStatistics", false, ct);
    }

    /// <summary>
    /// Get process instance statistics by definition
    /// Returns statistics for active process instances with incidents, grouped by process
    /// definition. The result set is scoped to a specific incident error hash code, which must be
    /// provided as a filter in the request body.
    /// 
    /// </summary>
    /// <remarks>Operation: getProcessInstanceStatisticsByDefinition</remarks>
    public async Task<IncidentProcessInstanceStatisticsByDefinitionQueryResult> GetProcessInstanceStatisticsByDefinitionAsync(IncidentProcessInstanceStatisticsByDefinitionQuery body, ConsistencyOptions<IncidentProcessInstanceStatisticsByDefinitionQueryResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/incidents/statistics/process-instances-by-definition";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getProcessInstanceStatisticsByDefinition", false,
                () => InvokeWithRetryAsync(() => SendAsync<IncidentProcessInstanceStatisticsByDefinitionQueryResult>(HttpMethod.Post, path, body, ct), "getProcessInstanceStatisticsByDefinition", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<IncidentProcessInstanceStatisticsByDefinitionQueryResult>(HttpMethod.Post, path, body, ct), "getProcessInstanceStatisticsByDefinition", false, ct);
    }

    /// <summary>
    /// Get process instance statistics by error
    /// Returns statistics for active process instances that currently have active incidents,
    /// grouped by incident error hash code.
    /// 
    /// </summary>
    /// <remarks>Operation: getProcessInstanceStatisticsByError</remarks>
    public async Task<IncidentProcessInstanceStatisticsByErrorQueryResult> GetProcessInstanceStatisticsByErrorAsync(IncidentProcessInstanceStatisticsByErrorQuery body, ConsistencyOptions<IncidentProcessInstanceStatisticsByErrorQueryResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/incidents/statistics/process-instances-by-error";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getProcessInstanceStatisticsByError", false,
                () => InvokeWithRetryAsync(() => SendAsync<IncidentProcessInstanceStatisticsByErrorQueryResult>(HttpMethod.Post, path, body, ct), "getProcessInstanceStatisticsByError", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<IncidentProcessInstanceStatisticsByErrorQueryResult>(HttpMethod.Post, path, body, ct), "getProcessInstanceStatisticsByError", false, ct);
    }

    /// <summary>
    /// Get resource
    /// Returns a deployed resource.
    /// :::info
    /// Currently, this endpoint only supports RPA resources.
    /// :::
    /// 
    /// </summary>
    /// <remarks>Operation: getResource</remarks>
    public async Task<ResourceResult> GetResourceAsync(ResourceKey resourceKey, CancellationToken ct = default)
    {
        var path = $"/resources/{Uri.EscapeDataString(resourceKey.ToString()!)}";
        return await InvokeWithRetryAsync(() => SendAsync<ResourceResult>(HttpMethod.Get, path, null, ct), "getResource", false, ct);
    }

    /// <summary>
    /// Get resource content
    /// Returns the content of a deployed resource.
    /// :::info
    /// Currently, this endpoint only supports RPA resources.
    /// :::
    /// 
    /// </summary>
    /// <remarks>Operation: getResourceContent</remarks>
    public async Task<object> GetResourceContentAsync(ResourceKey resourceKey, CancellationToken ct = default)
    {
        var path = $"/resources/{Uri.EscapeDataString(resourceKey.ToString()!)}/content";
        return await InvokeWithRetryAsync(() => SendAsync<object>(HttpMethod.Get, path, null, ct), "getResourceContent", false, ct);
    }

    /// <summary>
    /// Get role
    /// Get a role by its ID.
    /// </summary>
    /// <remarks>Operation: getRole</remarks>
    public async Task<RoleResult> GetRoleAsync(string roleId, ConsistencyOptions<RoleResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/roles/{Uri.EscapeDataString(roleId.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getRole", true,
                () => InvokeWithRetryAsync(() => SendAsync<RoleResult>(HttpMethod.Get, path, null, ct), "getRole", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<RoleResult>(HttpMethod.Get, path, null, ct), "getRole", false, ct);
    }

    /// <summary>
    /// Get process start form
    /// Get the start form of a process.
    /// Note that this endpoint will only return linked forms. This endpoint does not support embedded forms.
    /// 
    /// </summary>
    /// <remarks>Operation: getStartProcessForm</remarks>
    public async Task<GetStartProcessFormResponse> GetStartProcessFormAsync(ProcessDefinitionKey processDefinitionKey, ConsistencyOptions<GetStartProcessFormResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-definitions/{Uri.EscapeDataString(processDefinitionKey.ToString()!)}/form";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getStartProcessForm", true,
                () => InvokeWithRetryAsync(() => SendAsync<GetStartProcessFormResponse>(HttpMethod.Get, path, null, ct), "getStartProcessForm", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<GetStartProcessFormResponse>(HttpMethod.Get, path, null, ct), "getStartProcessForm", false, ct);
    }

    /// <summary>
    /// Get cluster status
    /// Checks the health status of the cluster by verifying if there's at least one partition with a healthy leader.
    /// </summary>
    /// <remarks>Operation: getStatus</remarks>
    public async Task GetStatusAsync(CancellationToken ct = default)
    {
        var path = $"/status";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Get, path, null, ct); return 0; }, "getStatus", false, ct);
    }

    /// <summary>
    /// Get tenant
    /// Retrieves a single tenant by tenant ID.
    /// </summary>
    /// <remarks>Operation: getTenant</remarks>
    public async Task<TenantResult> GetTenantAsync(TenantId tenantId, ConsistencyOptions<TenantResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getTenant", true,
                () => InvokeWithRetryAsync(() => SendAsync<TenantResult>(HttpMethod.Get, path, null, ct), "getTenant", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<TenantResult>(HttpMethod.Get, path, null, ct), "getTenant", false, ct);
    }

    /// <summary>
    /// Get a tenant-scoped cluster variable
    /// </summary>
    /// <remarks>Operation: getTenantClusterVariable</remarks>
    public async Task<ClusterVariableResult> GetTenantClusterVariableAsync(TenantId tenantId, string name, ConsistencyOptions<ClusterVariableResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/cluster-variables/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}/{Uri.EscapeDataString(name.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getTenantClusterVariable", true,
                () => InvokeWithRetryAsync(() => SendAsync<ClusterVariableResult>(HttpMethod.Get, path, null, ct), "getTenantClusterVariable", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<ClusterVariableResult>(HttpMethod.Get, path, null, ct), "getTenantClusterVariable", false, ct);
    }

    /// <summary>
    /// Get cluster topology
    /// Obtains the current topology of the cluster the gateway is part of.
    /// </summary>
    /// <remarks>Operation: getTopology</remarks>
    public async Task<TopologyResponse> GetTopologyAsync(CancellationToken ct = default)
    {
        var path = $"/topology";
        return await InvokeWithRetryAsync(() => SendAsync<TopologyResponse>(HttpMethod.Get, path, null, ct), "getTopology", false, ct);
    }

    /// <summary>
    /// Get usage metrics
    /// Retrieve the usage metrics based on given criteria.
    /// </summary>
    /// <remarks>Operation: getUsageMetrics</remarks>
    public async Task<UsageMetricsResponse> GetUsageMetricsAsync(DateTimeOffset startTime, DateTimeOffset endTime, TenantId? tenantId = null, bool? withTenants = null, ConsistencyOptions<UsageMetricsResponse>? consistency = null, CancellationToken ct = default)
    {
        var queryParts = new List<string>();
        queryParts.Add($"startTime={Uri.EscapeDataString(startTime.ToString()!)}");
        queryParts.Add($"endTime={Uri.EscapeDataString(endTime.ToString()!)}");
        if (tenantId != null) queryParts.Add($"tenantId={Uri.EscapeDataString(tenantId.ToString()!)}");
        if (withTenants != null) queryParts.Add($"withTenants={Uri.EscapeDataString(withTenants.ToString()!)}");
        var path = queryParts.Count > 0 ? $"/system/usage-metrics?{string.Join("&", queryParts)}" : $"/system/usage-metrics";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getUsageMetrics", true,
                () => InvokeWithRetryAsync(() => SendAsync<UsageMetricsResponse>(HttpMethod.Get, path, null, ct), "getUsageMetrics", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<UsageMetricsResponse>(HttpMethod.Get, path, null, ct), "getUsageMetrics", false, ct);
    }

    /// <summary>
    /// Get user
    /// Get a user by its username.
    /// </summary>
    /// <remarks>Operation: getUser</remarks>
    public async Task<UserResult> GetUserAsync(Username username, ConsistencyOptions<UserResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/users/{Uri.EscapeDataString(username.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getUser", true,
                () => InvokeWithRetryAsync(() => SendAsync<UserResult>(HttpMethod.Get, path, null, ct), "getUser", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<UserResult>(HttpMethod.Get, path, null, ct), "getUser", false, ct);
    }

    /// <summary>
    /// Get user task
    /// Get the user task by the user task key.
    /// </summary>
    /// <remarks>Operation: getUserTask</remarks>
    public async Task<GetUserTaskResponse> GetUserTaskAsync(UserTaskKey userTaskKey, ConsistencyOptions<GetUserTaskResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/user-tasks/{Uri.EscapeDataString(userTaskKey.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getUserTask", true,
                () => InvokeWithRetryAsync(() => SendAsync<GetUserTaskResponse>(HttpMethod.Get, path, null, ct), "getUserTask", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<GetUserTaskResponse>(HttpMethod.Get, path, null, ct), "getUserTask", false, ct);
    }

    /// <summary>
    /// Get user task form
    /// Get the form of a user task.
    /// Note that this endpoint will only return linked forms. This endpoint does not support embedded forms.
    /// 
    /// </summary>
    /// <remarks>Operation: getUserTaskForm</remarks>
    public async Task<GetUserTaskFormResponse> GetUserTaskFormAsync(UserTaskKey userTaskKey, ConsistencyOptions<GetUserTaskFormResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/user-tasks/{Uri.EscapeDataString(userTaskKey.ToString()!)}/form";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getUserTaskForm", true,
                () => InvokeWithRetryAsync(() => SendAsync<GetUserTaskFormResponse>(HttpMethod.Get, path, null, ct), "getUserTaskForm", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<GetUserTaskFormResponse>(HttpMethod.Get, path, null, ct), "getUserTaskForm", false, ct);
    }

    /// <summary>
    /// Get variable
    /// Get the variable by the variable key.
    /// </summary>
    /// <remarks>Operation: getVariable</remarks>
    public async Task<GetVariableResponse> GetVariableAsync(VariableKey variableKey, ConsistencyOptions<GetVariableResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/variables/{Uri.EscapeDataString(variableKey.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("getVariable", true,
                () => InvokeWithRetryAsync(() => SendAsync<GetVariableResponse>(HttpMethod.Get, path, null, ct), "getVariable", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<GetVariableResponse>(HttpMethod.Get, path, null, ct), "getVariable", false, ct);
    }

    /// <summary>
    /// Migrate process instance
    /// Migrates a process instance to a new process definition.
    /// This request can contain multiple mapping instructions to define mapping between the active
    /// process instance's elements and target process definition elements.
    /// 
    /// Use this to upgrade a process instance to a new version of a process or to
    /// a different process definition, e.g. to keep your running instances up-to-date with the
    /// latest process improvements.
    /// 
    /// </summary>
    /// <remarks>Operation: migrateProcessInstance</remarks>
    public async Task MigrateProcessInstanceAsync(ProcessInstanceKey processInstanceKey, MigrateProcessInstanceRequest body, CancellationToken ct = default)
    {
        var path = $"/process-instances/{Uri.EscapeDataString(processInstanceKey.ToString()!)}/migration";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Post, path, body, ct); return 0; }, "migrateProcessInstance", false, ct);
    }

    /// <summary>
    /// Migrate process instances (batch)
    /// Migrate multiple process instances.
    /// Since only process instances with ACTIVE state can be migrated, any given
    /// filters for state are ignored and overridden during this batch operation.
    /// This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
    /// 
    /// </summary>
    /// <remarks>Operation: migrateProcessInstancesBatchOperation</remarks>
    public async Task<BatchOperationCreatedResult> MigrateProcessInstancesBatchOperationAsync(MigrateProcessInstancesBatchOperationRequest body, ConsistencyOptions<BatchOperationCreatedResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-instances/migration";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("migrateProcessInstancesBatchOperation", false,
                () => InvokeWithRetryAsync(() => SendAsync<BatchOperationCreatedResult>(HttpMethod.Post, path, body, ct), "migrateProcessInstancesBatchOperation", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<BatchOperationCreatedResult>(HttpMethod.Post, path, body, ct), "migrateProcessInstancesBatchOperation", false, ct);
    }

    /// <summary>
    /// Modify process instance
    /// Modifies a running process instance.
    /// This request can contain multiple instructions to activate an element of the process or
    /// to terminate an active instance of an element.
    /// 
    /// Use this to repair a process instance that is stuck on an element or took an unintended path.
    /// For example, because an external system is not available or doesn't respond as expected.
    /// 
    /// </summary>
    /// <remarks>Operation: modifyProcessInstance</remarks>
    public async Task ModifyProcessInstanceAsync(ProcessInstanceKey processInstanceKey, ModifyProcessInstanceRequest body, CancellationToken ct = default)
    {
        var path = $"/process-instances/{Uri.EscapeDataString(processInstanceKey.ToString()!)}/modification";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Post, path, body, ct); return 0; }, "modifyProcessInstance", false, ct);
    }

    /// <summary>
    /// Modify process instances (batch)
    /// Modify multiple process instances.
    /// Since only process instances with ACTIVE state can be modified, any given
    /// filters for state are ignored and overridden during this batch operation.
    /// In contrast to single modification operation, it is not possible to add variable instructions or modify by element key.
    /// It is only possible to use the element id of the source and target.
    /// This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
    /// 
    /// </summary>
    /// <remarks>Operation: modifyProcessInstancesBatchOperation</remarks>
    public async Task<BatchOperationCreatedResult> ModifyProcessInstancesBatchOperationAsync(ModifyProcessInstancesBatchOperationRequest body, ConsistencyOptions<BatchOperationCreatedResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-instances/modification";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("modifyProcessInstancesBatchOperation", false,
                () => InvokeWithRetryAsync(() => SendAsync<BatchOperationCreatedResult>(HttpMethod.Post, path, body, ct), "modifyProcessInstancesBatchOperation", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<BatchOperationCreatedResult>(HttpMethod.Post, path, body, ct), "modifyProcessInstancesBatchOperation", false, ct);
    }

    /// <summary>
    /// Pin internal clock (alpha)
    /// Set a precise, static time for the Zeebe engine's internal clock.
    /// When the clock is pinned, it remains at the specified time and does not advance.
    /// To change the time, the clock must be pinned again with a new timestamp.
    /// 
    /// This endpoint is an alpha feature and may be subject to change
    /// in future releases.
    /// 
    /// </summary>
    /// <remarks>Operation: pinClock</remarks>
    public async Task PinClockAsync(ClockPinRequest body, CancellationToken ct = default)
    {
        var path = $"/clock";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Put, path, body, ct); return 0; }, "pinClock", false, ct);
    }

    /// <summary>
    /// Publish message
    /// Publishes a single message.
    /// Messages are published to specific partitions computed from their correlation keys.
    /// Messages can be buffered.
    /// The endpoint does not wait for a correlation result.
    /// Use the message correlation endpoint for such use cases.
    /// 
    /// </summary>
    /// <remarks>Operation: publishMessage</remarks>
    public async Task<PublishMessageResponse> PublishMessageAsync(MessagePublicationRequest body, CancellationToken ct = default)
    {
        var path = $"/messages/publication";
        if (body is Runtime.ITenantIdSettable __t) __t.SetDefaultTenantId(_config.DefaultTenantId);
        return await InvokeWithRetryAsync(() => SendAsync<PublishMessageResponse>(HttpMethod.Post, path, body, ct), "publishMessage", false, ct);
    }

    /// <summary>
    /// Reset internal clock (alpha)
    /// Resets the Zeebe engine's internal clock to the current system time, enabling it to tick in real-time.
    /// This operation is useful for returning the clock to
    /// normal behavior after it has been pinned to a specific time.
    /// 
    /// This endpoint is an alpha feature and may be subject to change
    /// in future releases.
    /// 
    /// </summary>
    /// <remarks>Operation: resetClock</remarks>
    public async Task ResetClockAsync(CancellationToken ct = default)
    {
        var path = $"/clock/reset";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Post, path, null, ct); return 0; }, "resetClock", false, ct);
    }

    /// <summary>
    /// Resolve incident
    /// Marks the incident as resolved; most likely a call to Update job will be necessary
    /// to reset the job's retries, followed by this call.
    /// 
    /// </summary>
    /// <remarks>Operation: resolveIncident</remarks>
    public async Task ResolveIncidentAsync(IncidentKey incidentKey, IncidentResolutionRequest body, CancellationToken ct = default)
    {
        var path = $"/incidents/{Uri.EscapeDataString(incidentKey.ToString()!)}/resolution";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Post, path, body, ct); return 0; }, "resolveIncident", false, ct);
    }

    /// <summary>
    /// Resolve related incidents (batch)
    /// Resolves multiple instances of process instances.
    /// Since only process instances with ACTIVE state can have unresolved incidents, any given
    /// filters for state are ignored and overridden during this batch operation.
    /// This is done asynchronously, the progress can be tracked using the batchOperationKey from the response and the batch operation status endpoint (/batch-operations/{batchOperationKey}).
    /// 
    /// </summary>
    /// <remarks>Operation: resolveIncidentsBatchOperation</remarks>
    public async Task<BatchOperationCreatedResult> ResolveIncidentsBatchOperationAsync(ResolveIncidentsBatchOperationRequest body, ConsistencyOptions<BatchOperationCreatedResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-instances/incident-resolution";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("resolveIncidentsBatchOperation", false,
                () => InvokeWithRetryAsync(() => SendAsync<BatchOperationCreatedResult>(HttpMethod.Post, path, body, ct), "resolveIncidentsBatchOperation", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<BatchOperationCreatedResult>(HttpMethod.Post, path, body, ct), "resolveIncidentsBatchOperation", false, ct);
    }

    /// <summary>
    /// Resolve related incidents
    /// Creates a batch operation to resolve multiple incidents of a process instance.
    /// </summary>
    /// <remarks>Operation: resolveProcessInstanceIncidents</remarks>
    public async Task<BatchOperationCreatedResult> ResolveProcessInstanceIncidentsAsync(ProcessInstanceKey processInstanceKey, ConsistencyOptions<BatchOperationCreatedResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-instances/{Uri.EscapeDataString(processInstanceKey.ToString()!)}/incident-resolution";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("resolveProcessInstanceIncidents", false,
                () => InvokeWithRetryAsync(() => SendAsync<BatchOperationCreatedResult>(HttpMethod.Post, path, null, ct), "resolveProcessInstanceIncidents", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<BatchOperationCreatedResult>(HttpMethod.Post, path, null, ct), "resolveProcessInstanceIncidents", false, ct);
    }

    /// <summary>
    /// Resume Batch operation
    /// Resumes a suspended batch operation.
    /// This is done asynchronously, the progress can be tracked using the batch operation status endpoint (/batch-operations/{batchOperationKey}).
    /// 
    /// </summary>
    /// <remarks>Operation: resumeBatchOperation</remarks>
    public async Task ResumeBatchOperationAsync(BatchOperationKey batchOperationKey, ConsistencyOptions<object>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/batch-operations/{Uri.EscapeDataString(batchOperationKey.ToString()!)}/resumption";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            await EventualPoller.PollAsync("resumeBatchOperation", false,
                async () => { await SendVoidAsync(HttpMethod.Post, path, null, ct); return new object(); },
                consistency!, _logger, ct);
            return;
        }

        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Post, path, null, ct); return 0; }, "resumeBatchOperation", false, ct);
    }

    /// <summary>
    /// Search audit logs
    /// Search for audit logs based on given criteria.
    /// </summary>
    /// <remarks>Operation: searchAuditLogs</remarks>
    public async Task<SearchAuditLogsResponse> SearchAuditLogsAsync(AuditLogSearchQueryRequest body, ConsistencyOptions<SearchAuditLogsResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/audit-logs/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchAuditLogs", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchAuditLogsResponse>(HttpMethod.Post, path, body, ct), "searchAuditLogs", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchAuditLogsResponse>(HttpMethod.Post, path, body, ct), "searchAuditLogs", false, ct);
    }

    /// <summary>
    /// Search authorizations
    /// Search for authorizations based on given criteria.
    /// </summary>
    /// <remarks>Operation: searchAuthorizations</remarks>
    public async Task<AuthorizationSearchResult> SearchAuthorizationsAsync(AuthorizationSearchQuery body, ConsistencyOptions<AuthorizationSearchResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/authorizations/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchAuthorizations", false,
                () => InvokeWithRetryAsync(() => SendAsync<AuthorizationSearchResult>(HttpMethod.Post, path, body, ct), "searchAuthorizations", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<AuthorizationSearchResult>(HttpMethod.Post, path, body, ct), "searchAuthorizations", false, ct);
    }

    /// <summary>
    /// Search batch operation items
    /// Search for batch operation items based on given criteria.
    /// </summary>
    /// <remarks>Operation: searchBatchOperationItems</remarks>
    public async Task<SearchBatchOperationItemsResponse> SearchBatchOperationItemsAsync(SearchBatchOperationItemsRequest body, ConsistencyOptions<SearchBatchOperationItemsResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/batch-operation-items/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchBatchOperationItems", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchBatchOperationItemsResponse>(HttpMethod.Post, path, body, ct), "searchBatchOperationItems", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchBatchOperationItemsResponse>(HttpMethod.Post, path, body, ct), "searchBatchOperationItems", false, ct);
    }

    /// <summary>
    /// Search batch operations
    /// Search for batch operations based on given criteria.
    /// </summary>
    /// <remarks>Operation: searchBatchOperations</remarks>
    public async Task<BatchOperationSearchQueryResult> SearchBatchOperationsAsync(SearchBatchOperationsRequest body, ConsistencyOptions<BatchOperationSearchQueryResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/batch-operations/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchBatchOperations", false,
                () => InvokeWithRetryAsync(() => SendAsync<BatchOperationSearchQueryResult>(HttpMethod.Post, path, body, ct), "searchBatchOperations", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<BatchOperationSearchQueryResult>(HttpMethod.Post, path, body, ct), "searchBatchOperations", false, ct);
    }

    /// <summary>
    /// Search group clients
    /// Search clients assigned to a group.
    /// </summary>
    /// <remarks>Operation: searchClientsForGroup</remarks>
    public async Task<TenantClientSearchResult> SearchClientsForGroupAsync(string groupId, SearchClientsForGroupRequest body, ConsistencyOptions<TenantClientSearchResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/groups/{Uri.EscapeDataString(groupId.ToString()!)}/clients/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchClientsForGroup", false,
                () => InvokeWithRetryAsync(() => SendAsync<TenantClientSearchResult>(HttpMethod.Post, path, body, ct), "searchClientsForGroup", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<TenantClientSearchResult>(HttpMethod.Post, path, body, ct), "searchClientsForGroup", false, ct);
    }

    /// <summary>
    /// Search role clients
    /// Search clients with assigned role.
    /// </summary>
    /// <remarks>Operation: searchClientsForRole</remarks>
    public async Task<TenantClientSearchResult> SearchClientsForRoleAsync(string roleId, SearchClientsForRoleRequest body, ConsistencyOptions<TenantClientSearchResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/roles/{Uri.EscapeDataString(roleId.ToString()!)}/clients/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchClientsForRole", false,
                () => InvokeWithRetryAsync(() => SendAsync<TenantClientSearchResult>(HttpMethod.Post, path, body, ct), "searchClientsForRole", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<TenantClientSearchResult>(HttpMethod.Post, path, body, ct), "searchClientsForRole", false, ct);
    }

    /// <summary>
    /// Search clients for tenant
    /// Retrieves a filtered and sorted list of clients for a specified tenant.
    /// </summary>
    /// <remarks>Operation: searchClientsForTenant</remarks>
    public async Task<TenantClientSearchResult> SearchClientsForTenantAsync(TenantId tenantId, SearchClientsForTenantRequest body, ConsistencyOptions<TenantClientSearchResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}/clients/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchClientsForTenant", false,
                () => InvokeWithRetryAsync(() => SendAsync<TenantClientSearchResult>(HttpMethod.Post, path, body, ct), "searchClientsForTenant", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<TenantClientSearchResult>(HttpMethod.Post, path, body, ct), "searchClientsForTenant", false, ct);
    }

    /// <summary>
    /// Search for cluster variables based on given criteria. By default, long variable values in the response are truncated.
    /// </summary>
    /// <remarks>Operation: searchClusterVariables</remarks>
    public async Task<ClusterVariableSearchQueryResult> SearchClusterVariablesAsync(ClusterVariableSearchQueryRequest body, bool? truncateValues = null, ConsistencyOptions<ClusterVariableSearchQueryResult>? consistency = null, CancellationToken ct = default)
    {
        var queryParts = new List<string>();
        if (truncateValues != null) queryParts.Add($"truncateValues={Uri.EscapeDataString(truncateValues.ToString()!)}");
        var path = queryParts.Count > 0 ? $"/cluster-variables/search?{string.Join("&", queryParts)}" : $"/cluster-variables/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchClusterVariables", false,
                () => InvokeWithRetryAsync(() => SendAsync<ClusterVariableSearchQueryResult>(HttpMethod.Post, path, body, ct), "searchClusterVariables", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<ClusterVariableSearchQueryResult>(HttpMethod.Post, path, body, ct), "searchClusterVariables", false, ct);
    }

    /// <summary>
    /// Search correlated message subscriptions
    /// Search correlated message subscriptions based on given criteria.
    /// </summary>
    /// <remarks>Operation: searchCorrelatedMessageSubscriptions</remarks>
    public async Task<SearchCorrelatedMessageSubscriptionsResponse> SearchCorrelatedMessageSubscriptionsAsync(CorrelatedMessageSubscriptionSearchQuery body, ConsistencyOptions<SearchCorrelatedMessageSubscriptionsResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/correlated-message-subscriptions/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchCorrelatedMessageSubscriptions", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchCorrelatedMessageSubscriptionsResponse>(HttpMethod.Post, path, body, ct), "searchCorrelatedMessageSubscriptions", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchCorrelatedMessageSubscriptionsResponse>(HttpMethod.Post, path, body, ct), "searchCorrelatedMessageSubscriptions", false, ct);
    }

    /// <summary>
    /// Search decision definitions
    /// Search for decision definitions based on given criteria.
    /// </summary>
    /// <remarks>Operation: searchDecisionDefinitions</remarks>
    public async Task<DecisionDefinitionSearchQueryResult> SearchDecisionDefinitionsAsync(DecisionDefinitionSearchQuery body, ConsistencyOptions<DecisionDefinitionSearchQueryResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/decision-definitions/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchDecisionDefinitions", false,
                () => InvokeWithRetryAsync(() => SendAsync<DecisionDefinitionSearchQueryResult>(HttpMethod.Post, path, body, ct), "searchDecisionDefinitions", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<DecisionDefinitionSearchQueryResult>(HttpMethod.Post, path, body, ct), "searchDecisionDefinitions", false, ct);
    }

    /// <summary>
    /// Search decision instances
    /// Search for decision instances based on given criteria.
    /// </summary>
    /// <remarks>Operation: searchDecisionInstances</remarks>
    public async Task<SearchDecisionInstancesResponse> SearchDecisionInstancesAsync(DecisionInstanceSearchQuery body, ConsistencyOptions<SearchDecisionInstancesResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/decision-instances/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchDecisionInstances", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchDecisionInstancesResponse>(HttpMethod.Post, path, body, ct), "searchDecisionInstances", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchDecisionInstancesResponse>(HttpMethod.Post, path, body, ct), "searchDecisionInstances", false, ct);
    }

    /// <summary>
    /// Search decision requirements
    /// Search for decision requirements based on given criteria.
    /// </summary>
    /// <remarks>Operation: searchDecisionRequirements</remarks>
    public async Task<DecisionRequirementsSearchQueryResult> SearchDecisionRequirementsAsync(DecisionRequirementsSearchQuery body, ConsistencyOptions<DecisionRequirementsSearchQueryResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/decision-requirements/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchDecisionRequirements", false,
                () => InvokeWithRetryAsync(() => SendAsync<DecisionRequirementsSearchQueryResult>(HttpMethod.Post, path, body, ct), "searchDecisionRequirements", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<DecisionRequirementsSearchQueryResult>(HttpMethod.Post, path, body, ct), "searchDecisionRequirements", false, ct);
    }

    /// <summary>
    /// Search for incidents of a specific element instance
    /// Search for incidents caused by the specified element instance, including incidents of any child instances created from this element instance.
    /// 
    /// Although the `elementInstanceKey` is provided as a path parameter to indicate the root element instance,
    /// you may also include an `elementInstanceKey` within the filter object to narrow results to specific
    /// child element instances. This is useful, for example, if you want to isolate incidents associated with
    /// nested or subordinate elements within the given element instance while excluding incidents directly tied
    /// to the root element itself.
    /// 
    /// </summary>
    /// <remarks>Operation: searchElementInstanceIncidents</remarks>
    public async Task<SearchElementInstanceIncidentsResponse> SearchElementInstanceIncidentsAsync(ElementInstanceKey elementInstanceKey, IncidentSearchQuery body, ConsistencyOptions<SearchElementInstanceIncidentsResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/element-instances/{Uri.EscapeDataString(elementInstanceKey.ToString()!)}/incidents/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchElementInstanceIncidents", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchElementInstanceIncidentsResponse>(HttpMethod.Post, path, body, ct), "searchElementInstanceIncidents", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchElementInstanceIncidentsResponse>(HttpMethod.Post, path, body, ct), "searchElementInstanceIncidents", false, ct);
    }

    /// <summary>
    /// Search element instances
    /// Search for element instances based on given criteria.
    /// </summary>
    /// <remarks>Operation: searchElementInstances</remarks>
    public async Task<SearchElementInstancesResponse> SearchElementInstancesAsync(ElementInstanceSearchQuery body, ConsistencyOptions<SearchElementInstancesResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/element-instances/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchElementInstances", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchElementInstancesResponse>(HttpMethod.Post, path, body, ct), "searchElementInstances", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchElementInstancesResponse>(HttpMethod.Post, path, body, ct), "searchElementInstances", false, ct);
    }

    /// <summary>
    /// Search groups for tenant
    /// Retrieves a filtered and sorted list of groups for a specified tenant.
    /// </summary>
    /// <remarks>Operation: searchGroupIdsForTenant</remarks>
    public async Task<TenantGroupSearchResult> SearchGroupIdsForTenantAsync(TenantId tenantId, SearchGroupIdsForTenantRequest body, ConsistencyOptions<TenantGroupSearchResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}/groups/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchGroupIdsForTenant", false,
                () => InvokeWithRetryAsync(() => SendAsync<TenantGroupSearchResult>(HttpMethod.Post, path, body, ct), "searchGroupIdsForTenant", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<TenantGroupSearchResult>(HttpMethod.Post, path, body, ct), "searchGroupIdsForTenant", false, ct);
    }

    /// <summary>
    /// Search groups
    /// Search for groups based on given criteria.
    /// </summary>
    /// <remarks>Operation: searchGroups</remarks>
    public async Task<GroupSearchQueryResult> SearchGroupsAsync(GroupSearchQueryRequest body, ConsistencyOptions<GroupSearchQueryResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/groups/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchGroups", false,
                () => InvokeWithRetryAsync(() => SendAsync<GroupSearchQueryResult>(HttpMethod.Post, path, body, ct), "searchGroups", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<GroupSearchQueryResult>(HttpMethod.Post, path, body, ct), "searchGroups", false, ct);
    }

    /// <summary>
    /// Search role groups
    /// Search groups with assigned role.
    /// </summary>
    /// <remarks>Operation: searchGroupsForRole</remarks>
    public async Task<RoleGroupSearchResult> SearchGroupsForRoleAsync(string roleId, SearchGroupsForRoleRequest body, ConsistencyOptions<RoleGroupSearchResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/roles/{Uri.EscapeDataString(roleId.ToString()!)}/groups/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchGroupsForRole", false,
                () => InvokeWithRetryAsync(() => SendAsync<RoleGroupSearchResult>(HttpMethod.Post, path, body, ct), "searchGroupsForRole", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<RoleGroupSearchResult>(HttpMethod.Post, path, body, ct), "searchGroupsForRole", false, ct);
    }

    /// <summary>
    /// Search incidents
    /// Search for incidents based on given criteria.
    /// 
    /// </summary>
    /// <remarks>Operation: searchIncidents</remarks>
    public async Task<SearchIncidentsResponse> SearchIncidentsAsync(IncidentSearchQuery body, ConsistencyOptions<SearchIncidentsResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/incidents/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchIncidents", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchIncidentsResponse>(HttpMethod.Post, path, body, ct), "searchIncidents", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchIncidentsResponse>(HttpMethod.Post, path, body, ct), "searchIncidents", false, ct);
    }

    /// <summary>
    /// Search jobs
    /// Search for jobs based on given criteria.
    /// </summary>
    /// <remarks>Operation: searchJobs</remarks>
    public async Task<SearchJobsResponse> SearchJobsAsync(JobSearchQuery body, ConsistencyOptions<SearchJobsResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/jobs/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchJobs", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchJobsResponse>(HttpMethod.Post, path, body, ct), "searchJobs", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchJobsResponse>(HttpMethod.Post, path, body, ct), "searchJobs", false, ct);
    }

    /// <summary>
    /// Search mapping rules
    /// Search for mapping rules based on given criteria.
    /// 
    /// </summary>
    /// <remarks>Operation: searchMappingRule</remarks>
    public async Task<MappingRuleSearchQueryResult> SearchMappingRuleAsync(MappingRuleSearchQueryRequest body, ConsistencyOptions<MappingRuleSearchQueryResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/mapping-rules/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchMappingRule", false,
                () => InvokeWithRetryAsync(() => SendAsync<MappingRuleSearchQueryResult>(HttpMethod.Post, path, body, ct), "searchMappingRule", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<MappingRuleSearchQueryResult>(HttpMethod.Post, path, body, ct), "searchMappingRule", false, ct);
    }

    /// <summary>
    /// Search group mapping rules
    /// Search mapping rules assigned to a group.
    /// </summary>
    /// <remarks>Operation: searchMappingRulesForGroup</remarks>
    public async Task<SearchQueryResponse> SearchMappingRulesForGroupAsync(string groupId, MappingRuleSearchQueryRequest body, ConsistencyOptions<SearchQueryResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/groups/{Uri.EscapeDataString(groupId.ToString()!)}/mapping-rules/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchMappingRulesForGroup", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchQueryResponse>(HttpMethod.Post, path, body, ct), "searchMappingRulesForGroup", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchQueryResponse>(HttpMethod.Post, path, body, ct), "searchMappingRulesForGroup", false, ct);
    }

    /// <summary>
    /// Search role mapping rules
    /// Search mapping rules with assigned role.
    /// </summary>
    /// <remarks>Operation: searchMappingRulesForRole</remarks>
    public async Task<SearchQueryResponse> SearchMappingRulesForRoleAsync(string roleId, MappingRuleSearchQueryRequest body, ConsistencyOptions<SearchQueryResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/roles/{Uri.EscapeDataString(roleId.ToString()!)}/mapping-rules/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchMappingRulesForRole", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchQueryResponse>(HttpMethod.Post, path, body, ct), "searchMappingRulesForRole", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchQueryResponse>(HttpMethod.Post, path, body, ct), "searchMappingRulesForRole", false, ct);
    }

    /// <summary>
    /// Search mapping rules for tenant
    /// Retrieves a filtered and sorted list of MappingRules for a specified tenant.
    /// </summary>
    /// <remarks>Operation: searchMappingRulesForTenant</remarks>
    public async Task<SearchQueryResponse> SearchMappingRulesForTenantAsync(TenantId tenantId, MappingRuleSearchQueryRequest body, ConsistencyOptions<SearchQueryResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}/mapping-rules/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchMappingRulesForTenant", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchQueryResponse>(HttpMethod.Post, path, body, ct), "searchMappingRulesForTenant", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchQueryResponse>(HttpMethod.Post, path, body, ct), "searchMappingRulesForTenant", false, ct);
    }

    /// <summary>
    /// Search message subscriptions
    /// Search for message subscriptions based on given criteria.
    /// </summary>
    /// <remarks>Operation: searchMessageSubscriptions</remarks>
    public async Task<SearchMessageSubscriptionsResponse> SearchMessageSubscriptionsAsync(SearchMessageSubscriptionsRequest body, ConsistencyOptions<SearchMessageSubscriptionsResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/message-subscriptions/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchMessageSubscriptions", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchMessageSubscriptionsResponse>(HttpMethod.Post, path, body, ct), "searchMessageSubscriptions", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchMessageSubscriptionsResponse>(HttpMethod.Post, path, body, ct), "searchMessageSubscriptions", false, ct);
    }

    /// <summary>
    /// Search process definitions
    /// Search for process definitions based on given criteria.
    /// </summary>
    /// <remarks>Operation: searchProcessDefinitions</remarks>
    public async Task<ProcessDefinitionSearchQueryResult> SearchProcessDefinitionsAsync(SearchProcessDefinitionsRequest body, ConsistencyOptions<ProcessDefinitionSearchQueryResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-definitions/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchProcessDefinitions", false,
                () => InvokeWithRetryAsync(() => SendAsync<ProcessDefinitionSearchQueryResult>(HttpMethod.Post, path, body, ct), "searchProcessDefinitions", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<ProcessDefinitionSearchQueryResult>(HttpMethod.Post, path, body, ct), "searchProcessDefinitions", false, ct);
    }

    /// <summary>
    /// Search related incidents
    /// Search for incidents caused by the process instance or any of its called process or decision instances.
    /// 
    /// Although the `processInstanceKey` is provided as a path parameter to indicate the root process instance,
    /// you may also include a `processInstanceKey` within the filter object to narrow results to specific
    /// child process instances. This is useful, for example, if you want to isolate incidents associated with
    /// subprocesses or called processes under the root instance while excluding incidents directly tied to the root.
    /// 
    /// </summary>
    /// <remarks>Operation: searchProcessInstanceIncidents</remarks>
    public async Task<SearchProcessInstanceIncidentsResponse> SearchProcessInstanceIncidentsAsync(ProcessInstanceKey processInstanceKey, IncidentSearchQuery body, ConsistencyOptions<SearchProcessInstanceIncidentsResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-instances/{Uri.EscapeDataString(processInstanceKey.ToString()!)}/incidents/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchProcessInstanceIncidents", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchProcessInstanceIncidentsResponse>(HttpMethod.Post, path, body, ct), "searchProcessInstanceIncidents", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchProcessInstanceIncidentsResponse>(HttpMethod.Post, path, body, ct), "searchProcessInstanceIncidents", false, ct);
    }

    /// <summary>
    /// Search process instances
    /// Search for process instances based on given criteria.
    /// </summary>
    /// <remarks>Operation: searchProcessInstances</remarks>
    public async Task<SearchProcessInstancesResponse> SearchProcessInstancesAsync(SearchProcessInstancesRequest body, ConsistencyOptions<SearchProcessInstancesResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/process-instances/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchProcessInstances", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchProcessInstancesResponse>(HttpMethod.Post, path, body, ct), "searchProcessInstances", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchProcessInstancesResponse>(HttpMethod.Post, path, body, ct), "searchProcessInstances", false, ct);
    }

    /// <summary>
    /// Search roles
    /// Search for roles based on given criteria.
    /// </summary>
    /// <remarks>Operation: searchRoles</remarks>
    public async Task<RoleSearchQueryResult> SearchRolesAsync(RoleSearchQueryRequest body, ConsistencyOptions<RoleSearchQueryResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/roles/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchRoles", false,
                () => InvokeWithRetryAsync(() => SendAsync<RoleSearchQueryResult>(HttpMethod.Post, path, body, ct), "searchRoles", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<RoleSearchQueryResult>(HttpMethod.Post, path, body, ct), "searchRoles", false, ct);
    }

    /// <summary>
    /// Search group roles
    /// Search roles assigned to a group.
    /// </summary>
    /// <remarks>Operation: searchRolesForGroup</remarks>
    public async Task<SearchQueryResponse> SearchRolesForGroupAsync(string groupId, RoleSearchQueryRequest body, ConsistencyOptions<SearchQueryResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/groups/{Uri.EscapeDataString(groupId.ToString()!)}/roles/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchRolesForGroup", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchQueryResponse>(HttpMethod.Post, path, body, ct), "searchRolesForGroup", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchQueryResponse>(HttpMethod.Post, path, body, ct), "searchRolesForGroup", false, ct);
    }

    /// <summary>
    /// Search roles for tenant
    /// Retrieves a filtered and sorted list of roles for a specified tenant.
    /// </summary>
    /// <remarks>Operation: searchRolesForTenant</remarks>
    public async Task<SearchQueryResponse> SearchRolesForTenantAsync(TenantId tenantId, RoleSearchQueryRequest body, ConsistencyOptions<SearchQueryResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}/roles/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchRolesForTenant", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchQueryResponse>(HttpMethod.Post, path, body, ct), "searchRolesForTenant", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchQueryResponse>(HttpMethod.Post, path, body, ct), "searchRolesForTenant", false, ct);
    }

    /// <summary>
    /// Search tenants
    /// Retrieves a filtered and sorted list of tenants.
    /// </summary>
    /// <remarks>Operation: searchTenants</remarks>
    public async Task<TenantSearchQueryResult> SearchTenantsAsync(SearchTenantsRequest body, ConsistencyOptions<TenantSearchQueryResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/tenants/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchTenants", false,
                () => InvokeWithRetryAsync(() => SendAsync<TenantSearchQueryResult>(HttpMethod.Post, path, body, ct), "searchTenants", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<TenantSearchQueryResult>(HttpMethod.Post, path, body, ct), "searchTenants", false, ct);
    }

    /// <summary>
    /// Search user task audit logs
    /// Search for user task audit logs based on given criteria.
    /// </summary>
    /// <remarks>Operation: searchUserTaskAuditLogs</remarks>
    public async Task<SearchUserTaskAuditLogsResponse> SearchUserTaskAuditLogsAsync(UserTaskKey userTaskKey, SearchUserTaskAuditLogsRequest body, ConsistencyOptions<SearchUserTaskAuditLogsResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/user-tasks/{Uri.EscapeDataString(userTaskKey.ToString()!)}/audit-logs/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchUserTaskAuditLogs", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchUserTaskAuditLogsResponse>(HttpMethod.Post, path, body, ct), "searchUserTaskAuditLogs", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchUserTaskAuditLogsResponse>(HttpMethod.Post, path, body, ct), "searchUserTaskAuditLogs", false, ct);
    }

    /// <summary>
    /// Search user task variables
    /// Search for user task variables based on given criteria. By default, long variable values in the response are truncated.
    /// </summary>
    /// <remarks>Operation: searchUserTaskVariables</remarks>
    public async Task<SearchUserTaskVariablesResponse> SearchUserTaskVariablesAsync(UserTaskKey userTaskKey, SearchUserTaskVariablesRequest body, bool? truncateValues = null, ConsistencyOptions<SearchUserTaskVariablesResponse>? consistency = null, CancellationToken ct = default)
    {
        var queryParts = new List<string>();
        if (truncateValues != null) queryParts.Add($"truncateValues={Uri.EscapeDataString(truncateValues.ToString()!)}");
        var path = queryParts.Count > 0 ? $"/user-tasks/{Uri.EscapeDataString(userTaskKey.ToString()!)}/variables/search?{string.Join("&", queryParts)}" : $"/user-tasks/{Uri.EscapeDataString(userTaskKey.ToString()!)}/variables/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchUserTaskVariables", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchUserTaskVariablesResponse>(HttpMethod.Post, path, body, ct), "searchUserTaskVariables", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchUserTaskVariablesResponse>(HttpMethod.Post, path, body, ct), "searchUserTaskVariables", false, ct);
    }

    /// <summary>
    /// Search user tasks
    /// Search for user tasks based on given criteria.
    /// </summary>
    /// <remarks>Operation: searchUserTasks</remarks>
    public async Task<SearchUserTasksResponse> SearchUserTasksAsync(SearchUserTasksRequest body, ConsistencyOptions<SearchUserTasksResponse>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/user-tasks/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchUserTasks", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchUserTasksResponse>(HttpMethod.Post, path, body, ct), "searchUserTasks", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchUserTasksResponse>(HttpMethod.Post, path, body, ct), "searchUserTasks", false, ct);
    }

    /// <summary>
    /// Search users
    /// Search for users based on given criteria.
    /// </summary>
    /// <remarks>Operation: searchUsers</remarks>
    public async Task<UserSearchResult> SearchUsersAsync(SearchUsersRequest body, ConsistencyOptions<UserSearchResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/users/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchUsers", false,
                () => InvokeWithRetryAsync(() => SendAsync<UserSearchResult>(HttpMethod.Post, path, body, ct), "searchUsers", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<UserSearchResult>(HttpMethod.Post, path, body, ct), "searchUsers", false, ct);
    }

    /// <summary>
    /// Search group users
    /// Search users assigned to a group.
    /// </summary>
    /// <remarks>Operation: searchUsersForGroup</remarks>
    public async Task<TenantUserSearchResult> SearchUsersForGroupAsync(string groupId, SearchUsersForGroupRequest body, ConsistencyOptions<TenantUserSearchResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/groups/{Uri.EscapeDataString(groupId.ToString()!)}/users/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchUsersForGroup", false,
                () => InvokeWithRetryAsync(() => SendAsync<TenantUserSearchResult>(HttpMethod.Post, path, body, ct), "searchUsersForGroup", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<TenantUserSearchResult>(HttpMethod.Post, path, body, ct), "searchUsersForGroup", false, ct);
    }

    /// <summary>
    /// Search role users
    /// Search users with assigned role.
    /// </summary>
    /// <remarks>Operation: searchUsersForRole</remarks>
    public async Task<TenantUserSearchResult> SearchUsersForRoleAsync(string roleId, SearchUsersForRoleRequest body, ConsistencyOptions<TenantUserSearchResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/roles/{Uri.EscapeDataString(roleId.ToString()!)}/users/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchUsersForRole", false,
                () => InvokeWithRetryAsync(() => SendAsync<TenantUserSearchResult>(HttpMethod.Post, path, body, ct), "searchUsersForRole", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<TenantUserSearchResult>(HttpMethod.Post, path, body, ct), "searchUsersForRole", false, ct);
    }

    /// <summary>
    /// Search users for tenant
    /// Retrieves a filtered and sorted list of users for a specified tenant.
    /// </summary>
    /// <remarks>Operation: searchUsersForTenant</remarks>
    public async Task<TenantUserSearchResult> SearchUsersForTenantAsync(TenantId tenantId, SearchUsersForTenantRequest body, ConsistencyOptions<TenantUserSearchResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}/users/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchUsersForTenant", false,
                () => InvokeWithRetryAsync(() => SendAsync<TenantUserSearchResult>(HttpMethod.Post, path, body, ct), "searchUsersForTenant", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<TenantUserSearchResult>(HttpMethod.Post, path, body, ct), "searchUsersForTenant", false, ct);
    }

    /// <summary>
    /// Search variables
    /// Search for process and local variables based on given criteria. By default, long variable values in the response are truncated.
    /// </summary>
    /// <remarks>Operation: searchVariables</remarks>
    public async Task<SearchVariablesResponse> SearchVariablesAsync(SearchVariablesRequest body, bool? truncateValues = null, ConsistencyOptions<SearchVariablesResponse>? consistency = null, CancellationToken ct = default)
    {
        var queryParts = new List<string>();
        if (truncateValues != null) queryParts.Add($"truncateValues={Uri.EscapeDataString(truncateValues.ToString()!)}");
        var path = queryParts.Count > 0 ? $"/variables/search?{string.Join("&", queryParts)}" : $"/variables/search";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("searchVariables", false,
                () => InvokeWithRetryAsync(() => SendAsync<SearchVariablesResponse>(HttpMethod.Post, path, body, ct), "searchVariables", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<SearchVariablesResponse>(HttpMethod.Post, path, body, ct), "searchVariables", false, ct);
    }

    /// <summary>
    /// Suspend Batch operation
    /// Suspends a running batch operation.
    /// This is done asynchronously, the progress can be tracked using the batch operation status endpoint (/batch-operations/{batchOperationKey}).
    /// 
    /// </summary>
    /// <remarks>Operation: suspendBatchOperation</remarks>
    public async Task SuspendBatchOperationAsync(BatchOperationKey batchOperationKey, ConsistencyOptions<object>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/batch-operations/{Uri.EscapeDataString(batchOperationKey.ToString()!)}/suspension";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            await EventualPoller.PollAsync("suspendBatchOperation", false,
                async () => { await SendVoidAsync(HttpMethod.Post, path, null, ct); return new object(); },
                consistency!, _logger, ct);
            return;
        }

        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Post, path, null, ct); return 0; }, "suspendBatchOperation", false, ct);
    }

    /// <summary>
    /// Throw error for job
    /// Reports a business error (i.e. non-technical) that occurs while processing a job.
    /// 
    /// </summary>
    /// <remarks>Operation: throwJobError</remarks>
    public async Task ThrowJobErrorAsync(JobKey jobKey, JobErrorRequest body, CancellationToken ct = default)
    {
        var path = $"/jobs/{Uri.EscapeDataString(jobKey.ToString()!)}/error";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Post, path, body, ct); return 0; }, "throwJobError", true, ct);
    }

    /// <summary>
    /// Unassign a client from a group
    /// Unassigns a client from a group.
    /// The client is removed as a group member, with associated authorizations, roles, and tenant assignments no longer applied.
    /// 
    /// </summary>
    /// <remarks>Operation: unassignClientFromGroup</remarks>
    public async Task UnassignClientFromGroupAsync(string groupId, string clientId, CancellationToken ct = default)
    {
        var path = $"/groups/{Uri.EscapeDataString(groupId.ToString()!)}/clients/{Uri.EscapeDataString(clientId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "unassignClientFromGroup", false, ct);
    }

    /// <summary>
    /// Unassign a client from a tenant
    /// Unassigns the client from the specified tenant.
    /// The client can no longer access tenant data.
    /// 
    /// </summary>
    /// <remarks>Operation: unassignClientFromTenant</remarks>
    public async Task UnassignClientFromTenantAsync(TenantId tenantId, string clientId, CancellationToken ct = default)
    {
        var path = $"/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}/clients/{Uri.EscapeDataString(clientId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "unassignClientFromTenant", false, ct);
    }

    /// <summary>
    /// Unassign a group from a tenant
    /// Unassigns a group from a specified tenant.
    /// Members of the group (users, clients) will no longer have access to the tenant's data - except they are assigned directly to the tenant.
    /// 
    /// </summary>
    /// <remarks>Operation: unassignGroupFromTenant</remarks>
    public async Task UnassignGroupFromTenantAsync(TenantId tenantId, string groupId, CancellationToken ct = default)
    {
        var path = $"/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}/groups/{Uri.EscapeDataString(groupId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "unassignGroupFromTenant", false, ct);
    }

    /// <summary>
    /// Unassign a mapping rule from a group
    /// Unassigns a mapping rule from a group.
    /// </summary>
    /// <remarks>Operation: unassignMappingRuleFromGroup</remarks>
    public async Task UnassignMappingRuleFromGroupAsync(string groupId, string mappingRuleId, CancellationToken ct = default)
    {
        var path = $"/groups/{Uri.EscapeDataString(groupId.ToString()!)}/mapping-rules/{Uri.EscapeDataString(mappingRuleId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "unassignMappingRuleFromGroup", false, ct);
    }

    /// <summary>
    /// Unassign a mapping rule from a tenant
    /// Unassigns a single mapping rule from a specified tenant without deleting the rule.
    /// </summary>
    /// <remarks>Operation: unassignMappingRuleFromTenant</remarks>
    public async Task UnassignMappingRuleFromTenantAsync(TenantId tenantId, string mappingRuleId, CancellationToken ct = default)
    {
        var path = $"/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}/mapping-rules/{Uri.EscapeDataString(mappingRuleId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "unassignMappingRuleFromTenant", false, ct);
    }

    /// <summary>
    /// Unassign a role from a client
    /// Unassigns the specified role from the client. The client will no longer inherit the authorizations associated with this role.
    /// </summary>
    /// <remarks>Operation: unassignRoleFromClient</remarks>
    public async Task UnassignRoleFromClientAsync(string roleId, string clientId, CancellationToken ct = default)
    {
        var path = $"/roles/{Uri.EscapeDataString(roleId.ToString()!)}/clients/{Uri.EscapeDataString(clientId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "unassignRoleFromClient", false, ct);
    }

    /// <summary>
    /// Unassign a role from a group
    /// Unassigns the specified role from the group. All group members (user or client) no longer inherit the authorizations associated with this role.
    /// </summary>
    /// <remarks>Operation: unassignRoleFromGroup</remarks>
    public async Task UnassignRoleFromGroupAsync(string roleId, string groupId, CancellationToken ct = default)
    {
        var path = $"/roles/{Uri.EscapeDataString(roleId.ToString()!)}/groups/{Uri.EscapeDataString(groupId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "unassignRoleFromGroup", false, ct);
    }

    /// <summary>
    /// Unassign a role from a mapping rule
    /// Unassigns a role from a mapping rule.
    /// </summary>
    /// <remarks>Operation: unassignRoleFromMappingRule</remarks>
    public async Task UnassignRoleFromMappingRuleAsync(string roleId, string mappingRuleId, CancellationToken ct = default)
    {
        var path = $"/roles/{Uri.EscapeDataString(roleId.ToString()!)}/mapping-rules/{Uri.EscapeDataString(mappingRuleId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "unassignRoleFromMappingRule", false, ct);
    }

    /// <summary>
    /// Unassign a role from a tenant
    /// Unassigns a role from a specified tenant.
    /// Users, Clients or Groups, that have the role assigned, will no longer have access to the
    /// tenant's data - unless they are assigned directly to the tenant.
    /// 
    /// </summary>
    /// <remarks>Operation: unassignRoleFromTenant</remarks>
    public async Task UnassignRoleFromTenantAsync(TenantId tenantId, string roleId, CancellationToken ct = default)
    {
        var path = $"/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}/roles/{Uri.EscapeDataString(roleId.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "unassignRoleFromTenant", false, ct);
    }

    /// <summary>
    /// Unassign a role from a user
    /// Unassigns a role from a user. The user will no longer inherit the authorizations associated with this role.
    /// </summary>
    /// <remarks>Operation: unassignRoleFromUser</remarks>
    public async Task UnassignRoleFromUserAsync(string roleId, Username username, CancellationToken ct = default)
    {
        var path = $"/roles/{Uri.EscapeDataString(roleId.ToString()!)}/users/{Uri.EscapeDataString(username.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "unassignRoleFromUser", false, ct);
    }

    /// <summary>
    /// Unassign a user from a group
    /// Unassigns a user from a group.
    /// The user is removed as a group member, with associated authorizations, roles, and tenant assignments no longer applied.
    /// 
    /// </summary>
    /// <remarks>Operation: unassignUserFromGroup</remarks>
    public async Task UnassignUserFromGroupAsync(string groupId, Username username, CancellationToken ct = default)
    {
        var path = $"/groups/{Uri.EscapeDataString(groupId.ToString()!)}/users/{Uri.EscapeDataString(username.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "unassignUserFromGroup", false, ct);
    }

    /// <summary>
    /// Unassign a user from a tenant
    /// Unassigns the user from the specified tenant.
    /// The user can no longer access tenant data.
    /// 
    /// </summary>
    /// <remarks>Operation: unassignUserFromTenant</remarks>
    public async Task UnassignUserFromTenantAsync(TenantId tenantId, Username username, CancellationToken ct = default)
    {
        var path = $"/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}/users/{Uri.EscapeDataString(username.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "unassignUserFromTenant", false, ct);
    }

    /// <summary>
    /// Unassign user task
    /// Removes the assignee of a task with the given key.
    /// </summary>
    /// <remarks>Operation: unassignUserTask</remarks>
    public async Task UnassignUserTaskAsync(UserTaskKey userTaskKey, CancellationToken ct = default)
    {
        var path = $"/user-tasks/{Uri.EscapeDataString(userTaskKey.ToString()!)}/assignee";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Delete, path, null, ct); return 0; }, "unassignUserTask", false, ct);
    }

    /// <summary>
    /// Update authorization
    /// Update the authorization with the given key.
    /// </summary>
    /// <remarks>Operation: updateAuthorization</remarks>
    public async Task UpdateAuthorizationAsync(AuthorizationKey authorizationKey, AuthorizationRequest body, CancellationToken ct = default)
    {
        var path = $"/authorizations/{Uri.EscapeDataString(authorizationKey.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Put, path, body, ct); return 0; }, "updateAuthorization", false, ct);
    }

    /// <summary>
    /// Update a global-scoped cluster variable
    /// Updates the value of an existing global cluster variable.
    /// The variable must exist, otherwise a 404 error is returned.
    /// 
    /// </summary>
    /// <remarks>Operation: updateGlobalClusterVariable</remarks>
    public async Task<ClusterVariableResult> UpdateGlobalClusterVariableAsync(string name, UpdateClusterVariableRequest body, CancellationToken ct = default)
    {
        var path = $"/cluster-variables/global/{Uri.EscapeDataString(name.ToString()!)}";
        return await InvokeWithRetryAsync(() => SendAsync<ClusterVariableResult>(HttpMethod.Put, path, body, ct), "updateGlobalClusterVariable", false, ct);
    }

    /// <summary>
    /// Update group
    /// Update a group with the given ID.
    /// </summary>
    /// <remarks>Operation: updateGroup</remarks>
    public async Task<GroupUpdateResult> UpdateGroupAsync(string groupId, GroupUpdateRequest body, CancellationToken ct = default)
    {
        var path = $"/groups/{Uri.EscapeDataString(groupId.ToString()!)}";
        return await InvokeWithRetryAsync(() => SendAsync<GroupUpdateResult>(HttpMethod.Put, path, body, ct), "updateGroup", false, ct);
    }

    /// <summary>
    /// Update job
    /// Update a job with the given key.
    /// </summary>
    /// <remarks>Operation: updateJob</remarks>
    public async Task UpdateJobAsync(JobKey jobKey, JobUpdateRequest body, CancellationToken ct = default)
    {
        var path = $"/jobs/{Uri.EscapeDataString(jobKey.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Patch, path, body, ct); return 0; }, "updateJob", false, ct);
    }

    /// <summary>
    /// Update mapping rule
    /// Update a mapping rule.
    /// 
    /// </summary>
    /// <remarks>Operation: updateMappingRule</remarks>
    public async Task<MappingRuleUpdateResult> UpdateMappingRuleAsync(string mappingRuleId, MappingRuleUpdateRequest body, CancellationToken ct = default)
    {
        var path = $"/mapping-rules/{Uri.EscapeDataString(mappingRuleId.ToString()!)}";
        return await InvokeWithRetryAsync(() => SendAsync<MappingRuleUpdateResult>(HttpMethod.Put, path, body, ct), "updateMappingRule", false, ct);
    }

    /// <summary>
    /// Update role
    /// Update a role with the given ID.
    /// </summary>
    /// <remarks>Operation: updateRole</remarks>
    public async Task<RoleUpdateResult> UpdateRoleAsync(string roleId, RoleUpdateRequest body, CancellationToken ct = default)
    {
        var path = $"/roles/{Uri.EscapeDataString(roleId.ToString()!)}";
        return await InvokeWithRetryAsync(() => SendAsync<RoleUpdateResult>(HttpMethod.Put, path, body, ct), "updateRole", false, ct);
    }

    /// <summary>
    /// Update tenant
    /// Updates an existing tenant.
    /// </summary>
    /// <remarks>Operation: updateTenant</remarks>
    public async Task<TenantUpdateResult> UpdateTenantAsync(TenantId tenantId, TenantUpdateRequest body, CancellationToken ct = default)
    {
        var path = $"/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}";
        return await InvokeWithRetryAsync(() => SendAsync<TenantUpdateResult>(HttpMethod.Put, path, body, ct), "updateTenant", false, ct);
    }

    /// <summary>
    /// Update a tenant-scoped cluster variable
    /// Updates the value of an existing tenant-scoped cluster variable.
    /// The variable must exist, otherwise a 404 error is returned.
    /// 
    /// </summary>
    /// <remarks>Operation: updateTenantClusterVariable</remarks>
    public async Task<ClusterVariableResult> UpdateTenantClusterVariableAsync(TenantId tenantId, string name, UpdateClusterVariableRequest body, CancellationToken ct = default)
    {
        var path = $"/cluster-variables/tenants/{Uri.EscapeDataString(tenantId.ToString()!)}/{Uri.EscapeDataString(name.ToString()!)}";
        return await InvokeWithRetryAsync(() => SendAsync<ClusterVariableResult>(HttpMethod.Put, path, body, ct), "updateTenantClusterVariable", false, ct);
    }

    /// <summary>
    /// Update user
    /// Updates a user.
    /// </summary>
    /// <remarks>Operation: updateUser</remarks>
    public async Task<UserResult> UpdateUserAsync(Username username, UserUpdateRequest body, ConsistencyOptions<UserResult>? consistency = null, CancellationToken ct = default)
    {
        var path = $"/users/{Uri.EscapeDataString(username.ToString()!)}";
        if (consistency != null && consistency.WaitUpToMs > 0)
        {
            return await EventualPoller.PollAsync("updateUser", false,
                () => InvokeWithRetryAsync(() => SendAsync<UserResult>(HttpMethod.Put, path, body, ct), "updateUser", false, ct),
                consistency!, _logger, ct);
        }

        return await InvokeWithRetryAsync(() => SendAsync<UserResult>(HttpMethod.Put, path, body, ct), "updateUser", false, ct);
    }

    /// <summary>
    /// Update user task
    /// Update a user task with the given key.
    /// </summary>
    /// <remarks>Operation: updateUserTask</remarks>
    public async Task UpdateUserTaskAsync(UserTaskKey userTaskKey, UserTaskUpdateRequest body, CancellationToken ct = default)
    {
        var path = $"/user-tasks/{Uri.EscapeDataString(userTaskKey.ToString()!)}";
        await InvokeWithRetryAsync(async () => { await SendVoidAsync(HttpMethod.Patch, path, body, ct); return 0; }, "updateUserTask", false, ct);
    }

}
